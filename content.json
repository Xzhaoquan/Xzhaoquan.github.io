{"meta":{"title":"个人博客","subtitle":"Siwat","description":"","author":"Napat","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Qt文件读写","slug":"Qt文件读写","date":"2023-09-21T08:17:49.000Z","updated":"2023-09-21T08:33:32.708Z","comments":true,"path":"2023/09/21/Qt文件读写/","link":"","permalink":"http://example.com/2023/09/21/Qt%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/","excerpt":"","text":"Qt文件读写QFileQFile 是一个读写文本、二进制文件和资源的 I&#x2F;O 设备。 QFile 可以自己使用，也可以更方便地与 QTextStream 或 QDataStream 一起使用。 QFile常用操作函数 exists()检查文件是否存在 remove()删除文件 open()打开文件 close()关闭文件 flush()刷新文件 read()读取文件 write()写入文件 通常使用 QDataStream 或 QTextStream 读写数据，但也可以调用 QIODevice 继承的函数 read()、readLine()、 readAll()、 write()。 QFile 还继承 getChar()、 putChar()和 ungetChar()，它们一次只处理一个字符。文件的大小由 size()返回。可以使用 pos()获取当前文件位置，也可以使用 seek()移动到新的文件位置。如果已经到达文件的末尾，则 atEnd()返回 true。 QFile::open()函数打开文件时需要传递 QIODevice::OpenModeFlag 枚举类型的参数，决定文件以什么方式打开， QIODevice::OpenModeFlag 类型的主要取值如下 QIODevice::ReadOnly：以只读方式打开文件，用于载入文件。 QIODevice::WriteOnly：以只写方式打开文件，用于保存文件。 QIODevice::ReadWrite：以读写方式打开。 QIODevice::Append：以添加模式打开，新写入文件的数据添加到文件尾部。 QIODevice::Truncate：以截取方式打开文件，文件原有的内容全部被删除。 QIODevice::Text：以文本方式打开文件，读取时“\\n”被自动翻译为换行符，写入时字符串结束符会自动翻译为系统平台的编码，如 Windows 平台下是“\\r\\n”。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &quot;mainwindow.h&quot;#include &lt;QFileDialog&gt;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(); vBoxLayout = new QVBoxLayout(); hBoxLayout = new QHBoxLayout(); vWidget = new QWidget(); hWidget = new QWidget(); openFileButton = new QPushButton(); closeFileButton = new QPushButton(); /*设置两个按钮大小*/ openFileButton-&gt;setMaximumHeight(50); openFileButton-&gt;setMaximumWidth(120); closeFileButton-&gt;setMaximumHeight(50); closeFileButton-&gt;setMaximumWidth(120); openFileButton-&gt;setText(&quot;打开&quot;); closeFileButton-&gt;setText(&quot;关闭&quot;); /*将按钮设置为不可用*/ closeFileButton-&gt;setEnabled(false); /*水平布局*/ hBoxLayout-&gt;addWidget(openFileButton); hBoxLayout-&gt;addWidget(closeFileButton); hWidget-&gt;setLayout(hBoxLayout); /*垂直布局*/ vBoxLayout-&gt;addWidget(textEdit); vBoxLayout-&gt;addWidget(hWidget); vWidget-&gt;setLayout(vBoxLayout); /*设置vWidget居中*/ setCentralWidget(vWidget); connect(openFileButton,SIGNAL(clicked()),this,SLOT(openFile())); connect(closeFileButton,SIGNAL(clicked()),this,SLOT(closeFile()));&#125;bool MainWindow::openFile()&#123; QString file_name = QFileDialog::getOpenFileName(this); /*指向文件*/ file.setFileName(file_name); /*判断文件是否存在*/ if(!file.exists())&#123; return false; &#125; /*打开文件*/ if(!file.open(QIODevice::ReadOnly | QIODevice::Text))&#123; return false; &#125; /*读取文本到textEdit*/ textEdit-&gt;setPlainText(file.readAll()); /*设置打开按钮不可用*/ openFileButton-&gt;setEnabled(false); /*设置关闭按钮可用*/ closeFileButton-&gt;setEnabled(true); file.close(); return true;&#125;void MainWindow::closeFile()&#123; /*检测打开按钮openFileButton是否可用,不可用时表示打开了文件*/ if(!openFileButton-&gt;isEnabled())&#123; /*获取textEdit的文本内容*/ QString str = textEdit-&gt;toPlainText(); if(!file.open(QIODevice::WriteOnly | QIODevice::Text))&#123; return; &#125; QByteArray strBytes = str.toUtf8(); file.write(strBytes,strBytes.length()); textEdit-&gt;clear(); file.close(); /*重新设置按钮属性*/ openFileButton-&gt;setEnabled(true); closeFileButton-&gt;setEnabled(false); &#125;&#125; ui示例 QTextStreamQTextStream 类为读写文本提供了一个方便的接口，常与 QFile 结合使用。 可以使用 C++的操作符“&lt;&lt;”和“&gt;&gt;” (流提取运算符和流插入运算符)进行操作流了 代码QFile代码类似，代码部分示例12345/*使用文本流读取文件*/QTextStream stream(&amp;file);/*读取文本到textEdit*/textEdit-&gt;setPlainText(stream.readAll()); 12345QTextStream stream(&amp;file);/*获取textEdit的文本内容，转换成字符串*/QString str = textEdit-&gt;toPlainText();/*使用流提取运算符*/stream&lt;&lt;str; ui同QFile一致","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt项目控件组","slug":"Qt项目控件组","date":"2023-09-21T06:03:41.000Z","updated":"2023-09-21T07:24:15.556Z","comments":true,"path":"2023/09/21/Qt项目控件组/","link":"","permalink":"http://example.com/2023/09/21/Qt%E9%A1%B9%E7%9B%AE%E6%8E%A7%E4%BB%B6%E7%BB%84/","excerpt":"","text":"Qt项目控件组QListWidgetQListWidget 类提供了一个基于项的列表小部件。 QListWidget 是一个便捷的类，它提供了一个类似于 QListView（下一小节将讲到）提供的列表视图，但是提供了一个用于添加和删除项目的基于项目的经典接口。 QListWidget 使用内部模型来管理列表中的每个 QListWidgetItem。 代码示例12345678910111213141516171819202122232425262728#include &quot;mainwindow.h&quot;#include &lt;QFileDialog&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); listWidget = new QListWidget(this); /*设置listWidget的大小*/ listWidget-&gt;setGeometry(0,0,480,480); listWidget-&gt;addItem(&quot;请点击右边的添加项添加内容&quot;); button = new QPushButton(this); button-&gt;setGeometry(540,200,200,100); button-&gt;setText(&quot;添加项&quot;); connect(button,SIGNAL(clicked()),this,SLOT(buttonClicked()));&#125;void MainWindow::buttonClicked()&#123; /*调用系统窗口打开文件，过滤文件名*/ QString file_name = QFileDialog::getOpenFileName(this, tr(&quot;添加项&quot;), &quot;&quot;, tr(&quot;Files(*.mp3)&quot;)); if(file_name != NULL)&#123; listWidget-&gt;addItem(file_name); &#125;&#125; ui示例 QTreeWidgetQTreeWidget 类提供了一个使用预定义树模型的树视图。QTreeWidget 类是一个便捷的类，它提供了一个标准的树小部件，具有一个类似于 qt3 中的 QListView 类所使用的基于项目的经典接口。该类基于 Qt 的模型&#x2F;视图体系结构，并使用默认模型来保存项，每个项都是 QTreeWidgetItem。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); treeWidget = new QTreeWidget(this); this-&gt;setCentralWidget(treeWidget); /*清空列表*/ treeWidget-&gt;clear(); /*实例化顶层树节点*/ upItem = new QTreeWidgetItem(treeWidget); upItem-&gt;setText(0,&quot;同学&quot;); upItem-&gt;setFlags(Qt::ItemIsUserCheckable| Qt::ItemIsEnabled| Qt::ItemIsSelectable); /*树节点设置为未选中*/ upItem-&gt;setCheckState(0,Qt::Unchecked); QList &lt;QString&gt; strList; strList&lt;&lt;&quot;小明&quot;&lt;&lt;&quot;小红&quot;&lt;&lt;&quot;小蓝&quot;; /*在顶层节点下面实例化3个子节点*/ for(int i = 0;i &lt; 3;i ++)&#123; subItem[i] = new QTreeWidgetItem(upItem); subItem[i]-&gt;setText(0,strList[i]); /*设置子节点的属性为用户可选，项开启，项可选*/ subItem[i]-&gt;setFlags(Qt::ItemIsUserCheckable| Qt::ItemIsEnabled| Qt::ItemIsSelectable); /*设置子节点的状态为未选中*/ subItem[i]-&gt;setCheckState(0,Qt::Unchecked); &#125; connect(treeWidget,SIGNAL(itemChanged(QTreeWidgetItem*,int)),this,SLOT(treeItemChanged(QTreeWidgetItem*,int)));&#125;/*子节点跟新处理函数*/void MainWindow::subItemHandle(QTreeWidgetItem *item)&#123; /*获取节点的上层节点*/ QTreeWidgetItem *parentItem = item-&gt;parent(); if(parentItem == NULL)&#123; return; &#125; /*初始化选中的数目为0,下面根据selectCount来判断树节点的状态*/ int selectCount = 0; /*获取子节点的总数*/ int childCount = parentItem-&gt;childCount(); for(int i = 0;i &lt; childCount;i ++)&#123; QTreeWidgetItem *childItem = parentItem-&gt;child(i); /*判断当前节点的状态是否为选中状态，如果是则加1*/ if(childItem-&gt;checkState(0) == Qt::Checked)&#123; selectCount ++; &#125; &#125; /*根据selectCount来判断树节点的状态*/ /*当选中的子节点小于或等于0时，则设置树节点为未选中的状态*/ if(selectCount &lt;= 0)&#123; /*设置为未选中状态*/ parentItem-&gt;setCheckState(0,Qt::Unchecked); &#125;else if(selectCount &gt; 0 &amp;&amp; selectCount &lt; childCount)&#123; /*设置为半选中状态*/ parentItem-&gt;setCheckState(0,Qt::PartiallyChecked); &#125;else if(selectCount == childCount)&#123; /*设置为全选中状态*/ parentItem-&gt;setCheckState(0,Qt::Checked); &#125;else&#123; &#125;&#125;void MainWindow::treeItemChanged(QTreeWidgetItem *item,int value)&#123; (void) value; /*获取子节点个数*/ int count = item-&gt;childCount(); /*如果顶层节点被选中*/ if(Qt::Checked == item-&gt;checkState(0))&#123; /*若选中的项是树节点,count会大于0，否则选中的项是子节点*/ if(count &gt; 0)&#123; for(int i = 0;i &lt; count;i ++)&#123; item-&gt;child(i)-&gt;setCheckState(0,Qt::Checked); &#125; &#125;else&#123; /*子节点处理*/ subItemHandle(item); &#125; /*如果顶层节点取消选中*/ &#125;else if(Qt::Unchecked == item-&gt;checkState(0))&#123; if(count &gt; 0)&#123; /*如果选中的是树节点*/ for(int i = 0;i &lt; count;i ++)&#123; item-&gt;child(i)-&gt;setCheckState(0,Qt::Unchecked); &#125; &#125;else&#123; subItemHandle(item); &#125; &#125;&#125; ui示例 QTableWidgetQTableWidget 类提供了一个带有默认模型的基于项的表视图。表小部件为应用程序提供标准的表显示工具。 代码示例123456789101112131415161718192021222324252627#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); tableWidget = new QTableWidget(); this-&gt;setCentralWidget(tableWidget); /*设置列数*/ tableWidget-&gt;setColumnCount(2); /*设置行数*/ tableWidget-&gt;setRowCount(2); /*使用标签设置水平标题标签*/ tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;); QList &lt;QString&gt; strList; strList&lt;&lt;&quot;小明&quot;&lt;&lt;&quot;小红&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;女&quot;; for(int i = 0;i &lt; 4;i ++)&#123; tableWidgetItem[i] = new QTableWidgetItem(); tableWidgetItem[i]-&gt;setText(strList[i]); tableWidgetItem[i]-&gt;setTextAlignment(Qt::AlignCenter); &#125; /*插入数据表的index，一个二位数组数据*/ tableWidget-&gt;setItem(0,0,tableWidgetItem[0]); tableWidget-&gt;setItem(1,0,tableWidgetItem[1]); tableWidget-&gt;setItem(0,1,tableWidgetItem[2]); tableWidget-&gt;setItem(1,1,tableWidgetItem[3]);&#125; ui示例","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"代码编程规范","slug":"代码编程规范","date":"2023-09-20T09:10:10.000Z","updated":"2023-09-20T09:14:17.722Z","comments":true,"path":"2023/09/20/代码编程规范/","link":"","permalink":"http://example.com/2023/09/20/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/","excerpt":"","text":"代码编程规范宏定义宏定义使用字母加下划线 1#define EXAMPLE_A_B 变量变量使用小写字母加下划线 1char example_a_b; 函数函数使用驼峰命名法 123void functionExample(void)&#123;&#125;","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Qt项目视图组","slug":"Qt项目视图组","date":"2023-09-20T08:03:13.000Z","updated":"2023-09-21T05:59:33.977Z","comments":true,"path":"2023/09/20/Qt项目视图组/","link":"","permalink":"http://example.com/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/","excerpt":"","text":"Qt项目视图组QListViewQListView 类提供模型上的列表或图标视图。 QListView 以简单的非分层列表或图标集合的形式显示存储在模型中的项。 QT 提供了一些现成的 models 用于处理数据项（这些是 Qt 处理数据模型的精华，如果用到Qt 数据模型，下面这些是经常要用到的）： QStringListModel 用于存储简单的 QString 列表。 QStandardItemModel 管理复杂的树型结构数据项，每项都可以包含任意数据。 QDirModel 提供本地文件系统中的文件与目录信息。 QSqlQueryModel, QSqlTableModel,QSqlRelationTableModel 用来访问数据库。 代码示例12345678910111213141516171819202122#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); listView = new QListView(this); this-&gt;setCentralWidget(listView); QStringList strList; strList&lt;&lt;&quot;高三(1)班&quot;&lt;&lt;&quot;高三(2)班&quot;&lt;&lt;&quot;高三(3)班&quot;&lt;&lt;&quot;高三(4)班&quot;; /*实例化字符串模型*/ stringListModel = new QStringListModel(strList); /*向表中插入一段数据*/ listView-&gt;setModel(stringListModel); /*设置视图为图标模式*/ listView-&gt;setViewMode(QListView::IconMode); /*设置为不可拖动*/ listView-&gt;setDragEnabled(false);&#125; ui示例 QTreeViewQTreeView 类提供树视图的默认模型&#x2F;视图实现。 QTreeView 实现了模型项的树表示。 要使一个 QTreeView 能够显示数据，需要构造一个 model 并设置 QTreeView。 Qt 提供了一些类型的 Model，其中最常用的就是这个QStandardItemModel 类，一般可以满足大部分需求。 另外，表头的内容也由这个 model管理，setHorizontalHeaderLabels 函数可以设置共有多少列、每列文字。一级标题直接使用 appendRow方法添加到 model 上，次级标题则是添加到第一个父级标题上，依次构成父子关系树。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;mainwindow.h&quot;#include &lt;QStandardItem&gt;#include &lt;QStandardItemModel&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); treeView = new QTreeView(this); this-&gt;setCentralWidget(treeView); /*构建modle*/ QStandardItemModel *sdiModule = new QStandardItemModel(treeView); sdiModule-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;QStringLiteral(&quot;标题&quot;) &lt;&lt; QStringLiteral(&quot;名称&quot;)); for(int i = 0;i &lt; 5;i ++)&#123; /*一级标题*/ QList &lt;QStandardItem *&gt; items1; QStandardItem *item1 = new QStandardItem(QString::number(i)); QStandardItem *item2 = new QStandardItem(QStringLiteral(&quot;一级标题&quot;)); /*添加项1*/ items1.append(item1); /*添加项2*/ items1.append(item2); /*将items1添加到sdiModule*/ sdiModule-&gt;appendRow(items1); for(int j = 0;j &lt; 5;j ++)&#123; /*在一级标题后面插入二级标题*/ QList &lt;QStandardItem *&gt; items2; QStandardItem * item3 = new QStandardItem(QString::number(j)); QStandardItem * item4 = new QStandardItem(QStringLiteral(&quot;二级标题&quot;)); items2.append(item3); items2.append(item4); item1-&gt;appendRow(items2); &#125; &#125; treeView-&gt;setModel(sdiModule);&#125; ui示例 QTableViewQTableView 类提供了表视图的默认模型&#x2F;视图实现。 QTableView 实现了一个表视图，用于显示来自模型的项。 Qt 提供了一些类型的 Model，其中最常用的就是这个QStandardItemModel 类，一般可以满足大部分需求。另外，表头的内容也由这个 model 管理，setHorizontalHeaderLabels 函数可以设置共有多少列、每列文字。 代码示例123456789101112131415161718192021222324252627282930313233343536#include &quot;mainwindow.h&quot;#include &lt;QStandardItemModel&gt;#include &lt;QHeaderView&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); tableView = new QTableView(this); this-&gt;setCentralWidget(tableView); /*显示网格线*/ tableView-&gt;setShowGrid(true); QStandardItemModel *model = new QStandardItemModel(); QStringList lables = QObject::tr(&quot;语文,数学,英语&quot;).simplified().split(&quot;,&quot;); /*设置水平头标签*/ model-&gt;setHorizontalHeaderLabels(lables); /*model插入内容*/ QStandardItem * item = 0; for(int i = 0;i &lt; 5;i ++)&#123; item = new QStandardItem(&quot;80&quot;); model-&gt;setItem(i,0,item); item = new QStandardItem(&quot;90&quot;); model-&gt;setItem(i,1,item); item = new QStandardItem(&quot;100&quot;); model-&gt;setItem(i,2,item); &#125; /*将model设置给tableView*/ tableView-&gt;setModel(model); /*平均分列*/ tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch); /*平均分行*/ tableView-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch);&#125; ui示例 QColumnViewQColumnView 在许多 QListViews 中显示一个模型，每个 QListViews 对应树中的每个层次结构。这有时被称为级联列表。 QColumnView 类是模型&#x2F;视图类之一，是 Qt 模型&#x2F;视图框架的一部分。 代码示例12345678910111213141516171819202122232425262728293031#include &quot;mainwindow.h&quot;#include &lt;QStandardItem&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); columnView = new QColumnView(this); this-&gt;setCentralWidget(columnView); QStandardItemModel *model = new QStandardItemModel(this); /*省份*/ QStandardItem *province = new QStandardItem(&quot;四川省&quot;); /*城市*/ QStandardItem *city1 = new QStandardItem(&quot;成都市&quot;); QStandardItem *city2 = new QStandardItem(&quot;绵阳市&quot;); /*将城市添加到省份*/ province-&gt;appendRow(city1); province-&gt;appendRow(city2); /*区域*/ QStandardItem *area1 = new QStandardItem(&quot;武侯区&quot;); QStandardItem *area2 = new QStandardItem(&quot;金牛区&quot;); /*将区域添加到城市*/ city1-&gt;appendRow(area1); city1-&gt;appendRow(area2); model-&gt;appendRow(province); columnView-&gt;setModel(model);&#125; ui示例 QundoViewQUndoView 类显示 QUndoStack 的内容。 QUndoView 是一个QListView，它显示在撤销堆栈上推送的命令列表。总是选择最近执行的命令。选择不同的命令会导致调用QUndoStack::setIndex()，将文档的状态向后或向前滚动到新命令。可以使用setStack()显式地设置堆栈。 代码示例mainWindow.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &quot;mainwindow.h&quot;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; /* 设置主窗体显示的位置与大小 */ this-&gt;setGeometry(0, 0, 800, 480); /* 实例一个水平布局，用于左侧按钮区域与右侧历史记录面板 */ hLayout = new QHBoxLayout(); /* 实例一个水平布局，用于左侧标签与按钮 */ vLayout = new QVBoxLayout(); /* 主Widget, 因为MainWindow自带一个布局， * 我们要新建一个Widget容纳新布局 */ mainWidget = new QWidget(); /* 用于存放命令行栈 */ undoStack = new QUndoStack(this); /* 用于容纳左侧标签与按钮布局 */ widget = new QWidget(); /* 历史记录面板实例化 */ undoView = new QUndoView(undoStack); /* 实例化一个按钮，用于加一操作 */ pushButton = new QPushButton(); /* 标签，用于显示计算结果 */ label = new QLabel(); /* 设置widget的大小 */ widget-&gt;setMinimumSize(400, 480); /* 将两个widget添加到水平布局 */ hLayout-&gt;addWidget(widget); hLayout-&gt;addWidget(undoView); /* 初始化count的值 */ count = 0; /* 显示初始化计算结果 */ label-&gt;setText(&quot;计算结果：&quot; + QString::number(count)); label-&gt;setAlignment(Qt::AlignCenter); /* 左侧布局 */ vLayout-&gt;addWidget(label); vLayout-&gt;addWidget(pushButton); /* 左侧布局控件的高度设置 */ label-&gt;setMaximumHeight(this-&gt;height() / 5); pushButton-&gt;setMaximumHeight(this-&gt;height() / 5); /* 按钮文件设置 */ pushButton-&gt;setText(&quot;加1&quot;); /* 设置widget的布局为vLayout */ widget-&gt;setLayout(vLayout); /* 将主窗体的布局设置为hLayout */ mainWidget-&gt;setLayout(hLayout); /* 设置mainWidget为主窗体的居中widget */ this-&gt;setCentralWidget(mainWidget); /* 信号槽连接，按钮点击，执行加一操作 */ connect(pushButton, SIGNAL(clicked()), this, SLOT(pushButtonClieked())); /* 信号槽连接，历史记录项index发生变化，显示count大小 */ connect(undoStack, SIGNAL(indexChanged(int) ), this, SLOT(showCountValue(int)));&#125;/* 入栈操作会自动调用addCommand的redo */void MainWindow::pushButtonClieked()&#123; /* 变量值加一 */ count++; /* value指向count的地址 */ int *value = &amp;count; /* 用重写的addCommand类实例化 */ QUndoCommand *add = new addCommand(value); /* 入栈 */ undoStack-&gt;push(add);&#125;void MainWindow::showCountValue(int)&#123; /* 标签用于显示计算结果 */ label-&gt;setText(&quot;计算结果：&quot; + QString::number(count));&#125; command.h 1234567891011121314151617181920212223242526#ifndef COMMAND_H#define COMMAND_H#include &lt;QUndoCommand&gt;#include &lt;QObject&gt;class addCommand : public QUndoCommand&#123;public: addCommand(int *value, QUndoCommand* parent = 0); ~addCommand(); /* 重写重做与撤回方法 */ void redo() override; void undo() override;private: /* 新的count */ int *new_count; /* 旧的count */ int old_count;&#125;;#endif // COMMAND_H command.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142#include &quot;command.h&quot;#include &lt;QDebug&gt;addCommand::addCommand(int *value, QUndoCommand *parent)&#123; /* 使用Q_UNUSED,避免未使用的数据类型 */ Q_UNUSED(parent); /* undoView显示的操作信息 */ setText(&quot;进行了加1操作&quot;); /* value的地址赋值给new_count */ new_count = value; /* 让构造函数传过来的*new_count的值赋值给old_count */ old_count = *new_count;&#125;/* 执行stack push时或者重做操作时会自动调用 */void addCommand::redo()&#123; /* 重新赋值给new_count */ *new_count = old_count; /* 打印出*new_count的值 */ qDebug()&lt;&lt;&quot;redo:&quot;&lt;&lt;*new_count&lt;&lt;endl;&#125;/* 回撤操作时执行 */void addCommand::undo()&#123; /* 回撤操作每次应减一 */ (*new_count)--; /* 打印出*new_count的值 */ qDebug()&lt;&lt;&quot;undo:&quot;&lt;&lt;*new_count&lt;&lt;endl;&#125;addCommand::~addCommand()&#123;&#125; ui示例","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt容器","slug":"Qt容器","date":"2023-09-20T05:27:12.000Z","updated":"2023-09-20T07:53:38.327Z","comments":true,"path":"2023/09/20/Qt容器/","link":"","permalink":"http://example.com/2023/09/20/Qt%E5%AE%B9%E5%99%A8/","excerpt":"","text":"Qt容器QGroupBoxQGroupBox 小部件提供一个带有标题的组框框架。 一般与一组或者是同类型的部件一起使用。 代码示例123456789101112131415161718192021222324#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); groupBox = new QGroupBox(tr(&quot;QGroupBox示例&quot;),this);// groupBox-&gt;setTitle(&quot;QGroupBox示例&quot;); groupBox-&gt;setGeometry(300,100,300,200); vBoxLayout = new QVBoxLayout(); QList &lt;QString&gt; list; list&lt;&lt;&quot;Choice1&quot;&lt;&lt;&quot;Choice2&quot;&lt;&lt;&quot;Choice3&quot;; for(int i = 0;i &lt; 3;i ++)&#123; radioButton[i] = new QRadioButton(this); radioButton[i]-&gt;setText(list[i]); vBoxLayout-&gt;addWidget(radioButton[i]); &#125; /*添加一个伸缩量*/ vBoxLayout-&gt;addStretch(1); groupBox-&gt;setLayout(vBoxLayout);&#125; ui示例 QScrollAreaQScrollArea 类提供到另一个小部件的滚动视图 代码示例1234567891011121314151617#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); scrollArea = new QScrollArea(this); /*设置滚动区域*/ scrollArea-&gt;setGeometry(50,50,700,380); label = new QLabel(); /*标签显示图片，分辨率为1076 * 500*/ QImage image(&quot;:/images/lantingxu.png&quot;); label-&gt;setPixmap(QPixmap::fromImage((image))); scrollArea-&gt;setWidget(label);&#125; ui示例 QToolBoxQToolBox（工具盒类）提供了一种列状的层叠窗体，中文译为工具箱，类似抽屉。 代码示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); toolBox = new QToolBox(this); toolBox-&gt;setGeometry(300,50,200,250); /*设置toolBox的样式*/ toolBox-&gt;setStyleSheet(&quot;QToolBox &#123;backgroud-color:rgba&#123;0,0,0,30%)&#125;&quot;); for(int i = 0;i &lt; 2;i ++)&#123; vBoxLayout[i] = new QVBoxLayout(this); groupBox[i] = new QGroupBox(this); &#125; QList &lt;QString&gt; strList; strList&lt;&lt;&quot;李白&quot;&lt;&lt;&quot;王昭君&quot;&lt;&lt;&quot;李元芳&quot;&lt;&lt;&quot;程咬金&quot;&lt;&lt;&quot;钟馗&quot;&lt;&lt;&quot;上官婉儿&quot;; QList &lt;QString&gt; iconList; iconList&lt;&lt;&quot;:/icons/libai&quot;&lt;&lt;&quot;:/icons/wangzhaojun&quot;&lt;&lt;&quot;:/icons/liyuanfang&quot; &lt;&lt;&quot;:/icons/chengyaojin&quot;&lt;&lt;&quot;:/icons/zhongkui&quot;&lt;&lt;&quot;:/icons/shangguanwaner&quot;; for(int i = 0;i &lt; 6;i ++)&#123; toolButton[i] = new QToolButton(this); /*设置toolButton图标*/ toolButton[i]-&gt;setIcon(QIcon(iconList[i])); /*设置toolButton文本*/ toolButton[i]-&gt;setText(strList[i]); /*设置toolButton 的大小*/ toolButton[i]-&gt;setFixedSize(150,40); /*设置toolButton的样式*/ toolButton[i]-&gt;setToolButtonStyle(Qt::ToolButtonTextBesideIcon); if(i &lt; 3)&#123; /*添加到垂直布局*/ vBoxLayout[0]-&gt;addWidget(toolButton[i]); /*添加一个伸缩量*/ vBoxLayout[0]-&gt;addStretch(1); &#125;else&#123; vBoxLayout[1]-&gt;addWidget(toolButton[i]); vBoxLayout[1]-&gt;addStretch(1); &#125; &#125; /*将垂直布局添加到groupBox*/ groupBox[0]-&gt;setLayout(vBoxLayout[0]); groupBox[1]-&gt;setLayout(vBoxLayout[1]); /*将groupBox添加到QToolBox*/ toolBox-&gt;addItem(groupBox[0],&quot;我的好友&quot;); toolBox-&gt;addItem(groupBox[1],&quot;黑名单&quot;);&#125; ui示例 QTabWidgetQTabWidget 继承 QWidget， QTabWidget 类提供了一组选项卡（多页面）小部件。 QTabWidget 主要是用来分页显示的，每一页一个界面，众多界面公用一块区域，节省了界面大小，很方便的为用户显示更多的信息。 代码示例12345678910111213141516171819202122232425262728293031323334353637#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); widget = new QWidget(this); this-&gt;setCentralWidget(widget); /*多页面小部件*/ tabWidget = new QTabWidget(this); /*水平布局实例化*/ hBoxLayout = new QHBoxLayout(this); QList &lt;QString&gt; labelList; labelList&lt;&lt;&quot;tag1&quot;&lt;&lt;&quot;tag2&quot;&lt;&lt;&quot;tag3&quot;; QList &lt;QString&gt; tabList; tabList&lt;&lt;&quot;page1&quot;&lt;&lt;&quot;page2&quot;&lt;&lt;&quot;page3&quot;; QList &lt;QString&gt; iconList; iconList&lt;&lt;&quot;:/icons/icon1.png&quot;&lt;&lt;&quot;:/icons/icon2.png&quot;&lt;&lt;&quot;:/icons/icon3.png&quot;; for(int i = 0;i &lt; 3;i ++)&#123; label[i] = new QLabel(this); label[i]-&gt;setText(labelList[i]); /*设置标签对其方式居中*/ label[i]-&gt;setAlignment(Qt::AlignCenter); /*添加页面*/ tabWidget-&gt;addTab(label[i],QIcon(iconList[i]),tabList[i]); &#125; /*添加关闭按钮*/ tabWidget-&gt;setTabsClosable(true); /*将tabWidget水平排布*/ hBoxLayout-&gt;addWidget(tabWidget); /*将垂直布局设置到widget*/ widget-&gt;setLayout(hBoxLayout);&#125; ui示例 QStackedWidgetQStackedWidget 继承 QFrame。 QStackedWidget 类提供了一个小部件堆栈，其中一次只能看到一个小部件，与 QQ 的设置面板类似。 QStackedWidget 可 用 于 创 建 类 似 于 QTabWidget 提 供 的 用 户 界 面 。 它 是 构 建 在QStackedLayout 类之上的一个方便的布局小部件。常与 QListWidget 搭配使用，效果如下图，左边的是 QListWidget 列表，右边的是 QStackedWidget。他们一般与信号槽连接，通过点击左边的 QListWidget 列表，使用信号槽连接后，就可以让右边的 QStackedWidget 显示不同的内容，每次显示一个 widget 小部件。 代码示例12345678910111213141516171819202122232425262728293031323334353637383940414243#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); widget = new QWidget(this); this-&gt;setCentralWidget(widget); hBoxLayout = new QHBoxLayout(this); stackedWidget = new QStackedWidget(this); listWidget = new QListWidget(this); QList &lt;QString&gt; listWidgetList; listWidgetList&lt;&lt;&quot;windows1&quot;&lt;&lt;&quot;windows2&quot;&lt;&lt;&quot;windows3&quot;; for(int i = 0;i &lt; 3;i ++)&#123; /*listWidget插入项*/ listWidget-&gt;insertItem(i,listWidgetList[i]); &#125; QList &lt;QString&gt; labelList; labelList&lt;&lt;&quot;label1&quot;&lt;&lt;&quot;label2&quot;&lt;&lt;&quot;label3&quot;; for(int i = 0;i &lt; 3;i ++)&#123; label[i] = new QLabel(this); label[i]-&gt;setText(labelList[i]); /*设置label居中*/ label[i]-&gt;setAlignment(Qt::AlignCenter); /*添加页面*/ stackedWidget-&gt;addWidget(label[i]); &#125; /*设置列表的最大宽度*/ listWidget-&gt;setMaximumWidth(100); /*添加到水平布局*/ hBoxLayout-&gt;addWidget(listWidget); hBoxLayout-&gt;addWidget(stackedWidget); widget-&gt;setLayout(hBoxLayout); /*使用listWidget的信号函数currentRowChanged 和槽函数setCurrentIndex进行连接*/ connect(listWidget,SIGNAL(currentRowChanged(int)),stackedWidget,SLOT(setCurrentIndex(int)));&#125; ui示例 QMdiAreaQMdiArea 小部件提供一个显示 MDI 窗口的区域。QMdiArea的功能本质上类似于MDI窗口的窗口管理器。 代码示例123456789101112131415161718192021222324252627282930313233#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); pushButton = new QPushButton(this); pushButton-&gt;setText(&quot;新建窗口&quot;); pushButton-&gt;setGeometry(0,30,100,30); mdiArea = new QMdiArea(this); /*设置MDI Area区域大小*/ mdiArea-&gt;setGeometry(100,30,700,430); /*连接信号槽*/ connect(pushButton,SIGNAL(clicked()),this,SLOT(creat_MidSubWindow()));&#125;void MainWindow::creat_MidSubWindow()&#123; mdiSubWindow = new QMdiSubWindow(); mdiSubWindow-&gt;setWindowTitle(&quot;新建窗口&quot;); /*设置窗口的属性，接收窗口关闭事件之后，QT会释放这个窗口占用的资源*/ mdiSubWindow-&gt;setAttribute(Qt::WA_DeleteOnClose); /*添加子窗口*/ mdiArea-&gt;addSubWindow(mdiSubWindow); /*显示窗口，不设置时为不显示*/ mdiSubWindow-&gt;show(); /*自适应窗口*/ mdiSubWindow-&gt;sizePolicy(); /*以平铺的方式排列所有窗口*/ mdiArea-&gt;tileSubWindows();&#125; ui示例 QDockWidgetQDockWidget继承QWidget。QDockWidget类提供了一个小部件，可以停靠在QMainWindow内，也可以作为桌面的顶级窗口浮动。 QDockWidget 提供了停靠部件的概念，也称为工具面板或实用程序窗口。停靠窗口是放置在 QMainWindow 中央窗口附近的停靠窗口部件区域中的辅助窗口。停靠窗口可以被移动到当前区域内，移动到新的区域，并由终端用户浮动(例如，不停靠)。 代码示例1234567891011121314151617#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*实例化标题为停靠窗口*/ dockWidget = new QDockWidget(&quot;停靠窗口&quot;,this); textEdit = new QTextEdit(dockWidget); textEdit-&gt;setText(&quot;this is demo&quot;); dockWidget-&gt;setWidget(textEdit); /*放在主窗体的顶部*/ this-&gt;addDockWidget(Qt::TopDockWidgetArea,dockWidget);&#125; ui示例","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt布局管理","slug":"Qt布局管理","date":"2023-09-20T01:39:49.000Z","updated":"2023-09-20T05:22:33.844Z","comments":true,"path":"2023/09/20/Qt布局管理/","link":"","permalink":"http://example.com/2023/09/20/Qt%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/","excerpt":"","text":"Qt布局管理QBoxLayoutQBoxLayout 继承 QLayout。 QBoxLayout 类提供水平或垂直地排列子部件。 QBoxLayout 获取从它的父布局或从 parentWidget()中所获得的空间，将其分成一列框，并使每个托管小部件填充一个框。 代码示例1234567891011121314151617181920212223242526272829303132333435#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); hWidget = new QWidget(this); hWidget-&gt;setGeometry(0,0,800,240); vWidget = new QWidget(this); vWidget-&gt;setGeometry(0,240,200,240); hBoxLayout = new QHBoxLayout(this); vBoxLayout = new QVBoxLayout(this); /*使用QList链表*/ QList &lt;QString&gt; list; list&lt;&lt;&quot;one&quot;&lt;&lt;&quot;two&quot;&lt;&lt;&quot;three&quot;&lt;&lt;&quot;four&quot;&lt;&lt;&quot;five&quot;&lt;&lt;&quot;six&quot;; /*实例化PushButton*/ for(int i = 0;i &lt; 6;i ++)&#123; button[i] = new QPushButton(this); button[i]-&gt;setText(list[i]); if(3 &gt; i)&#123; /*将按钮添加到hBoxLayout*/ hBoxLayout-&gt;addWidget(button[i]); &#125;else&#123; vBoxLayout-&gt;addWidget(button[i]); &#125; &#125; /*设置按钮间隔为50*/ hBoxLayout-&gt;setSpacing(50); hWidget-&gt;setLayout(hBoxLayout); vWidget-&gt;setLayout(vBoxLayout);&#125; QGridLayoutQGridLayout 类提供了布局管理器里的一种以网格（二维）的方式管理界面组件 QGridLayout获取可用的空间(通过其父布局或parentWidget()))，将其分为行和列，并将其管理的每个小部件放入正确的单元格中。由于网格布局管理器中的组件也是会随着窗口拉伸而发生变化的，所以也是需要设置组件之间的比例系数的，与QBoxLayout 不同的是网格布局管理器还需要分别设置行和列的比例系数。 示例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); gWidget = new QWidget(this); /*设置gWidget居中央*/ this-&gt;setCentralWidget(gWidget); gridLayout = new QGridLayout(); QList &lt;QString&gt; list; list&lt;&lt;&quot;button1&quot;&lt;&lt;&quot;button2&quot;&lt;&lt;&quot;button3&quot;&lt;&lt;&quot;button4&quot;&lt;&lt;&quot;button5&quot;&lt;&lt;&quot;button6&quot;; for(int i = 0;i &lt; 4;i ++)&#123; button[i] = new QPushButton(this); button[i]-&gt;setText(list[i]); /*设置按钮的最小宽度与高度*/ button[i]-&gt;setMaximumSize(100,30); /*设置自动调整按钮大小*/ button[i]-&gt;setSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding ); switch(i)&#123; case 0: /*将button添加到网格的坐标(0,0)*/ gridLayout-&gt;addWidget(button[i],0,0); break; case 1: gridLayout-&gt;addWidget(button[i],0,1); break; case 2: gridLayout-&gt;addWidget(button[i],1,0); break; case 3: gridLayout-&gt;addWidget(button[i],1,1); break; default: break; &#125; &#125; /*设置0,1行的行比例系数*/ gridLayout-&gt;setRowStretch(0,2); gridLayout-&gt;setRowStretch(1,3); /*设置0,1列的列比例系数*/ gridLayout-&gt;setColumnStretch(0,1); gridLayout-&gt;setColumnStretch(1,3); gWidget-&gt;setLayout(gridLayout);&#125; QFormLayoutQFormLayout 继承 QLayout。 QFormLayout 类管理输入小部件及其关联标签的表单。 QFormLayout 是一个方便的布局类，它以两列的形式布局其子类。左列由标签组成，右列由“字段”小部件(QLineEdit(行编辑器)、 QSpinBox(旋转框等))组成。通常使用 setRowWrapPolicy(RowWrapPolicy policy)接口函数设置布局的换行策略进行布局等。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); gWidget = new QWidget(this); /*设置gWidget居中央*/ this-&gt;setCentralWidget(gWidget); gridLayout = new QGridLayout(); QList &lt;QString&gt; list; list&lt;&lt;&quot;button1&quot;&lt;&lt;&quot;button2&quot;&lt;&lt;&quot;button3&quot;&lt;&lt;&quot;button4&quot;&lt;&lt;&quot;button5&quot;&lt;&lt;&quot;button6&quot;; for(int i = 0;i &lt; 4;i ++)&#123; button[i] = new QPushButton(this); button[i]-&gt;setText(list[i]); /*设置按钮的最小宽度与高度*/ button[i]-&gt;setMaximumSize(100,30); /*设置自动调整按钮大小*/ button[i]-&gt;setSizePolicy( QSizePolicy::Expanding, QSizePolicy::Expanding ); switch(i)&#123; case 0: /*将button添加到网格的坐标(0,0)*/ gridLayout-&gt;addWidget(button[i],0,0); break; case 1: gridLayout-&gt;addWidget(button[i],0,1); break; case 2: gridLayout-&gt;addWidget(button[i],1,0); break; case 3: gridLayout-&gt;addWidget(button[i],1,1); break; default: break; &#125; &#125; /*设置0,1行的行比例系数*/ gridLayout-&gt;setRowStretch(0,2); gridLayout-&gt;setRowStretch(1,3); /*设置0,1列的列比例系数*/ gridLayout-&gt;setColumnStretch(0,1); gridLayout-&gt;setColumnStretch(1,3); gWidget-&gt;setLayout(gridLayout);&#125; QSpacerItemQSpacerItem 类在布局中提供空白(空间间隔)。所以 QSpacerItem 是在布局中使用的。 代码示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &quot;mainwindow.h&quot;#include &lt;QList&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); widget = new QWidget(this); /*设置widget居中*/ this-&gt;setCentralWidget(widget); /*实例化QSpacerItem*/ vSpacer = new QSpacerItem(10,10,QSizePolicy::Minimum,QSizePolicy::Expanding); hSpacer = new QSpacerItem(10,10,QSizePolicy::Expanding,QSizePolicy::Minimum); mainLayout = new QHBoxLayout(); hBoxLayout = new QHBoxLayout(); vBoxLayout = new QVBoxLayout(); /*在VboxLayout添加垂直间隔*/ vBoxLayout-&gt;addSpacerItem(vSpacer); QList &lt;QString&gt; list; list&lt;&lt;&quot;bt1&quot;&lt;&lt;&quot;bt2&quot;&lt;&lt;&quot;bt3&quot;&lt;&lt;&quot;bt4&quot;&lt;&lt;&quot;bt5&quot;&lt;&lt;&quot;bt6&quot;; for(int i = 0;i &lt; 6;i ++)&#123; button[i] = new QPushButton(this); button[i]-&gt;setText(list[i]); if(3 &gt; i)&#123; /*按钮1设置大小为100 * 100*/ button[i]-&gt;setFixedSize(60,30); /*在vboxLayout添加按钮*/ vBoxLayout-&gt;addWidget(button[i]); &#125;else&#123; button[i]-&gt;setFixedSize(60,30); hBoxLayout-&gt;addWidget(button[i]); &#125; &#125; /*在hBoxLayout里面添加水平间隔*/ hBoxLayout-&gt;addSpacerItem(hSpacer); /*在主布局俩面添加垂直布局*/ mainLayout-&gt;addLayout(vBoxLayout); /*在主布局里面添加水平布局*/ mainLayout-&gt;addLayout(hBoxLayout); /*设置部件之间的间距*/ mainLayout-&gt;setSpacing(30); widget-&gt;setLayout(mainLayout);&#125;","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"window下面实现C串口","slug":"window下面实现C串口","date":"2023-09-19T12:59:20.000Z","updated":"2023-09-19T13:11:11.777Z","comments":true,"path":"2023/09/19/window下面实现C串口/","link":"","permalink":"http://example.com/2023/09/19/window%E4%B8%8B%E9%9D%A2%E5%AE%9E%E7%8E%B0C%E4%B8%B2%E5%8F%A3/","excerpt":"","text":"在windows下面实现C串口代码示例如下 SerialC.h 1234567891011121314151617181920212223242526272829303132333435#ifndef __SERIALC_H#define __SERIALC_H#include &lt;windows.h&gt;#include &lt;stdio.h&gt;#ifdef __cplusplusextern &quot;C&quot;&#123;#endif typedef HANDLE PORT; extern PORT OpenPort(int idCom); extern void ClosePort(PORT idCom); extern int SetPortBoudrate(PORT idCom, int rate); extern int SetPortDateBits(PORT idCom, int bits); extern int SetPortStopBits(PORT idCom, int bits); extern int SetPortParity(PORT idCom, int parity); extern int GetPortBoudrate(PORT idCom); extern int GetPortDataBits(PORT idCom); extern int GetPortStopBits(PORT idCom); extern int GetPortParity(PORT idCom); extern int PortSendDate(PORT idCom, const char *date); extern int PortReceiveDate(PORT idCom, char *date, int len); extern PORT SerialPortInit(int idCom, int rate, int dateBits, int stopBits, int parity); extern int SerialReceiveDate(PORT idCom, char *date, int len); extern int SerialSendDate(PORT idCom, const char *date, int len);#ifdef __cplusplus&#125;#endif#endif SerialC.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284#include &quot;SerialC.h&quot;// #define SDebug#ifdef SDebug#define SerialDebug(...) printf(__VA_ARGS__)#else#define SerialDebug(...)#endifPORT OpenPort(int idCom)&#123; PORT Com; TCHAR ComName[128] = &#123;0&#125;; wsprintf(ComName, TEXT(&quot;\\\\\\\\.\\\\COM%d&quot;), idCom); Com = CreateFile(ComName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if (Com == INVALID_HANDLE_VALUE) &#123; return NULL; &#125; COMMTIMEOUTS timeOuts = &#123;0&#125;; timeOuts.ReadIntervalTimeout = 50; timeOuts.ReadTotalTimeoutConstant = 50; timeOuts.ReadTotalTimeoutMultiplier = 10; timeOuts.WriteTotalTimeoutConstant = 50; timeOuts.WriteTotalTimeoutMultiplier = 10; if (SetCommTimeouts(Com, &amp;timeOuts) == FALSE) &#123; return NULL; &#125; if (SetCommMask(Com, EV_RXCHAR) == FALSE) &#123; return NULL; &#125; SerialDebug(&quot;Open %d Success\\r\\n&quot;, idCom); return Com;&#125;void ClosePort(PORT idCom)&#123; CloseHandle(idCom);&#125;int SetPortBoudrate(PORT idCom, int rate)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return FALSE; &#125; dcbSerial.BaudRate = rate; Status = SetCommState(idCom, &amp;dcbSerial); return Status;&#125;int SetPortDateBits(PORT idCom, int bits)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return FALSE; &#125; dcbSerial.ByteSize = bits; Status = SetCommState(idCom, &amp;dcbSerial); return Status;&#125;int SetPortStopBits(PORT idCom, int bits)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return FALSE; &#125; dcbSerial.StopBits = bits; Status = SetCommState(idCom, &amp;dcbSerial); return Status;&#125;int SetPortParity(PORT idCom, int parity)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return FALSE; &#125; dcbSerial.Parity = parity; Status = SetCommState(idCom, &amp;dcbSerial); return Status;&#125;int GetPortBoudrate(PORT idCom)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return -1; &#125; return dcbSerial.BaudRate;&#125;int GetPortDataBits(PORT idCom)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return -1; &#125; return dcbSerial.ByteSize;&#125;int GetPortStopBits(PORT idCom)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return -1; &#125; return dcbSerial.StopBits;&#125;int GetPortParity(PORT idCom)&#123; DCB dcbSerial = &#123;0&#125;; BOOL Status; dcbSerial.DCBlength = sizeof(dcbSerial); Status = GetCommState(idCom, &amp;dcbSerial); if (Status == FALSE) &#123; return -1; &#125; return dcbSerial.Parity;&#125;int PortSendDate(PORT idCom, const char *date)&#123; DWORD writeLen = strlen(date); DWORD hasWrite; BOOL Status = WriteFile(idCom, date, writeLen, &amp;hasWrite, NULL); if (Status == FALSE) &#123; return -1; &#125; else &#123; // SerialDebug(&quot;date Send Success\\r\\n&quot;); &#125; return hasWrite;&#125;int PortReceiveDate(PORT idCom, char *date, int len)&#123; DWORD dwEventMask; DWORD hasRead; BOOL Status = WaitCommEvent(idCom, &amp;dwEventMask, NULL); if (Status == FALSE) &#123; return FALSE; &#125; Status = ReadFile(idCom, date, len, &amp;hasRead, NULL); date[hasRead] = 0; if (Status == FALSE) &#123; return FALSE; &#125; else &#123; // SerialDebug(&quot;has Read %d date\\r\\n&quot;,hasRead); &#125; return TRUE;&#125;PORT SerialPortInit(int idCom, int rate, int dateBits, int stopBits, int parity)&#123; int Status = 0; PORT Com; Com = OpenPort(idCom); if (Com == INVALID_HANDLE_VALUE) &#123; SerialDebug(&quot;Open Com%d Fail\\r\\n&quot;, idCom); return NULL; &#125; Status = SetPortBoudrate(Com, rate); if (Status == FALSE) &#123; SerialDebug(&quot;Set BoudRate Com%d Fail\\r\\n&quot;, idCom); return NULL; &#125; Status = SetPortDateBits(Com, dateBits); if (Status == FALSE) &#123; SerialDebug(&quot;Set dateBits Com%d Fail\\r\\n&quot;, idCom); return NULL; &#125; stopBits = ONESTOPBIT; Status = SetPortStopBits(Com, stopBits); if (Status == FALSE) &#123; SerialDebug(&quot;Set stopBits Com%d Fail\\r\\n&quot;, idCom); return NULL; &#125; Status = SetPortParity(Com, parity); if (Status == FALSE) &#123; SerialDebug(&quot;Set Parity Com%d Fail\\r\\n&quot;, idCom); return NULL; &#125; return Com;&#125;int SerialReceiveDate(PORT idCom, char *date, int len)&#123; DWORD dwEventMask; DWORD NoByteRead = 0; BOOL Status = WaitCommEvent(idCom, &amp;dwEventMask, NULL); if (Status == FALSE) &#123; return -1; &#125; Status = ReadFile(idCom, date, len, &amp;NoByteRead, NULL); date[NoByteRead] = 0; if (Status == FALSE) &#123; return -1; &#125; else &#123; SerialDebug(&quot;receive :%s\\r\\n&quot;, date); &#125; return NoByteRead;&#125;int SerialSendDate(PORT idCom, const char *date, int len)&#123; DWORD hasWrite; BOOL Status = WriteFile(idCom, date, len, &amp;hasWrite, NULL); if (Status == FALSE) &#123; return -1; &#125; else &#123; SerialDebug(&quot;Send :%s\\r\\n&quot;, date); &#125; return hasWrite;&#125;","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Qt显示窗口部件之浏览器","slug":"Qt显示窗口部件之浏览器","date":"2023-09-14T08:03:01.000Z","updated":"2023-09-14T09:26:20.065Z","comments":true,"path":"2023/09/14/Qt显示窗口部件之浏览器/","link":"","permalink":"http://example.com/2023/09/14/Qt%E6%98%BE%E7%A4%BA%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8/","excerpt":"","text":"Qt显示窗口部件QTextBrowserQTextBrowser 继承 QTextEdit， QTextBrowser 类提供了一个具有超文本导航的文本浏览器。该类扩展了 QTextEdit(在只读模式下)，添加了一些导航功能，以便用户可以跟踪超文本文档中的链接。 QTextBrowser使用示例 新建一个带ui的工程 声明和实例化QTextBrowser 信号和槽的连接 槽函数的实现 示例代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;/*窗口对话框与文本流*/#include &lt;QFileDialog&gt;#include &lt;QTextStream&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(new Ui::MainWindow)&#123; ui-&gt;setupUi(this); this-&gt;setGeometry(0,0,800,480); /*将窗口标题设置为文本浏览器*/ this-&gt;setWindowTitle(&quot;文本浏览器&quot;); /*实例化*/ textBroser = new QTextBrowser(this); /*设置文本浏览器窗口居中*/ this-&gt;setCentralWidget(textBroser); openAction = new QAction(&quot;打开&quot;,this); /* ui 窗口自带有 menubar(菜单栏)、 mainToolbar（工具栏）与 * statusbar（状态栏） * menuBar 是 ui 生成工程就有的，所以可以在 menubar 里添加 * 我们的 QActiont 等，如果不需要 menubar，可以在 ui 设计 * 窗口里，在右则对象里把 menubar 删除，再自己重新定义自己的 * 菜单栏 */ ui-&gt;menubar-&gt;addAction(openAction); connect(openAction,SIGNAL(triggered()),this,SLOT(openActionTriggered()));&#125;void MainWindow::openActionTriggered()&#123; /*调用系统打开文件窗口，过滤文件名*/ QString FileName = QFileDialog::getOpenFileName(this,tr(&quot;打开文件&quot;),&quot;&quot;, tr(&quot;Files(*.txt *.cpp *.h *.html)&quot;)); QFile myFile(FileName); /*以只读文本方式打开*/ if(!myFile.open(QIODevice::ReadOnly | QIODevice::Text))&#123; return; &#125; /*使用QTextStream对象接收*/ QTextStream in (&amp;myFile); /*读取全部数据*/ QString myText = in.readAll(); /*判断打开文件的后缀，如果使html格式的则设置文本浏览器为html格式*/ if(FileName.endsWith(&quot;html&quot;) || FileName.endsWith(&quot;htm&quot;))&#123; textBroser-&gt;setHtml(myText); &#125;else&#123; textBroser-&gt;setPlainText(myText); &#125; /*Ui 窗口自带有statusbar(状态栏),设置打开的文件名*/ ui-&gt;statusbar-&gt;showMessage(&quot;文件名:&quot; + FileName);&#125;","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt显示窗口部件","slug":"Qt显示窗口部件","date":"2023-09-14T05:30:35.000Z","updated":"2023-09-14T07:05:03.694Z","comments":true,"path":"2023/09/14/Qt显示窗口部件/","link":"","permalink":"http://example.com/2023/09/14/Qt%E6%98%BE%E7%A4%BA%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6/","excerpt":"","text":"Qt窗口显示部件QLabelQLabel 提供了一种用于文本或图像显示的小部件 代码示例如下12345678910111213141516171819202122#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*使用资源里的文件格式使: + 前缀 + 文件路径*/ QPixmap pixmap(&quot;:image/idesign-logo.png&quot;); LabelImage = new QLabel(this); /*标签大小设置为图像大小*/ LabelImage-&gt;setGeometry(180,150,72,72); /*设置图像*/ LabelImage-&gt;setPixmap(pixmap); /*开启允许缩放填充*/ LabelImage-&gt;setScaledContents(true); LabelString = new QLabel(this); LabelString-&gt;setText(&quot;标签演示文本&quot;); LabelString-&gt;setGeometry(300,300,120,20);&#125; QCalendarWidgetQCalendarWidget 类提供了一个基于月的日历小部件，允许用户选择日期。 代码示例如下1234567891011121314151617181920212223242526272829303132333435#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); CalendarWidget = new QCalendarWidget(this); CalendarWidget-&gt;setGeometry(200,20,400,300); QFont font; /*设置日历里字体的大小为10像素*/ font.setPixelSize(10); CalendarWidget-&gt;setFont(font); PushButton = new QPushButton(this); PushButton-&gt;setGeometry(200,350,120,30); PushButton-&gt;setText(&quot;回到当前日期&quot;); Label = new QLabel(this); Label-&gt;setGeometry(400,350,400,30); QString str = &quot;当前选择的日期:&quot; + CalendarWidget-&gt;selectedDate().toString(); Label-&gt;setText(str); connect(CalendarWidget,SIGNAL(selectionChanged()),this,SLOT(calendarWidgetSelectChanged())); connect(PushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));&#125;void MainWindow::calendarWidgetSelectChanged()&#123; QString str = &quot;当前选择的日期:&quot; + CalendarWidget-&gt;selectedDate().toString(); Label-&gt;setText(str);&#125;void MainWindow::pushButtonClicked()&#123; /*设置当前选定的日期为系统的QDate*/ CalendarWidget-&gt;setSelectedDate(QDate::currentDate());&#125; QLCDNumberQLCDNumber 小部件显示一个类似于 lcd 的数字。QLCDNumber 小部件可以显示任意大小的数字。它可以显示十进制、十六进制、八进制或二进制数字。使用 display()插槽很容易连接到数据源，该插槽被重载以接受五种参数类型中的任何一种。 代码示例如下12345678910111213141516171819202122232425#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); lcdNumber = new QLCDNumber(this); lcdNumber-&gt;setGeometry(300,200,200,50); /*设置显示的位数为8位*/ lcdNumber-&gt;setDigitCount(8); /*设置样式*/ lcdNumber-&gt;setSegmentStyle(QLCDNumber::Flat); /*设置LCD显示为当前系统时间*/ QTime time = QTime::currentTime(); lcdNumber-&gt;display(time.toString(&quot;hh:mm:ss&quot;)); timer = new QTimer(this); /*设置定时器1000毫秒发送一个timeout信号*/ timer-&gt;start(1000); connect(timer,SIGNAL(timeout()),this,SLOT(TimerTimeOut()));&#125;void MainWindow::TimerTimeOut()&#123; QTime time = QTime::currentTime(); lcdNumber-&gt;display(time.toString(&quot;hh:mm:ss&quot;));&#125; QProgressBarQProgressBar 继承 QWidget。 QProgressBar 小部件提供了一个水平或垂直的进度条。进度条用于向用户显示操作的进度，并向他们确认应用程序仍在运行。 QProgressBar 一般用于表示进度，常用于如复制进度，打开、加载进度等。 示例代码如下1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &quot;mainwindow.h&quot;/*实现手机电池充电进度条*/MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); progressBar = new QProgressBar(this); progressBar-&gt;setGeometry(300,200,200,60); /*样式表设置，常用setStyleSheet来设置样式(实现界面美化的功能)*/ progressBar-&gt;setStyleSheet(&quot;QProgressBar&#123;border:8px solid #FFFFFF;&quot; &quot;height:30;&quot; &quot;border-image:url(:/images/battery.png);&quot;//背景图片 &quot;text-align:center;&quot;//文字居中 &quot;color:rgb(255,0,255);&quot; &quot;font:20px;&quot;//字体为20px &quot;border-radius:10px;&#125;&quot; &quot;QProgressBar::chunk&#123;&quot; //斑马线圆角 &quot;border-radius:5px;&quot; &quot;border:1px solid black;&quot;//黑边 &quot;background-color:skyblue;&quot; &quot;width:10px;&quot;//宽度 &quot;margin:1px;&#125;&quot;);//间距 /*设置progressBar的范围值*/ progressBar-&gt;setRange(0,100); /*初始化value = 0*/ value = 0; /*设置progressBar的当前值*/ progressBar-&gt;setValue(value); /*设置当前文本字符串的显示格式*/ progressBar-&gt;setFormat(&quot;充电中%p%&quot;); /*定时器设置100毫秒发送一个timeout信号*/ timer = new QTimer(this); timer-&gt;start(100); connect(timer,SIGNAL(timeout()),this,SLOT(timerTimerOut()));&#125;void MainWindow::timerTimerOut()&#123; /*定时器超时，value++*/ value ++; progressBar-&gt;setValue(value); if(value &gt; 100)&#123; value = 0; &#125;&#125; QFrameQFrame主要用于画窗口部件，和画边框 定义效果 NoFrame - QFrame 不画任何东西 Box - QFrame 在它的内容周围画一个框 Panel - QFrame 画一个平板使内容看起来凸起或者凹陷 WinPanel - 像 Panel，但 QFrame 绘制三维效果的方式和 Microsoft Windows 95（及其它）的一样 ToolBarPanel - QFrame 调用 QStyle::drawToolBarPanel() MenuBarPanel - QFrame 调用 QStyle::drawMenuBarPanel() HLine - QFrame 绘制一个水平线，但没有框任何东西（作为分隔是有用的） VLine - QFrame 绘制一个竖直线，但没有框任何东西（作为分隔是有用的） StyledPanel - QFrame 调用 QStyle::drawPanel() PopupPanel - QFrame 调用 QStyle::drawPopupPanel() 阴影风格有 Plain 使用调色板的前景颜色绘制（没有任何三维效果）。 Raised 使用当前颜色组的亮和暗颜色绘制三维的凸起线。 Sunken 使用当前颜色组的亮和暗颜色绘制三维的凹陷线。 示例代码如下1234567891011121314151617181920212223#include &quot;mainwindow.h&quot;/*实现画两个矩形框*/MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); hFrame = new QFrame(this); /*设置起始点，设置长和宽，绘制矩形*/ hFrame-&gt;setGeometry(QRect(200,100,400,40)); /*设置框样式为Hline，水平，可设置其他样式如Box*/ hFrame-&gt;setFrameShape(QFrame::Box); /*绘制阴影*/ hFrame-&gt;setFrameShadow(QFrame::Sunken); vFrame = new QFrame(this); /*设置起始点，设置长和宽，绘制矩形*/ vFrame-&gt;setGeometry(QRect(300,100,20,200)); /*设置框样式为Hline，水平，可设置其他样式如Box*/ vFrame-&gt;setFrameShape(QFrame::Box); /*绘制阴影*/ vFrame-&gt;setFrameShadow(QFrame::Sunken);&#125;","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"单片机模块初始化","slug":"单片机模块初始化","date":"2023-09-13T08:41:16.000Z","updated":"2023-09-13T09:06:59.737Z","comments":true,"path":"2023/09/13/单片机模块初始化/","link":"","permalink":"http://example.com/2023/09/13/%E5%8D%95%E7%89%87%E6%9C%BA%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96/","excerpt":"","text":"单片机模块初始化 __ attribute __((section(“section_name”))) 其作用是将作用的函数或数据放入指定名为”section_name”对应的中。 通过使用 __ attribute __ ((section(“section_name”))) 来实现单片机可以在模块内初始化代码，使模块代码更加的内聚。 模块初始化修改单片机的.sct 分散加载文件。123456789101112131415161718; *************************************************************; *** Scatter-Loading Description File generated by uVision ***; *************************************************************LR_IROM1 0x08000000 0x00100000 &#123; ; load region size_region ER_IROM1 0x08000000 0x00100000 &#123; ; load address = execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) .ANY (+XO) &#125; RW_IRAM1 0x20000000 0x00060000 &#123; ; RW data .ANY (+RW +ZI) &#125; INIT +0 &#123; .ANY (init) &#125;&#125; 定义module_init使用__ attribute __((section(“section_name”)))，将初始化函数放入指定段中。 1234567891011#define _section(x) __attribute__ ((used,section(x)))#define module_init(_func,_name) \\ app_init_func_t _##_func _section(&quot;init&quot;) = &#123;\\ _func,\\ _name,\\ &#125;typedef struct&#123; void (*app_func_init)(void); char *app_name;&#125;app_init_func_t; 获取放入函数段的指定地址12345extern unsigned long Image$$INIT$$Base;extern unsigned long Image$$INIT$$Limit;static app_init_func_t *_app_init_start = (app_init_func_t *)&amp;Image$$INIT$$Base;static app_init_func_t *_app_init_end = (app_init_func_t *)&amp;Image$$INIT$$Limit; 初始化运行指定函数段12345678void _init(void)&#123; app_init_func_t *t; for(t = _app_init_start;t &lt; _app_init_end;t ++)&#123; if(t-&gt;app_func_init)&#123; t-&gt;app_func_init(); &#125; &#125;&#125; 将_init()函数放入主函数中就可以在模块中初始化函数了，而不需要在外部调用初始化函数。 代码示例12345void Function_init(void)&#123; &#125;module_init(Function_init,&quot;Function init&quot;);","categories":[],"tags":[{"name":"单片机","slug":"单片机","permalink":"http://example.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"}]},{"title":"Qt信号和槽","slug":"Qt信号和槽","date":"2023-09-12T09:27:00.000Z","updated":"2023-09-13T01:49:59.224Z","comments":true,"path":"2023/09/12/Qt信号和槽/","link":"","permalink":"http://example.com/2023/09/12/Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/","excerpt":"","text":"Qt信号与槽QT信号与槽机制信号（signal）：在特定情况下被发送的事件 槽（slot）：对信号响应的函数，槽函数可以与一个信号关联，当信号被发送时，槽函数自动执行。 信号与槽关联使用QObject::connect()函数实现： 123456789example：QObject::connect(sender,SIGNAL(signal()),receiver,SLOT(slot()));connect(sender,SIGNAL(signal()),receiver,SLOT(slot()));上面两种写法都可以，因为QObject是QT的基类，在调用是可以忽略前面的限定符。sender:发送信号的对象receiver:接受信号的对象SIGNAL和SLOT是QT的宏，用于指明信号和槽，并将参数转化成相应字符串。signal:需要发送的信号slot:接收信号的槽 信号的创建 在mainwindow.h里面引入 1#include &lt;QPushButton&gt; 声明一个信号 12signals: void pushButtonTextChanged(); 槽的创建 直接在mainwindow.h里面声明槽。 123public slots: void changeButtonText(); void pushButtonClicked(); 并且在mainwindow.cpp里面实现槽的定义。 12345678void MainWindow::pushButtonClicked()&#123; /*use emit send signal*/ emit pushButtonTextChanged();&#125;void MainWindow::changeButtonText()&#123; pushButton-&gt;setText(&quot;按钮被按下&quot;);&#125; 槽可以是任何成员函数，不同全局函数，静态函数。 槽函数和信号的参数和返回值要一样。 信号和槽的连接12connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));connect(this,SIGNAL(pushButtonTextChanged()),this,SLOT(changeButtonText())); mainwindow如下：1234567891011121314151617181920212223242526272829#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; /*set windows width hight 480 * 800*/ this-&gt;resize(800,480); /*create QPushBotton Class*/ pushButton = new QPushButton(this); /*use setText() set text infomation*/ pushButton-&gt;setText(&quot;按钮&quot;); /*signal slot connect signal*/ connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked())); connect(this,SIGNAL(pushButtonTextChanged()),this,SLOT(changeButtonText()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::pushButtonClicked()&#123; /*use emit send signal*/ emit pushButtonTextChanged();&#125;void MainWindow::changeButtonText()&#123; pushButton-&gt;setText(&quot;按钮被按下&quot;);&#125;","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt输入窗口部件","slug":"Qt输入窗口部件","date":"2023-09-12T09:26:46.000Z","updated":"2023-09-13T08:31:59.762Z","comments":true,"path":"2023/09/12/Qt输入窗口部件/","link":"","permalink":"http://example.com/2023/09/12/Qt%E8%BE%93%E5%85%A5%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6/","excerpt":"","text":"Qt窗口输入部件1、QComboBoxQComboBox提供下拉组合框的组件。 QComboBox使用示例 声明 12private: QComboBox *ComboBox; 实例化 QComboBox组件，和初始化QComboBox组件 12345ComboBox = new QComboBox(this);ComboBox-&gt;setGeometry(300,200,150,30);ComboBox-&gt;addItem(&quot;四川(default)&quot;);ComboBox-&gt;addItem(&quot;云南&quot;);ComboBox-&gt;addItem(&quot;贵州&quot;); 实现信号和槽的连接 1connect(ComboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(ComboBoxIndexChanged(int))); 实现QComboBox的槽函数 123void MainWindow::ComboBoxIndexChanged(int index)&#123; qDebug()&lt;&lt;&quot;您选择的省份是&quot;&lt;&lt;ComboBox-&gt;itemText(index)&lt;&lt;endl;&#125; 示例代码如下12345678910111213141516171819#include &quot;mainwindow.h&quot;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); ComboBox = new QComboBox(this); ComboBox-&gt;setGeometry(300,200,150,30); ComboBox-&gt;addItem(&quot;四川(default)&quot;); ComboBox-&gt;addItem(&quot;云南&quot;); ComboBox-&gt;addItem(&quot;贵州&quot;); connect(ComboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(ComboBoxIndexChanged(int)));&#125;void MainWindow::ComboBoxIndexChanged(int index)&#123; qDebug()&lt;&lt;&quot;您选择的省份是&quot;&lt;&lt;ComboBox-&gt;itemText(index)&lt;&lt;endl;&#125; 2、QFontComboBoxQFontComboBox 类提供了下拉选择字体系列的组合框小部件。 QFontComboBox使用示例 引入 声明QFontComboBox对象 12private: QFontComboBox *FontConboBox; 实例化对象QFontComboBox 12345FontConboBox = new QFontComboBox(this); Label = new QLabel(this); FontConboBox-&gt;setGeometry(280,200,200,30); Label-&gt;setGeometry(280,250,300,50); 实现槽函数 1234567/*将lable里面的文本内容设置为所选择的字体*/ Label-&gt;setFont(Font); /*定义一个字符串接收当前项的字体*/ QString str = &quot;用此标签显示字体效果\\n设置的字体为:&quot; + FontConboBox-&gt;itemText(FontConboBox-&gt;currentIndex()); /*将字符串的内容作为lable的显示内容*/ Label-&gt;setText(str); 连接信号和槽 1connect(FontConboBox,SIGNAL(currentFontChanged(QFont)),this,SLOT(FontComboBoxFontChanged(QFont))); 代码示例如下1234567891011121314151617181920212223242526#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); FontConboBox = new QFontComboBox(this); Label = new QLabel(this); FontConboBox-&gt;setGeometry(280,200,200,30); Label-&gt;setGeometry(280,250,300,50); connect(FontConboBox,SIGNAL(currentFontChanged(QFont)),this,SLOT(FontComboBoxFontChanged(QFont)));&#125;void MainWindow::FontComboBoxFontChanged(QFont Font)&#123; /*将lable里面的文本内容设置为所选择的字体*/ Label-&gt;setFont(Font); /*定义一个字符串接收当前项的字体*/ QString str = &quot;用此标签显示字体效果\\n设置的字体为:&quot; + FontConboBox-&gt;itemText(FontConboBox-&gt;currentIndex()); /*将字符串的内容作为lable的显示内容*/ Label-&gt;setText(str);&#125; 3、QLineEditQLineEdit 小部件是一个单行文本编辑器。 QLineEdit的使用示例 引入 声明和实例化QLineEdit 实现和连接槽函数 示例代码如下1234567891011121314151617181920212223242526272829#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); LineEdit = new QLineEdit(this); LineEdit-&gt;setGeometry(280,200,200,20); PushButton = new QPushButton(this); PushButton-&gt;setGeometry(500,200,50,20); PushButton-&gt;setText(&quot;确认&quot;); Label = new QLabel(this); Label-&gt;setGeometry(280,250,400,20); Label-&gt;setText(&quot;您输入的内容是:&quot;); connect(PushButton,SIGNAL(clicked()),this,SLOT(PushButtonClicked()));&#125;void MainWindow::PushButtonClicked()&#123; QString str; str = &quot;您输入的内容是: &quot;; str += LineEdit-&gt;text(); /*设置label文本显示内容*/ Label-&gt;setText(str); /*点击确认键之后清空LineEdit单行输入框*/ LineEdit-&gt;clear();&#125; 4、QTextEditQTextEdit 类提供了一个查看器&#x2F;编辑器小部件。 QTextEdit的使用示例 引入 声明和实例化QTextEdit 实现槽函数和信号和槽的连接 代码示例如下1234567891011121314151617181920212223242526272829303132333435#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); textEdit = new QTextEdit(this); textEdit-&gt;setGeometry(0,0,800,400); pushButtonSelect = new QPushButton(this); pushButtonSelect-&gt;setGeometry(200,420,50,30); pushButtonSelect-&gt;setText(&quot;全选&quot;); pushButtonClear = new QPushButton(this); pushButtonClear-&gt;setGeometry(500,420,50,30); pushButtonClear-&gt;setText(&quot;清除&quot;); connect(pushButtonSelect,SIGNAL(clicked()),this,SLOT(pushButtonSelectAllClicked())); connect(pushButtonClear,SIGNAL(clicked()),this,SLOT(pushButtonClearAllClicked()));&#125;void MainWindow::pushButtonSelectAllClicked()&#123; /*设置焦点为textEdit*/ textEdit-&gt;setFocus(); /*判断文本编辑内容是否为空，不为空则全选*/ if(!textEdit-&gt;toPlainText().isEmpty())&#123; textEdit-&gt;selectAll(); &#125;&#125;void MainWindow::pushButtonClearAllClicked()&#123; /*清空textEdit里面的内容*/ textEdit-&gt;clear();&#125; 5、QPlainTextEditQPlainTextEdit 类提供了一个用于编辑和显示纯文本的小部件，常用于显示多行文本或简单文本。 示例代码如下1234567891011121314151617181920212223242526272829303132333435363738#include &quot;mainwindow.h&quot;#include &lt;QDir&gt;#include &lt;QTextStream&gt;#include &lt;QCoreApplication&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; /*设置当前程序的工作目录为可执行程序的工作目录*/ QDir::setCurrent(QCoreApplication::applicationDirPath()); this-&gt;setGeometry(0,0,800,480); plainTextEdit = new QPlainTextEdit(this); plainTextEdit-&gt;setGeometry(0,50,800,430); radioButton = new QRadioButton(this); radioButton-&gt;setGeometry(650,20,100,20); radioButton-&gt;setText(&quot;只读模式&quot;); /*打开可执行程序目录里面的moc_mainwindow.cpp.cpp*/ QFile file(&quot;moc_mainwindow.cpp&quot;); /*以只读模式打开，但是可以在plainTextEdit里面编辑*/ file.open(QFile::ReadOnly | QFile::Text); /*加载到文件流*/ QTextStream in(&amp;file); /*从文件流中读取全部*/ plainTextEdit-&gt;insertPlainText(in.readAll()); connect(radioButton,SIGNAL(clicked()),this,SLOT(radioButtonClicked()));&#125;void MainWindow::radioButtonClicked()&#123; if(radioButton-&gt;isChecked())&#123; /*设置为只读模式*/ plainTextEdit-&gt;setReadOnly(true); &#125;else&#123; plainTextEdit-&gt;setReadOnly(false); &#125;&#125; 6、QSpinBoxQSpinBox 类提供了一个微调框小部件 示例代码如下123456789101112131415161718192021222324252627282930#include &quot;mainwindow.h&quot;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); this-&gt;setStyleSheet(&quot;QMainWindow &#123;background-color: rgba(100,100,100,100%)&#125;&quot;); SpinBox = new QSpinBox(this); SpinBox-&gt;setGeometry(350,200,150,30); /*设置范围0~100*/ SpinBox-&gt;setRange(0,100); /*设置步长值为10*/ SpinBox-&gt;setSingleStep(10); /*设置初始值为100*/ SpinBox-&gt;setValue(100); /*设置后缀*/ SpinBox-&gt;setSuffix(&quot;%不透明度&quot;); connect(SpinBox,SIGNAL(valueChanged(int)),this,SLOT(spinBoxValueChanged(int)));&#125;void MainWindow::spinBoxValueChanged(int value)&#123; /*转换为double 数据类型*/ double dvalue = (double)value / 100; this-&gt;setWindowOpacity(dvalue); qDebug()&lt;&lt; &quot;value is: &quot;&lt;&lt;value&lt;&lt;endl;&#125; 7、QDoubleSpinBoxQDoubleSpinBox 类提供了一个用于处理浮点值微调框小部件。与 QSpinBox 作用基本一样，与 QSpinBox 不同的是， QDoubleSpinBox 类处理的是浮点值数据。 示例代码如下12345678910111213141516171819202122232425262728293031#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*实例化和设置显示的位置大小*/ DoubleSpinBox = new QDoubleSpinBox(this); DoubleSpinBox-&gt;setGeometry((this-&gt;width() - 200)/2,(this-&gt;height() - 30) / 2,200,30); /*设置前缀*/ DoubleSpinBox-&gt;setPrefix(&quot;窗口大小&quot;); /*设置后缀*/ DoubleSpinBox-&gt;setSuffix(&quot;%&quot;); /*设置范围*/ DoubleSpinBox-&gt;setRange(50.00,100.00); /*设置初始值*/ DoubleSpinBox-&gt;setValue(100.00); /*设置步长*/ DoubleSpinBox-&gt;setSingleStep(0.1); connect(DoubleSpinBox,SIGNAL(valueChanged(double)),this,SLOT(DoubleSpinBoxValueChanged(double)));&#125;void MainWindow::DoubleSpinBoxValueChanged(double value)&#123; int width = 800 * value / 100; int height = 480 *value / 100; this-&gt;setGeometry(0,0,width,height); DoubleSpinBox-&gt;setGeometry((this-&gt;width() - 200)/2, (this-&gt;height() - 30) / 2,200,30);&#125; 8、QTimeEdit QTimeDateEdit QDateEditQTimeEdit 类提供一个基于 QDateTimeEdit 类编辑时间的小部件。 QDateEdit 类提供一个基于 QDateTimeEdit 类编辑时间的小部件。 QDateTimeEdit 类提供了一个用于编辑日期和时间的小部件。 QDateTimeEdit允许用户使用键盘或箭头键编辑日期，以增加或减少日期和时间值。 代码示例如下12345678910111213141516171819#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*实例化对象，传入当前日期和时间*/ dateTimeEdit = new QDateTimeEdit(QDateTime::currentDateTime(),this); dateTimeEdit-&gt;setGeometry(300,200,200,30); /*设置弹出日期控件与否*/ dateTimeEdit-&gt;setCalendarPopup(true); /*实例化对象，传入当前时间*/ timeEdit = new QTimeEdit(QTime::currentTime(),this); timeEdit-&gt;setGeometry(300,240,200,30); /*实例化对象传入当前日期*/ dateEdit = new QDateEdit(QDate::currentDate(),this); dateEdit-&gt;setGeometry(300,280,200,30);&#125; 9、QDialQDial 类提供了一个圆形范围控制(如速度计或电位器)。 QDial 用于当用户需要在可编程定义的范围内控制一个值，并且该范围要么是环绕的(例如，从 0 到 359 度测量的角度)，要么对话框布局需要一个正方形小部件。 当 wrapping（）为 false（默认设置）时，滑块和刻度盘之间没有真正的区别。 代码示例如下1234567891011121314151617181920212223242526272829303132#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); dial = new QDial(this); dial-&gt;setGeometry(300,100,200,200); /*设置页长(两个最大刻度的间距)*/ dial-&gt;setPageStep(10); /*设置刻度可见*/ dial-&gt;setNotchesVisible(true); /*设置两个凹槽之间的目标像素数*/ dial-&gt;setNotchTarget(1.00); /*设置dial值的范围*/ dial-&gt;setRange(0,100);// /*开启后可以指向圆的任何角度*/// dial-&gt;setWrapping(true); label = new QLabel(this); label-&gt;setGeometry(370,300,200,50); label-&gt;setText(&quot;0km/h&quot;); connect(dial,SIGNAL(valueChanged(int)),this,SLOT(dialValueChanged(int)));&#125;void MainWindow::dialValueChanged(int value)&#123; /*使用QString::number()转化成字符串*/ label-&gt;setText(QString::number(value) + &quot;km/h&quot;);&#125; 10、QScroolBarQScrollBar 继承 QAbstractSlider。 QScrollBar 小部件提供垂直或水平滚动条，允许用户访问比用于显示文档的小部件大的文档部分。它提供了用户在文档中的当前位置和可见文档数量的可视化指示。 代码示例如下1234567891011121314151617#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*实例化水平滚动条hScrollBar*/ hScrollBar = new QScrollBar(Qt::Horizontal,this); hScrollBar-&gt;setGeometry(0,450,800,30); /*实例化竖直滚动条vScrollBar*/ vScrollBar = new QScrollBar(Qt::Vertical,this); vScrollBar-&gt;setGeometry(770,0,30,480); label = new QLabel(this); label-&gt;setText(&quot;这是一个测试&quot;); label-&gt;setGeometry(300,200,120,30);&#125; 11、QSliderQSlider 继承 QAbstractSlider。 QScrollBar 类提供垂直或水平滑动条小部件，滑动条是用于控制有界值的典型小部件。它允许用户沿着水平或垂直凹槽移动滑块手柄，并将手柄的位置转换为合法范围内的整数值。 代码示例如下1234567891011121314151617181920212223242526272829303132#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); vSlider = new QSlider(Qt::Vertical,this); vSlider-&gt;setGeometry(200,50,20,200); vSlider-&gt;setRange(0,100); hSlider = new QSlider(Qt::Horizontal,this); hSlider-&gt;setGeometry(250,100,200,20); hSlider-&gt;setRange(0,100); label = new QLabel(&quot;滑动条值: 0&quot;,this); label-&gt;setGeometry(250,200,100,20); connect(vSlider,SIGNAL(valueChanged(int)),this,SLOT(vSliderValueChanged(int))); connect(hSlider,SIGNAL(valueChanged(int)),this,SLOT(hSliderValueChanged(int)));&#125;void MainWindow::vSliderValueChanged(int value)&#123; hSlider-&gt;setSliderPosition(value);&#125;void MainWindow::hSliderValueChanged(int value)&#123; /*当水平滑动条的值改变时，改变垂直滑动条的值*/ vSlider-&gt;setSliderPosition(value); QString str = &quot;滑动条值: &quot; + QString::number(value); label-&gt;setText(str);&#125; 12、QKeySequenceEditQKeySequenceEdit 继承 QWidget。这个小部件允许用户选择 QKeySequence, QKeySequence通常用作快捷方式。当小部件接收到焦点并在用户释放最后一个键后一秒结束时，将启动记录，通常用作记录快捷键。 代码示例如下1234567891011121314151617181920212223#include &quot;mainwindow.h&quot;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); KeySequenceEdit = new QKeySequenceEdit(this); KeySequenceEdit-&gt;setGeometry(350,200,150,30); connect(KeySequenceEdit,SIGNAL(keySequenceChanged(const QKeySequence &amp;)), this,SLOT(KeySequenceEditChanged(const QKeySequence &amp;)));&#125;void MainWindow::KeySequenceEditChanged(const QKeySequence &amp;keySequence)&#123; /*判断输入的组合键是否为Ctrl + Q，如果是则退出程序*/ if(keySequence == QKeySequence(tr(&quot;Ctrl+Q&quot;)))&#123; this-&gt;close(); &#125;else&#123; qDebug()&lt;&lt;keySequence.toString()&lt;&lt;endl; &#125;&#125;","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"Qt按钮控件","slug":"Qt按钮控件","date":"2023-09-12T09:26:21.000Z","updated":"2023-09-13T01:49:59.229Z","comments":true,"path":"2023/09/12/Qt按钮控件/","link":"","permalink":"http://example.com/2023/09/12/Qt%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/","excerpt":"","text":"Qt按钮控件的使用按钮控件（button） pushButton （下压按钮） ToolButton （工具按钮） RadioButton （选择按钮） CheckBox （检查框） Command Link Button （命令连接按钮） Dialog Button Box （对话框按钮） QPushButton 引入类。 定义声明信号与槽，和实例化对象 连接信号与槽 代码定义声明如下123456789101112131415161718192021222324252627282930#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;/* import QPushButton Class*/#include &lt;QPushButton&gt;class MainWindow : public QMainWindow&#123; Q_OBJECTpublic: MainWindow(QWidget *parent = nullptr); ~MainWindow(); /*statement signal*/ signals: void pushButtonTextChanged(); /*statement slot*/public slots: void changeButtonText(); void pushButtonClicked();private: /*statement QPushBotton Class*/ QPushButton *pushButton;&#125;;#endif // MAINWINDOW_H 1234567891011121314151617181920212223242526272829#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; /*set windows width hight 480 * 800*/ this-&gt;resize(800,480); /*create QPushBotton Class*/ pushButton = new QPushButton(this); /*use setText() set text infomation*/ pushButton-&gt;setText(&quot;按钮&quot;); /*signal slot connect signal*/ connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked())); connect(this,SIGNAL(pushButtonTextChanged()),this,SLOT(changeButtonText()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::pushButtonClicked()&#123; /*use emit send signal*/ emit pushButtonTextChanged();&#125;void MainWindow::changeButtonText()&#123; pushButton-&gt;setText(&quot;按钮被按下&quot;);&#125; QToolButton​ QtoolButton和QpushButton的区别是QtoolButton可以带图标。 使用QtoolButton 引入和类 12#include &lt;QToolButton&gt;#include &lt;QToolBar&gt; 声明QToolButton和QToolBar对象 123private: QToolBar *toolBar; QToolButton *toolButton; 实例化对象 1toolBar = new QToolBar(this); 主程序如下：123456789101112131415161718192021222324252627282930313233#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;#include &lt;QStyle&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*create QToolBar Class*/ toolBar = new QToolBar(this); toolBar-&gt;setGeometry(0,0,800,100); /*create style Class,use set icon and Style*/ QStyle *style = QApplication::style(); /*use QT&#x27;s icon*/ QIcon icon = style-&gt;standardIcon(QStyle::SP_TitleBarMenuButton); /*create QToolButton Class*/ toolButton = new QToolButton(); /*toolButton set icon and text*/ toolButton-&gt;setIcon(icon); toolButton-&gt;setText(&quot;help&quot;); /*use setToolButtonStyle Function set ToolButton Style, set icon is under this button*/ toolButton-&gt;setToolButtonStyle(Qt::ToolButtonTextUnderIcon); /*will button add the toolbar*/ toolBar-&gt;addWidget(toolButton);&#125;MainWindow::~MainWindow()&#123;&#125; QRadioButton使用QRadioButton 添加资源文件（添加顺序如下） 12需要添加的项目-&gt;Add New-&gt;QT-&gt;Qt Resource File-&gt;Choose-&gt;(添加资源文件名称)双击添加的资源文件.qrc-&gt;Add Prefix-&gt;前缀添加&quot;/&quot;-&gt;Add Files 添加qss文件 QSS文件使用Qt程序相关联的样式文件，包括GUI的布局，颜色，鼠标的行为，大小和字体。 12新建添加一个qss文件。右键点击资源文件.qrc-&gt;Qt-&gt;Qt Resource File-&gt;Choose-&gt;填写名称-&gt;下一步 引入 声明 QRadioButton对象，实例化对象 12345QRadioButton *radioButton1;QRadioButton *radioButton2; radioButton1 = new QRadioButton(this);radioButton2 = new QRadioButton(this); 初始化QRadioButton 状态 12radioButton1-&gt;setChecked(false);radioButton2-&gt;setChecked(true); 编写.qss资源文件 引用打开资源文件 12345678910QFile file(&quot;:/style.qss&quot;); /*if file is exist*/ if(file.exists())&#123; file.open(QFile::ReadOnly); QString styleSheet = QLatin1String(file.readAll()); /*set global style*/ qApp-&gt;setStyleSheet(styleSheet); file.close(); &#125; 代码示例如下：.qss 1234567891011121314151617QRadioButton&#123; spacing:2px; color:white;&#125;QRadioButton::indicator&#123; width:45px; height:30px;&#125;QRadioButton::indicator:unchecked&#123; image: url(:/image/idesign-logo.png);&#125;QRadioButton::indicator:checked&#123; image: url(:/image/SzsFox-logo.png);&#125; main.cpp 123456789101112131415161718192021222324#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;/*import &lt;QFile&gt;*/#include &lt;QFile&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QFile file(&quot;:/style.qss&quot;); /*if file is exist*/ if(file.exists())&#123; file.open(QFile::ReadOnly); QString styleSheet = QLatin1String(file.readAll()); /*set global style*/ qApp-&gt;setStyleSheet(styleSheet); file.close(); &#125; MainWindow w; w.show(); return a.exec();&#125; mainwindow.cpp 12345678910111213141516171819202122232425#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); /*set mainwindows&#x27;s background-color*/ this-&gt;setStyleSheet(&quot;QMainWindow &#123;background-color:rgba(200,50,100,100%);&#125;&quot;); radioButton1 = new QRadioButton(this); radioButton2 = new QRadioButton(this); /*set radiobutton&#x27;s position and size*/ radioButton1-&gt;setGeometry(300,200,100,50); radioButton2-&gt;setGeometry(400,200,100,50); radioButton1-&gt;setText(&quot;Button1&quot;); radioButton2-&gt;setText(&quot;Button2&quot;); /*set radioButton&#x27;s init status*/ radioButton1-&gt;setChecked(false); radioButton2-&gt;setChecked(true);&#125; QCheckBoxQCheckBox是三态选择框，可以有三种状态。 QCheckBox 使用 添加资源文件 实例化QCheckBox,初始化QCheckBox状态。 1234567/*set checkBox status*/checkBox-&gt;setText(&quot;初始化状态为Checked&quot;);checkBox-&gt;setCheckState(Qt::Checked);/*open three status mode*/checkBox-&gt;setTristate();/*connect slot*/connect(checkBox,SIGNAL(stateChanged(int)),this,SLOT(checkBoxStatusChanged(int))); 实现Slot槽函数 1void MainWindow::checkBoxStatusChanged(int status) 编写.qss文件 代码示例如下mainwindow.cpp 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); this-&gt;setStyleSheet(&quot;QMainWindow &#123;background-color:rgba(100,100,100,100%);&#125;&quot;); checkBox = new QCheckBox(this); checkBox-&gt;setGeometry(350,200,250,50); /*set checkBox status*/ checkBox-&gt;setText(&quot;初始化状态为Checked&quot;); checkBox-&gt;setCheckState(Qt::Checked); /*open three status mode*/ checkBox-&gt;setTristate(); /*connect slot*/ connect(checkBox,SIGNAL(stateChanged(int)),this,SLOT(checkBoxStatusChanged(int)));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::checkBoxStatusChanged(int status)&#123; switch(status)&#123; case Qt::Checked: checkBox-&gt;setText(&quot;Checked status&quot;); break; case Qt::Unchecked: checkBox-&gt;setText(&quot;Unchecked status&quot;); break; case Qt::PartiallyChecked: checkBox-&gt;setText(&quot;PartiallyChecked status&quot;); break; default: break; &#125;&#125; main.cpp 123456789101112131415161718192021#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;#include &lt;QFile&gt;int main(int argc, char *argv[])&#123; QApplication a(argc, argv); QFile file(&quot;:/style.qss&quot;); if(file.exists())&#123; file.open(QFile::ReadOnly); QString styleSheet = QLatin1String(file.readAll()); /*set global style*/ qApp-&gt;setStyleSheet(styleSheet); file.close(); &#125; MainWindow w; w.show(); return a.exec();&#125; .qss 123456789101112131415161718192021QCheckBox&#123; spacing:5px; color:white;&#125;QCheckBox::indicator&#123; width:50px; height:50px;&#125;QCheckBox::indicator:enabled:unchecked&#123; image: url(:/image/chuangzaoshi-logo.png);&#125;QCheckBox::indicator:enabled:checked&#123; image: url(:/image/idesign-logo.png);&#125;QCheckBox::indicator:enabled:indeterminate&#123; image: url(:/image/SzsFox-logo.png);&#125; QCommandLinkButtonQCommandLinkButton命令链接按钮 和QRadioButton相似，用于在互斥选项中选择一项，携带一个箭头图标。 QCommandLinkButton使用 引用 ,, 声明和实例化QCommandLinkButton 1234private: QCommandLinkButton *CommandLinkButton;CommandLinkButton = new QCommandLinkButton( &quot;点击打开目录&quot;,this); 实现信号和槽之间的连接 1connect(CommandLinkButton,SIGNAL(clicked()),this,SLOT(CommandLinkButtonClicked())); 实现CommandLinkButtonClicked槽函数 代码实现如下123456789101112131415161718192021222324252627#include &quot;mainwindow.h&quot;/*import desk server,open system folder*/#include &lt;QDesktopServices&gt;/*import QUrl*/#include &lt;QUrl&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); CommandLinkButton = new QCommandLinkButton( &quot;点击打开目录&quot;,this); CommandLinkButton-&gt;setGeometry(300,200,250,60); connect(CommandLinkButton,SIGNAL(clicked()),this,SLOT(CommandLinkButtonClicked()));&#125;MainWindow::~MainWindow()&#123;&#125;void MainWindow::CommandLinkButtonClicked()&#123; /*call system server open catalogue*/ QDesktopServices::openUrl(QUrl(&quot;D:/emulate&quot;));&#125; QDialogButtonBoxQDialogButtonBox的使用​ QDialogButtonBox 允许开发人员向其添加按钮，并将自动使用适合用户桌面环境的布局 。我们可以实现自定义按钮。 引入 声明QDialogButtonBox 对象和QpushButton对象 12345private: QDialogButtonBox *dialogButtonBox; QPushButton *PushButton;private slots: void DialogButtonBoxClicked(QAbstractButton *); 实例化QDialogButtonBox对象 12345dialogButtonBox = new QDialogButtonBox(this); dialogButtonBox-&gt;setGeometry(300,200,200,30); dialogButtonBox-&gt;addButton(QDialogButtonBox::Cancel); dialogButtonBox-&gt;button(QDialogButtonBox::Cancel)-&gt;setText(&quot;取消&quot;); 实例化QPushButton 1PushButton = new QPushButton(tr(&quot;自定义&quot;)); 将QPushButton添加到QDialogButtonBox里面，并且实现信号和槽的连接。 123/*will pushbutton add to dialogbuttonBox,and set buttonRole is ActionRole*/ dialogButtonBox-&gt;addButton(PushButton,QDialogButtonBox::ActionRole); connect(dialogButtonBox,SIGNAL(clicked(QAbstractButton *)),this,SLOT(DialogButtonBoxClicked(QAbstractButton *))); 槽函数的实现 代码示例如下12345678910111213141516171819202122232425262728#include &quot;mainwindow.h&quot;#include &lt;QDebug&gt;MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent)&#123; this-&gt;setGeometry(0,0,800,480); dialogButtonBox = new QDialogButtonBox(this); dialogButtonBox-&gt;setGeometry(300,200,200,30); dialogButtonBox-&gt;addButton(QDialogButtonBox::Cancel); dialogButtonBox-&gt;button(QDialogButtonBox::Cancel)-&gt;setText(&quot;取消&quot;); PushButton = new QPushButton(tr(&quot;自定义&quot;)); /*will pushbutton add to dialogbuttonBox,and set buttonRole is ActionRole*/ dialogButtonBox-&gt;addButton(PushButton,QDialogButtonBox::ActionRole); connect(dialogButtonBox,SIGNAL(clicked(QAbstractButton *)),this,SLOT(DialogButtonBoxClicked(QAbstractButton *)));&#125;void MainWindow::DialogButtonBoxClicked(QAbstractButton *button)&#123; if(button == dialogButtonBox-&gt;button((QDialogButtonBox::Cancel)))&#123; qDebug() &lt;&lt;&quot;clicked Cancel&quot;&lt;&lt;endl; &#125;else if(button == PushButton)&#123; qDebug() &lt;&lt;&quot;clicked self button&quot;&lt;&lt;endl; &#125;else&#123; &#125;&#125;","categories":[],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"}]},{"title":"__atrribute__的一些用法","slug":"atrribute-的一些用法","date":"2023-01-27T12:00:31.000Z","updated":"2023-09-13T01:49:59.233Z","comments":true,"path":"2023/01/27/atrribute-的一些用法/","link":"","permalink":"http://example.com/2023/01/27/atrribute-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/","excerpt":"","text":"__attribute__用法attribute属性声明：formatGNU 通过 atttribute 扩展的 format 属性，用来指定变参函数的参数格式检查。 1__attribute__(( format (archetype, string-index, first-to-check))) archetype：指定格式类型 string-index：格式字符串的位置在所有参数列表中的索引 first-to-check：编译器帮忙检查的参数，在所有的参数列表里索引的位置 使用示例： 1void LOG(const char *fmt, ...) __attribute__((format(printf,1,2))); 第一个参数 printf 是告诉编译器，按照 printf 函数的检查标准来检查； 第2个参数表示在 LOG 函数所有的参数列表中，格式字符串的位置索引； 第3个参数是告诉编译器要检查的参数的起始位置。 1void LOG(int num, char *fmt, ...) __attribute__((format(printf,2,3))); 在这个函数定义中，多了一个参数 num，格式字符串在参数列表中的位置发生了变化（在所有的参数列表中，索引为2），要检查的第一个变参的位置也发生了变化（索引为3），那我们使用 format 属性声明时，就要写成 format(printf,2,3) 的形式了。 1234567void __attribute__ ((format(printf,1,2))) ESP_LOGI(char *fmt,...) &#123; va_list arg; va_start(arg, fmt); vprintf(fmt, arg); va_end(arg);&#125;","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"mqtt协议解析","slug":"mqtt协议解析","date":"2023-01-18T06:53:02.000Z","updated":"2023-09-13T01:49:59.242Z","comments":true,"path":"2023/01/18/mqtt协议解析/","link":"","permalink":"http://example.com/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/","excerpt":"","text":"MQTT数据帧解析[TOC] MQTT 控制报文格式MQTT控制报文结构组成 固定报头（所有控制报文都包含） 可变报头 消息体 固定报头的组成格式 控制报文的类型 控制报文的类型由第一个字节的4-7位组成 控制报文类型标志位 剩余长度：从第二个字节开始，剩余长度（Remaining Length） 表示当前报文剩余部分的字节数， 包括可变报头和负载的数据。 剩余长度不包括用于编码剩余长度字段本身的字节数。 12345分别表示（每个字节的低 7 位用于编码数据， 最高位是标志位） ：1 个字节时， 从 0(0x00)到 127(0x7f)2 个字节时， 从 128(0x80,0x01)到 16383(0Xff,0x7f)3 个字节时， 从 16384(0x80,0x80,0x01)到 2097151(0xFF,0xFF,0x7F)4 个字节时， 从 2097152(0x80,0x80,0x80,0x01)到 268435455(0xFF,0xFF,0xFF,0x7F) 可变报头可变报头在固定报头和负载之间，可变报头的内容根据报文类型的不同而不同 报文标识符 报文标识符类型 很多控制报文的可变报头部分包含一个两字节的报文标识符字段。 这些报文是 PUBLISH（QoS&gt;0 时）， PUBACK， PUBREC， PUBREL， PUBCOMP， SUBSCRIBE, SUBACK， UNSUBSCIBE，UNSUBACK。 &#96;&#96;&#96;1、SUBSCRIBE， UNSUBSCRIBE 和 PUBLISH（QoS 大于 0） 控制报文必须包含一个非零的 16 位报文标识符（Packet Identifier）。2、客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。3、如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时， 它必须使用相同的标识符。 当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。4、QoS 1 的 PUBLISH 对应的是 PUBACK， QoS 2 的 PUBLISH 对应的是 PUBCOMP，与 SUBSCRIBE 或UNSUBSCRIBE 对应的分别是 SUBACK 或 UNSUBACK [MQTT-2.3.1-3]。5、QoS 设置为 0 的 PUBLISH 报文不能包含报文标识符6、PUBACK, PUBREC, PUBREL 报文必须包含与最初发送的 PUBLISH 报文相同的报文标识符7、SUBACK 和 UNSUBACK 必须包含在对应的 SUBSCRIBE 和 UNSUBSCRIBE 报文中使用的报文标识符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 - **包含标识符的控制报文** ​ ![image-20230118152304772](mqtt协议解析/image-20230118152304772.png)客户端和服务端彼此独立地分配报文标识符。 因此，客户端服务端组合使用相同的报文标识符可以实现并发的消息交换。 ## MQTT控制报文### 1、CONNECT-连接服务端#### 客户端和服务端的网络建立后，第一个报文必须是connect报文，且一个网络连接上只能发送一个网络连接##### connect连接的固定报头（0x10）![image-20230118153045359](mqtt协议解析/image-20230118153045359.png)***剩余字段长度长度等于有效负荷长度加上可变报头的长度***#### 可变报头长度***CONNECT 报文的可变报头按下列次序包含四个字段：***- 协议名（Protocol Name） **（协议名是表示协议名 MQTT 的 UTF-8 编码的字符串） ** - 协议名构成 ![image-20230118153430526](mqtt协议解析/image-20230118153430526.png) ![image-20230118153505227](mqtt协议解析/image-20230118153505227.png) - 协议级别（ProtocolLevel） - Protocol Level byte 协议级别字节构成 ![image-20230118153636758](mqtt协议解析/image-20230118153636758.png)- 连接标志（Connect Flags） - 连接标志位**（连接标志字节包含一些用于指定 MQTT 连接行为的参数。 它还指出有效载荷中的字段是否存在。） ** - 服务端必须验证 CONNECT 控制报文的保留标志位（第 0 位） 是否为 0， 如果不为 0 必须断开客户端连接 。 ![image-20230118153804825](mqtt协议解析/image-20230118153804825.png) - 清理会话（CleanSession） - CleanSession置0：**表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。** - CleanSession置1：**表示创建一个新的临时会话，在客户端断开时，会话自动销毁。** - 遗嘱标志（Will Flsg） - WillFlag位置1：表示如果连接请求被接受了， 遗嘱（Will Message） 消息必须被存储在服务端并且与这个网络连接关联。 之后网络连接关闭时，服务端必须发布这个遗嘱消息， 除非服务端收到DISCONNECT 报文时删除了这个遗嘱消息 。 可以理解为简而言之，就是客户端预先定义好，在自己异常断开的情况下，所留下的最后遗愿（Last Will），也称之为遗嘱（Testament）。这个遗嘱就是一个由客户端预先定义好的主题和对应消息，附加在CONNECT的可变报文头部中，在客户端连接出现异常的情况下，由服务器主动发布此消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323 - WillFlag位置0：网络连接断开时， 不能发送遗嘱消息 - 遗嘱QoS标志（WillQos）**两位标志位用于指定发布遗嘱消息时使用的服务质量等级。 ** - WillQoS可以设置： - 0x00：遗嘱 QoS 服务质量等级 0 - 0x01：遗嘱 QoS 服务质量等级 1 - 0x02：遗嘱 QoS 服务质量等级 2 - 遗嘱保留标志（WillRetain）： - WillRetain置0：遗嘱消息被发布时需要保留 - WillRetain置1：遗嘱消息被发布时不需要保留 - 用户标志（UserNameFlag） - UserNameFlag置0：有效载荷中不能包含用户名字段 - UserNameFlag置1：有效载荷中必须包含用户名字段 - 密码标志（PasswordFlag）**（如果用户名标志被设置为 0， 密码标志也必须设置为 0 ）** - PasswordFlag置0：有效载荷中不能包含密码字段 - PasswordFlag置1：有效载荷中必须包含密码字段 - 保持连接（Keep Alive） **保持字节连接** ![image-20230118161545118](mqtt协议解析/image-20230118161545118.png) 保持连接（Keep Alive） 是一个以秒为单位的时间间隔，表示为一个 16 位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻， 两者之间允许空闲的最大时间间隔。 - 保持连接的值为零表示关闭保持连接功能 - 如果没有任何其它的控制报文可以发送， 客户端必须发送一个**PINGREQ** 报文 - 不管保持连接的值是多少，客户端任何时候都可以发送 PINGREQ 报文，并且使用 PINGRESP 报文判断网络和服务端的活动状态。 - 客户端发送了 PINGREQ 报文之后， 如果在**合理的时间内仍没有收到 PINGRESP 报文**， 它应该关闭到服务端的网络连接。 #### 有效负载***CONNECT 报文的有效载荷（payload） 包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。 如果包含的话， 必须按这个顺序出现：客户端标识符， 遗嘱主题， 遗嘱消息， 用户名， 密码***- 客户端标识符（**服务端使用客户端表示符识别客户端**） - 连接服务端的每个客户端都有**唯一的客户端标识符**（ClientId） 。客户端和服务端都必须使用 ClientId 识别两者之间的 MQTT 会话相关的状态。 - 客户端标识符 (ClientId) 必须存在而且必须是 CONNECT 报文有效载荷的第一个字段 （**标识符ID必须是UTF8编码，只能包含大小写字母和数字**） - 服务端可以允许客户端提供一个零字节的客户端标识符 (ClientId) ，务端必须将这看作特殊情况并分配唯一的客户端标识符给那个客户端。如果客户端提供了一个零字节的客户端标识符， 它必须同时将清理会话标志设置为 1 - 遗嘱主题 如果遗嘱标志被设置为 1， 有效载荷的下一个字段是遗嘱主题（Will Topic） - 遗嘱消息 如果遗嘱标志被设置为 1， 有效载荷的下一个字段是遗嘱消息。 - 用户名 如果用户名（User Name） 标志被设置为 1， 有效载荷的下一个字段就是它。 - 密码 如果密码（Password） 标志被设置为 1， 有效载荷的下一个字段就是它。 密码字段包含一个两字节的长度字段， 长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节） ， 后面跟着 0 到 65535 字节的二进制数据。 #### 响应- 服务端响应 - 网络连接建立后， 如果服务端在合理的时间内没有收到 CONNECT 报文， 服务端应该关闭这个连接。 - 服务端必须按照 3.1 节的要求验证 CONNECT 报文， 如果报文不符合规范， 服务端不发送CONNACK 报文直接关闭网络连接 。 - 如果任何一项检查没通过，按照 3.2 节的描述，它应该发送一个适当的、 返回码非零的CONNACK 响应， 并且必须关闭这个网络连接。 ### 2、CONNACK-确认连接请求#### CONNACK固定报头![image-20230118165402419](mqtt协议解析/image-20230118165402419.png)***剩余长度字段 ：***- 表示可变报头的长度。 对于 CONNACK 报文这个值等于 2。 #### 可变报头![image-20230118165749540](mqtt协议解析/image-20230118165749540.png)- **确认连接标志** - 第 1 个字节是 连接确认标志， 位 7-1 是保留位且必须设置为 0。 第 0 (SP)位 是当前会话（Session Present） 标志。 - **当前会话**（**连接确认标志的第 0 位。**） - 如果服务端收到清理会话（CleanSession） 标志为 1 的连接，除了将 CONNACK 报文中的返回码设置为 0之外，还必须将 CONNACK 报文中的当前会话设置（Session Present） 标志为 0 - 如果服务端收到一个 CleanSession 为 0 的连接， 当前会话标志的值取决于服务端是否已经保存了 ClientId对应客户端的会话状态。 - 如果服务端已经保存了会话状态， 它必须将 CONNACK 报文中的当前会话标志设置为 1 - 如果服务端没有已保存的会话状态， 它必须将 CONNACK 报文中的当前会话设置为 0，还需要将 CONNACK 报文中的返回码设置为 0 。 - 如果服务端发送了一个包含非零返回码的 CONNACK 报文， 它必须将当前会话标志设置为 0 - **连接返回码（可变报头的第二个字节）** ![image-20230118170752934](mqtt协议解析/image-20230118170752934.png) ![image-20230118170806394](mqtt协议解析/image-20230118170806394.png)#### 有效负载无### 3、PUBLISH-发布消息#### publish的固定报头：![image-20230118171158474](mqtt协议解析/image-20230118171158474.png)- **重发标志位** **（第一个字节第3位）** - DUP 标志被设置为 0， 表示这是客户端或服务端第一次请求发送这个 PUBLISH 报文 - DUP 标志被设置为 1，表示这可能是一个早前报文请求的重发。 - **客户端或服务端请求重发一个 PUBLISH 报文时， 必须将 DUP 标志设置为 1 ， 对于 QoS0 的消息， DUP 标志必须设置为 0 **- **服务质量等级** **（第一个字节第1，2位）** - QoS值 = 00：最多分发一次 - QoS值 = 01：至少分发一次 - QoS值 = 10：只分发一次 - QoS值 = 11：保留位- **保留标志位** **（第一个字节第0位）** - 如果客户端发给服务端的 PUBLISH 报文的保留（RETAIN） 标志被设置为 1， 服务端必须存储这个应用消息和它的服务质量等级（QoS） ，以便它可以被分发给未来的主题名匹配的订阅者 - 服务端发送 PUBLISH 报文给客户端时，如果消息是作为客户端一个新订阅的结果发送， 它必须将报文的保留标志设为 1 - 当一个 PUBLISH 报文发送给客户端是因为匹配一个已建立的订阅时，服务端必须将保留标志设为 0 - 保留标志为 1 且有效载荷为零字节的 PUBLISH 报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息 - 如果客户端发给服务端的 PUBLISH 报文的保留标志位 0， 服务端不能存储这个消息也不能移除或替换任何现存的保留消息 - 剩余长度#### publish可变报头##### 主题名- 主题名必须是 PUBLISH 报文可变报头的第一个字段。 - PUBLISH 报文中的主题名不能包含通配符 ##### 报文标识符​ 只有当 QoS 等级是 1 或 2 时，报文标识符（Packet Identifier） 字段才能出现在 PUBLISH 报文中。 ##### 有效负荷​ 有效载荷包含将被发布的应用消息。 有效载荷的长度这样计算： 用固定报头中的剩余长度字段的值减去可变报头的长度。 ##### 响应- 服务质量等级Qos0：无响应- 服务质量等级Qos1：PUBACK 报文- 服务质量等级Qos2：PUBREC 报文##### 动作​ 客户端使用 PUBLISH 报文发送应用消息给服务端， 目的是分发到其它订阅匹配的客户端。 ​ 服务端使用 PUBLISH 报文发送应用消息给每一个订阅匹配的客户端。 ### 4、PUBACK –发布确认 PUBACK 报文是对 QoS 1 等级的 PUBLISH 报文的响应。 #### PUBACK 报文固定报头 ![image-20230118173146808](mqtt协议解析/image-20230118173146808.png) ![image-20230118173205345](mqtt协议解析/image-20230118173205345.png)剩余长度字段表示可变报头的长度。对 PUBACK 报文这个值等于 2. #### 可变报头 包含等待确认的 PUBLISH 报文的报文标识符 ![image-20230118173304813](mqtt协议解析/image-20230118173304813.png)#### 有效负载无### 5、PUBREC – 发布收到（QoS 2， 第一步） #### PUBREC 报文固定报头 ![image-20230118173620945](mqtt协议解析/image-20230118173620945.png)剩余长度字段表示可变报头的长度。 对 PUBREC 报文它的值等于 2。 #### PUBREC 可变报头 可变报头包含等待确认的 PUBLISH 报文的报文标识符。 ![image-20230118173711725](mqtt协议解析/image-20230118173711725.png)#### 有效负载无### 6、PUBREL – 发布释放（QoS 2， 第二步） PUBREL 报文是对 PUBREC 报文的响应。 它是 QoS 2 等级协议交换的第三个报文。 #### 固定报头 ![image-20230118173845828](mqtt协议解析/image-20230118173845828.png)**PUBREL 控制报文固定报头的第 3,2,1,0 位是保留位， 必须被设置为 0,0,1,0。 **剩余长度字段表示可变报头的长度。 对 PUBREL 报文这个值等于 2. #### PUBREL 报文可变报头 可变报头包含与等待确认的 PUBREC 报文相同的报文标识符。 ![image-20230118173946287](mqtt协议解析/image-20230118173946287.png)#### 有效负载无### 7 、PUBCOMP – 发布完成（QoS 2， 第三步）PUBCOMP 报文是对 PUBREL 报文的响应。 它是 QoS 2 等级协议交换的第四个也是最后一个报文。 #### PUBCOMP 报文固定报头 ![image-20230118174114030](mqtt协议解析/image-20230118174114030.png)剩余长度字段表示可变报头的长度。 对 PUBCOMP 报文这个值等于 2。 #### PUBCOMP 报文可变报头 可变报头包含与等待确认的 PUBREL 报文相同的报文标识符。 ![image-20230118174227721](mqtt协议解析/image-20230118174227721.png)#### 有效负载无### 8、SUBSCRIBE - 订阅主题 客户端向服务端发送 SUBSCRIBE 报文用于创建一个或多个订阅。 每个订阅注册客户端关心的一个或多个主题。 为了将应用消息转发给与那些订阅匹配的主题， 服务端发送 PUBLISH 报文给客户端。 SUBSCRIBE报文也（为每个订阅） 指定了最大的 QoS 等级， 服务端根据这个发送应用消息给客户端。 #### SUBSCRIBE 报文固定报头 ![image-20230118174630367](mqtt协议解析/image-20230118174630367.png)**SUBSCRIBE 控制报固定报头的第 3,2,1,0 位是保留位， 必须分别设置为 0,0,1,0。** 剩余长度字段等于可变报头的长度（2 字节） 加上有效载荷的长度。 #### SUBSCRIBE 可变报头可变报头包含客户端标识符。 #### SUBSCRIBE 有效载荷SUBSCRIBE 报文的有效载荷包含了一个主题过滤器列表， 它们表示客户端想要订阅的主题。 **报文有效载荷格式**![image-20230118174912107](mqtt协议解析/image-20230118174912107.png)#### 有效载荷字节格式非规范示例 ![image-20230118175051471](mqtt协议解析/image-20230118175051471.png)![image-20230118175107151](mqtt协议解析/image-20230118175107151.png)#### 响应服务端收到客户端发送的一个 SUBSCRIBE 报文时， 必须使用 SUBACK 报文响应 SUBACK 报文必须和等待确认的 SUBSCRIBE 报文有相同的报文标识符 ### 9、 SUBACK – 订阅确认 服务端发送 SUBACK 报文给客户端， 用于确认它已收到并且正在处理 SUBSCRIBE 报文。 SUBACK 报文包含一个返回码清单， 它们指定了 SUBSCRIBE 请求的每个订阅被授予的最大 QoS 等级。 #### SUBACK 报文固定报头 ![image-20230118175316108](mqtt协议解析/image-20230118175316108.png)剩余长度字段等于可变报头的长度加上有效载荷的长度。 #### SUBACK 报文可变报头 可变报头包含等待确认的 SUBSCRIBE 报文的报文标识符。 ![image-20230118175404006](mqtt协议解析/image-20230118175404006.png)#### 有效载荷有效载荷包含一个返回码清单。 每个返回码对应等待确认的 SUBSCRIBE 报文中的一个主题过滤器。返回码的顺序必须和 SUBSCRIBE 报文中主题过滤器的顺序相同 ##### 有效载荷格式![image-20230118175637006](mqtt协议解析/image-20230118175637006.png) 允许的返回码值：0x00 - 最大 QoS 00x01 - 成功 – 最大 QoS 10x02 - 成功 – 最大 QoS 20x80 - Failure 失败 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107### 10 、UNSUBSCRIBE –取消订阅 客户端发送 UNSUBSCRIBE 报文给服务端， 用于取消订阅主题。 #### UNSUBSCRIBE 报文固定报头 ![image-20230118175754029](mqtt协议解析/image-20230118175754029.png)剩余长度字段等于可变报头的长度加上有效载荷的长度。 #### UNSUBSCRIBE 报文可变报头 ![image-20230118175834119](mqtt协议解析/image-20230118175834119.png)可变报头包含一个报文标识符。 #### 有效载荷UNSUBSCRIBE 报文的有效载荷包含客户端想要取消订阅的主题过滤器列表。 #### 响应服务端必须发送 UNSUBACK 报文响应客户端的 UNSUBSCRIBE 请求。UNSUBACK 报文必须包含和UNSUBSCRIBE 报文相同的报文标识符。 即使没有删除任何主题订阅， 服务端也必须发送一个 SUBACK 响应。 ### 11、UNSUBACK – 取消订阅确认 服务端发送 UNSUBACK 报文给客户端用于确认收到 UNSUBSCRIBE 报文。 #### UNSUBACK 报文固定报头 ![image-20230118202732410](mqtt协议解析/image-20230118202732410.png)剩余长度字段表示可变报头的长度， 对 UNSUBACK 报文这个值等于 2。 #### 可变报头 可变报头包含等待确认的 UNSUBSCRIBE 报文的报文标识符。 ![image-20230118202813135](mqtt协议解析/image-20230118202813135.png)### 有效负载无## 12、PINGREQ – 心跳请求 #### 客户端发送 PINGREQ 报文给服务端的。 - 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。 - 请求服务端发送 响应确认它还活着。 - 使用网络以确认网络连接没有断开。 保持连接（Keep Alive） 处理中用到这个报文 。#### PINGREQ 报文固定报头 ![image-20230118203020292](mqtt协议解析/image-20230118203020292.png)![image-20230118203038983](mqtt协议解析/image-20230118203038983.png)#### 可变报头无#### 有效载荷无#### 响应服务端必须发送 PINGRESP 报文响应客户端的 PINGREQ 报文 ### 13、PINGRESP – 心跳响应 服务端发送 PINGRESP 报文响应客户端的 PINGREQ 报文。 表示服务端还活着。 #### PINGRESP 报文固定报头 ![image-20230118203421595](mqtt协议解析/image-20230118203421595.png)#### 可变报头无#### 有效载荷无### 14、DISCONNECT –断开连接 DISCONNECT 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。 #### DISCONNECT 报文固定报头 ![image-20230118203629687](mqtt协议解析/image-20230118203629687.png)### 报文例子详解#### 1、CONECT 报文（client） 固定报头(2byte) 0x01 ??可变报头 协议名(6byte) 0x00 0x04 ‘M’ ‘Q’ ‘T’ ‘T’ 协议级别(1byte) ?? 连接标志(1byte) ?? 保持连接(2byte) ?? ??有效载荷 客户端标识符(xbyte) 遗嘱主题(如果开启遗嘱标志才有)(abyte) 遗嘱消息(如果开启遗嘱标志才有)(bbyte) 用户名(ybyte) 密码(zbyte &#x3D; 2byte + ?)byte &#x3D; 2 + 6 + 1 + 1 + 2 + x + y + z开启遗嘱标志：byte &#x3D; 2 + 6 + 1 + 1 + 2 + x + y + z + a + b 123#### 2、CONNACK 报文(server) 固定报头(2byte) 0x20 0x20报文标识符(2byte) ?? ??byte &#x3D; 2 + 2 123#### 3、PUBLISH 报文(client) 固定报头(2byte) ?? ??可变报头 主题名(xbyte) 报文标识符(2byte)(只有qos1或qos2才有报文标识符)有效载荷(ybyte) ?? ?? …byte &#x3D; 2 + x + 2 + y 如果是qos0：byte &#x3D; 2 + x + y 123#### 4、PUBACK 报文 (server) 固定报头(2byte) 0x40 0x20报文标识符(2byte) ?? ??byte &#x3D; 2 + 2 123#### 5、PUBREC 报文 固定报头(2byte) 0x50 0x20报文标识符(2byte) ?? ??byte &#x3D; 2 + 2 123#### 6、PUBREL报文 固定报头(2byte) 0x60 0x20报文标识符(2byte) ?? ??byte &#x3D; 2 + 2 123#### 7、PUBCOMP 报文 固定报头(2byte) 0x60 0x20报文标识符(2byte) ?? ??byte &#x3D; 2 + 2 123#### 8、SUBSCRIBE报文 固定报头(2byte) 0x80 ??可变报头 报文标识符(2byte) ?? ??主题过滤器(nbyte &#x3D; 2byte + xbyte + 1byte) 长度(2byte) 主题过滤器(xbyte) 服务质量要求(1byte)byte &#x3D; 2 + 2 + n报文标识符主要用于主题订阅和订阅确认的身份识别!! 123#### 9、SUBACK 报文(server) 固定报头(2byte) 0x90 03可变报头(2byte) ?? ??(返回的这是SUBSCRIBE报文的报文标识符)有效载荷(1byte) ??byte &#x3D; 2 + 2 + 1 123#### 10、UNSUBSCRIBE (client) 固定报头(2byte) 0xA0 ??可变报头 报文标识符(2byte) ?? ??主题过滤器(nbyte &#x3D; 2byte + xbyte) 长度(2byte) 主题过滤器(xbyte)byte &#x3D; 2 + 2 + n 123#### 11、UNSUBACK （server） 固定报头(2byte) 0xB0 02可变报头(2byte) ?? ??(返回的这是SUBSCRIBE报文的报文标识符)byte &#x3D; 2 + 2 123#### 12、PINGREQ报文（client） 固定报头(2byte) 0xC0 0x00byte &#x3D; 2 123#### 13、PINGRESP报文（server） 固定报头(2byte) 0xD0 0x00byte &#x3D; 2 123#### 14、DISCONNECT报文（client） 固定报头(2byte) 0xE0 0x60byte &#x3D; 2","categories":[],"tags":[{"name":"MQTT","slug":"MQTT","permalink":"http://example.com/tags/MQTT/"}]},{"title":"红黑树","slug":"红黑树","date":"2023-01-09T12:12:35.000Z","updated":"2023-09-13T01:49:59.303Z","comments":true,"path":"2023/01/09/红黑树/","link":"","permalink":"http://example.com/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/","excerpt":"","text":"红黑树（rbtree）[TOC] 红黑树特性 1、节点是红节点或者是黑节点 2、根节点为黑色 3、叶节点为黑色（叶节点是指末梢的空姐点Nil或NULL）（保证一半以上是黑节点）（是一个满二叉树） 4、红节点的子节点必须是黑节点 5、新插入的节点是红节点 6、每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同黑色高度） 红黑树规则说明： 规则4和5保证了红黑树的大致平衡，根节点到叶子的所有路径中，最长路径不会超过最短路径的两倍 使得红黑树在最坏的情况下，也能有O（log2N）的查找效率； 红黑树插入规律 红黑树的基本操作左旋右旋对X节点进行左旋 对X节点进行右旋 红黑树节点添加调整红黑树节点添加（添加的节点都是红色节点）将红黑树当作普通二叉树添加节点，只有在进行调整和着色。 当节点插入成功之后，我们需要根据插入的节点进行调整，使其变成一颗红黑树。 插入节点的调整节点插入之后可能出现3种情况： 情况1：插入节点的父亲节点和叔叔节点是红色 情况1处理： 12341、将插入节点的父节点设为黑色2、将插入节点的叔叔节点设为黑色3、将插入节点的祖父节点设为红色4、将祖父节点设为当前节点，之后继续对红色节点操作 情况1处理完成之后会变成，情况2 情况2：插入节点的叔叔节点是黑色，且当前节点是父节点的右孩子 情况2处理： 121、将父节点作为新的当前节点2、以新的当前节点作为支点进行左旋 情况3：插入节点的叔叔节点是黑色，且当前节点是父节点的左孩子 情况3处理： 1231、将父亲节点设为黑色2、将祖父节点设为红色3、以祖父节点为支点进行右旋 红黑树节点删除红黑树节点删除可能出现的情况被删除节点无子节点 case 1:被删除节点为红色 不需要任何处理，红黑树是平衡的。 case 2:被删除节点为黑色 因为删除黑色结点会破坏红黑树的性质5，所以为了不破坏性质5，将node删除后用一个拥有额外黑色的null替代它（可以想象是将node删除后，在这个位置放了一个黑色的权值），剩下的就是调平的过程，最终这个游离的黑色权值被扔掉，整个删除操作完成。 1、node节点的兄弟节点是红色 处理： 12345（左旋父，父祖换色）1、将node的兄弟节点设为“黑色”。2、将node的父节点设为“红色”。3、对node的父节点进行左旋。4、左旋后，重新设置node的兄弟节点。 如果NL节点下面的节点是NIL节点的话，就变成case4情况。 如果NIL节点下面的左节点是红节点，右节点是黑色。变成case3情况. 如果NIL节点下面的右节点是红节点，左节点是黑色。变成case2情况. 2、node的兄弟节点是黑色，兄弟节点的右孩子是红色（兄黑，右红侄） 处理：（处理后，红黑树平衡） 123456（左旋父，祖染父色，父叔黑）1、将node父亲节点的颜色赋值给node的兄弟节点2、将node父亲节点设为黑色3、将node兄弟节点的右孩子设为黑色4、以node父亲节点为支点进行左旋5、设置node节点为根节点 3、node的兄弟节点是黑色，兄弟节点的左孩子是红色（兄黑，左红侄） 处理：（处理后变成兄黑，右红侄） 12345（右旋兄，交换兄弟节点与其右子节点颜色）1、将node兄弟节点的左孩子设为“黑色”。2、将node兄弟节点设为“红色”。3、对node的兄弟节点进行右旋。4、 右旋后，重新设置node的兄弟节点。 4、node节点的兄弟节点是黑色，双黑节点（兄弟节点的子节点是NIL节点） 处理： 1234（兄弟红，用递归，遇到根节点或者是红节点，染黑回）（将兄弟染红，视角递归到P节点（或者说是当前节点是NIL节点的父节点），如果P节点是红色或者是根节点，就直接将P节点染黑返回）1、将node节点的兄弟节点设为红色2、将node的父节点设为新的node节点 如果P节点是红色，直接将P节点染黑返回 如果P节点是黑色，会变成case1情况。 被删除节点只有一个子节点 case 3:被删除节点是黑色（被删除节点是红色不可能，违反规则） 将Node节点删除之后，把他的子节点变成黑色完成红黑树平衡 被删节点有两个子节点（被删节点是黑色或者是红色）当被删节点有两个节点的时候，需要先找到这个被删节点的后继节点（或者是前驱节点），不用改变颜色，将后继节点替换删除节点。 如果删除节点的后继节点是（node-&gt;right&gt;nl）,使用nl替换删除node之后，出现以下情况： 如果nl是黑色，会转变成case 2 如果nl是红色, 会转变成case 1 如果删除节点的后继节点是（node-&gt;right）,使用nl替换删除node之后，出现一下情况： 如果right是黑色，会变成 case 3 如果right是红色，会变成case 1","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"gpio子系统","slug":"gpio子系统","date":"2022-12-05T06:59:46.000Z","updated":"2023-09-13T01:49:59.240Z","comments":true,"path":"2022/12/05/gpio子系统/","link":"","permalink":"http://example.com/2022/12/05/gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"gpio子系统&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi文件中的 GPIO 子节点记录着 GPIO 控制器的寄存器地址 ， gpio4节点123456789101112gpio4: gpio@20a8000 &#123; compatible = &quot;fsl,imx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;; reg = &lt;0x20a8000 0x4000&gt;; interrupts = &lt;GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH&gt;, &lt;GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH&gt;; clocks = &lt;&amp;clks IMX6UL_CLK_GPIO4&gt;; gpio-controller; #gpio-cells = &lt;2&gt;; interrupt-controller; #interrupt-cells = &lt;2&gt;; gpio-ranges = &lt;&amp;iomuxc 0 94 17&gt;, &lt;&amp;iomuxc 17 117 12&gt;;&#125;; compatible：与GPIO子系统的平台驱动做匹配 reg：GPIO 寄存器的基地址， GPIO4 的寄存器组是的映射地址为 0x20a8000-0x20ABFFF interrupts：描述中断相关的信息 clocks：初始化 GPIO 外设时钟信息 gpio-controller：表示 gpio4 是一个 GPIO 控制器 #gpio-cells：表示有多少个 cells 来描述 GPIO 引脚 interrupt-controller：表示 gpio4 也是个中断控制器 #interrupt-cells：表示用多少个 cells 来描述一个中断 gpio-ranges：将 gpio 编号转换成 pin 引脚， &lt;&amp;iomuxc 0 94 17&gt;，表示将 gpio4 的第 0 个引脚引脚映射为 97， 17 表示的是引脚的个数。 gpio4这个节点对整个gpio4进行了描述，使用gpio子系统时需要往设备树添加节点，在驱动程序中使用gpio子系统提供的API实现控制gpio的效果。 在设备树中添加RGB灯的设备树节点在&#x2F;imx6ull-mmc-npi.dtb 的根节点下面添加RGB节点 1234567891011rgb_led&#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; pinctrl-names = &quot;default&quot;; compatible = &quot;fire,rgb-led&quot;; pinctrl-0 = &lt;&amp;pinctrl_rgb_led&gt;; //指定rgb灯的引脚pinctrl信息。 rgb_led_red = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;//指定引脚使用的哪个 GPIO rgb_led_green = &lt;&amp;gpio4 20 GPIO_ACTIVE_LOW&gt;; rgb_led_blue = &lt;&amp;gpio4 19 GPIO_ACTIVE_LOW&gt;; status = &quot;okay&quot;; &#125;; 1rgb_led_red = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;; rgb_led_red：设置引脚名字，在使用gpio子系统提供的API操作GPIO时会用到。 const char *propname 参数用到rgb_led_red,在获取gpio编号时使用。 &amp;gpio1：指定gpio组 4：指定gpio编号 GPIO_ACTIVE_LOW：指定有效电平 向设备树中添加节点后重新编译设备树。 gpio子系统常用API函数详解of_get_named_gpio：获取gpio编号函数GPIO 编号可以通过 of_get_named_gpio 函数从设备树中获取。 12static inline int of_get_named_gpio(struct device_node *np, const char *propname,int index) np：指定设备节点 propname：GPIO 属性名，与设备树中定义的属性名对应。 index：引脚索引值，在设备树中一条引脚属性可以包含多个引脚，该参数用于指定获取那个引脚。 成功返回gpio编号，失败返回负数； gpio_request ：gpio申请函数一个 GPIO 只能被申请一次，当不再使用某一个引脚时记得将其释放掉。 1static inline int gpio_request(unsigned gpio, const char *label); gpio: 要申请的 GPIO 编号，该值是函数 of_get_named_gpio 的返回值。 label: 引脚名字，相当于为申请得到的引脚取了个别名。 成功返回0，失败返回负数； gpio_free：gpio释放函数1static inline void gpio_free(unsigned gpio); gpio：要释放的 GPIO 编号。 gpio_direction_output：gpio输出设置函数用于将引脚设置为输出模式 1static inline int gpio_direction_output(unsigned gpio , int value); gpio：设置的 GPIO 的编号。 value：输出值， 1，表示高电平。 0 表示低电平。 成功返回0，失败返回负数； gpio_direction_input：gpio输入设置函数用于将引脚设置为输入模式。 1static inline int gpio_direction_input(unsigned gpio) gpio：要设置的 GPIO 的编号。 成功返回0，失败返回负数； gpio_get_value：获取gpio引脚值函数用于获取引脚的当前状态。无论引脚被设置为输出或者输入都可以用该函数获取引脚的当前状态。 1static inline int gpio_get_value(unsigned gpio); gpio：要设置的 GPIO 的编号。 成功返回0，失败返回负数； gpio_set_value：设置gpio输出值该函数只用于那些设置为输出模式的 GPIO. 1static inline int gpio_direction_output(unsigned gpio, int value); gpio：设置的 GPIO 的编号。 value：输出值， 1，表示高电平。 0 表示低电平。 成功返回0，失败返回负数；","categories":[],"tags":[{"name":"Linux设备驱动","slug":"Linux设备驱动","permalink":"http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"}]},{"title":"pinctrl子系统","slug":"pinctrl子系统","date":"2022-12-05T06:09:03.000Z","updated":"2023-09-13T01:49:59.279Z","comments":true,"path":"2022/12/05/pinctrl子系统/","link":"","permalink":"http://example.com/2022/12/05/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"pinctrl子系统pinctrl子系统简介pinctrl 子系统主要用于管理芯片的引脚 pinctrl子系统编写格式iomuxc节点介绍去找到imx6ull.dtsi里面的iomuxc节点1/home/dirivers/clone/imx_kernel_4.19.35/ebf_linux_kernel_6ull_depth1/arch/arm/boot/dts/imx6ull.dtsi 1234iomuxc: iomuxc@20e0000 &#123; compatible = &quot;fsl,imx6ul-iomuxc&quot;; reg = &lt;0x20e0000 0x4000&gt;;&#125;; compatible：与平台驱动做匹配的名字，这里是与pinctrl平台做匹配的名字 reg：表示的是引脚配置寄存器的基地址 在imx6ull-mmc-npi.dts里面使用&amp;iomuxc向iomuxc节点追加内容。12345678910111213&amp;iomuxc &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;; pinctrl_hog_1: hoggrp-1 &#123; fsl,pins = &lt; MX6UL_PAD_UART1_RTS_B__GPIO1_IO19 0x17059 /* SD1 CD */ MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT 0x17059 /* SD1 VSELECT */ MX6UL_PAD_GPIO1_IO09__GPIO1_IO09 0x17059 /* SD1 RESET */ &gt;; &#125;; ...&#125; pinctrl-names：指定pin的状态列表，默认设置为”default” pinctrl-0 &#x3D; &lt;&amp;pinctrl_hog_1&gt;：表示在默认设置下，将使用pinctrl_hog_1这个节点来设置GPIO端口状态 其余都是pinctrl子节点，按照规范格式编写 pinctrl向iomuxc举例说明1234567891011121314151617181920212223&amp;iomuxc &#123; pinctrl-names = &quot;default&quot;,&quot;sleep&quot;,&quot;init&quot;; pinctrl-0 = &lt;&amp;pinctrl_uart1&gt;; pinctrl-1 =&lt;&amp;xxx&gt;; pinctrl-2 =&lt;&amp;yyy&gt;; ... pinctrl_uart1: uart1grp &#123; fsl,pins = &lt; MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1 MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1b0b1 &gt;; &#125;; xxx: xxx_grp &#123; ... 这里设置将引脚设置为其他模式 &#125; yyy: yyy_grp &#123; ... 这里设置将引脚设置为其他模式 &#125; ...&#125; pinctrl-names： 定义引脚状态。 pinctrl-0： 定义第 0 种状态需要使用到的引脚配置，可引用其他节点标识。 pinctrl-1： 定义第 1 种状态需要使用到的引脚配置。 pinctrl-2： 定义第 2 种状态需要使用到的引脚配置 pinctrl子节点格式规范，格式框架123456pinctrl_自定义名字：自定义名字&#123; fsl,pins = &lt; 引脚复用宏定义 PAD（引脚属性） 引脚复用宏定义 PAD（引脚属性） &gt;;&#125;; 引脚复用宏定义在&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ul-pinfunc.hl里面去寻找 12345宏定义格式：#define MX6UL_xxx mux_reg conf_reg input_reg mux_mode input_valmux_reg conf_reg input_reg mux_mode input_val0x0084 0x0310 0x0000 0x0 0x0 mux_reg：引 脚 复 用 选 择 寄 存 器 偏 移 地 址 (在寄存器基地址上面偏移（0x0084）) conf_reg：引脚（PAD）属性控制寄存器偏移地址 （基本参考官方给出的配置） input_reg：输入选择寄存器便宜地址 mux_mode：选择需要配置的复用模式0 input_val：输入选择寄存器的值 12#define MX6UL_PAD_BOOT_MODE0__GPIO5_IO10 0x0014 0x02a0 0x0000 5 0#define MX6UL_PAD_BOOT_MODE1__GPIO5_IO11 0x0018 0x02a4 0x0000 5 0 如何新增pinctrl节点在imx6ull-mmc-npi.dts新增pinctrl节点 12345678910111213&amp;iomuxc &#123; pinctrl-names = &quot;default&quot;; pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;; /*新增加的pinctrl节点*/ pinctrl_rgb_led:rgb_led&#123; fsl,pins = &lt; MX6UL_PAD_GPIO1_IO04__GPIO1_IO04 0x000010B1 MX6UL_PAD_CSI_HSYNC__GPIO4_IO20 0x000010B1 MX6UL_PAD_CSI_VSYNC__GPIO4_IO19 0x000010B1 &gt;; &#125;; ...&#125;","categories":[],"tags":[{"name":"Linux设备驱动","slug":"Linux设备驱动","permalink":"http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"}]},{"title":"设备树插件","slug":"设备树插件","date":"2022-12-04T12:51:28.000Z","updated":"2023-09-13T01:49:59.321Z","comments":true,"path":"2022/12/04/设备树插件/","link":"","permalink":"http://example.com/2022/12/04/%E8%AE%BE%E5%A4%87%E6%A0%91%E6%8F%92%E4%BB%B6/","excerpt":"","text":"设备树插件设备树插件简介设备树插件使用模块化管理硬件资源，可以更加灵活的去使用。 如何使用设备树插件？如果没有开启设备树插件的话，需要更改配置去开启设备树插件 设备树插件语法12345678910/dts-v1/;/plugin/;/&#123; fragment@0 &#123; target-path = &quot;/&quot;; __overlay__ &#123; /* 在此添加要插入的节点 */ &#125;; &#125;;&#125;; &#x2F;dts-v1&#x2F;：用于指定dts的版本 &#x2F;plugin&#x2F;：表示允许使用未定义的引用并记录它们，设备树插件中可以引用主设备树中的节点，而这些“引用的节点”对于设备树插件来说就是未定义的，所以设备树插件应该加上“&#x2F;plugin&#x2F;”。 target-path &#x3D; “xxx”：指定插件设备树的 父节点路径 target-path &#x3D; “&#x2F;“,指定设备树插件的加载位置,默认加载到根节点下。 {overlay }：将要插入的设备及节点或者要引用追加的设备树节点放在overlay{}内； 设备树插件使用方式编译设备树插件使用手动编译(借助linux内核里面的插件编译工具)找到scripts目录下面的dtc文件 1/home/kernel/build/scripts/dtc 在scripts当前目录执行,将dts文件编译成dtbo 1234./scripts/dtc/dtc -I dts -O dtb -o xxx.dtbo arch/arm/dts/xxx.dts/home/kernel/build/scripts/dtc/dtc -I dts -O dtb -o xxx.dtbo arch/arm/dts/xxx.dts//实际使用sudo /home/kernel/build/scripts/dtc/dtc -I dts -O dtb -o devtree_led.dtbo devtree_led.dts 将dtbo文件反编译成dts 1./scripts/dtc/dtc -I dtb -O dts -o xxx.dtbo arch/arm/dts/xxx.dtbo 使用apt下载dtc工具1sudo apt install device-tree-compiler 插件设备树的加载在内核运行状态加载（通用）1、在&#x2F;sys&#x2F;kernel&#x2F;config&#x2F;device-tree&#x2F;overlays&#x2F;目录下创建一个新目录 1sudo mkdir /sys/kernel/config/device-tree/overlays/xxx 2、将dtbo固件echo到path属性文件中 1echo xxx.dtbo &gt; /sys/kernel/config/device-tree/overlays/xxx/path 或者将dtbo的内容cat到dtbo属性文件 1cat xxx.dtbo &gt;/sys/kernel/config/device-tree/overlays/xxx/dtbo 3、节点将被创建，查看内核设备树 1ls /proc/device-tree 4、删除“插件设备树” 1rmdir /sys/kernerl/config/device-tree/overlays/xxx 使用uboot加载（Linux_野火开发板）修改&#x2F;boot&#x2F;uEnv.txt配置文件，在uEnv.txt文件里面添加需要加载的dtbo文件","categories":[],"tags":[{"name":"Linux驱动开发","slug":"Linux驱动开发","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux设备树","slug":"Linux设备树","date":"2022-11-27T11:04:04.000Z","updated":"2023-09-13T01:49:59.223Z","comments":true,"path":"2022/11/27/Linux设备树/","link":"","permalink":"http://example.com/2022/11/27/Linux%E8%AE%BE%E5%A4%87%E6%A0%91/","excerpt":"","text":"Linux设备树Linux设备树简介设备树是用来描述硬件平台的硬件资源信息，设备树可以被bootloader（uboot）传递到内核，使内内核可以从设备树中获取硬件信息。 带.dtsi后缀的文件表示的使设备树文件，需要使用设备树文件的话，直接包含设备树文件即可。#include xxx DTS：指.dts格式文件，一种使用ASII文本格式的设备树描述，一个.dts文件对应一个硬件平台。一般位于&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts目录下。（我们一般修改编写的设备树源码就是这个） DTC：指编译设备树源码的工具，一般需要手动安装。DTB：设备树源码编译生成的文件。设备树框架设备树详解设备树源码分析 头文件：设备树的头文件是可以使用#include 去应用设备树文件的。#include “imx6ull.dtsi”, imx6ull.dtsi一般由NXP官方提供。 设备树节点：每一个设备树根节点只有一个根节点。其余都是根节点的子节点，子节点也可以包含其他节点。 设备树节点追加内容：使用&amp;符号去向节点追加数据。 设备树节点设备树节点基本格式设备树中的节点都是按照以下约定命名。 123456node-name@unit-address&#123; 属性 1 = … 属性 2 = … 属性 3 = … 子节点…&#125; node-name节点名称 node-name用于指定节点名称，一般是1-31个字符。 根节点没有节点名，直接使用”&#x2F;“代替这是一个根节点 @：是一个分隔符 unit-address：用于指定单元地址，他的值要和”reg“属性的第一个地址一致，若没有”reg”属性可省略。 设备树节点标签imx6ull.dtsi 头文件中 ，cpu前面多了个cpu0，这个cpu0就是该节点的标签。 1cpu0: cpu@0 通常节点标签是节点名的简写。其他位置需要引用该节点时，可以直接使用节点标签。 设备树节点路径通过指定从根节点到所需节点的完整路径，可以唯一地标识设备树中的节点， 不同层次的设备树节点名字可以相同，同层次的设备树节点要唯一。 设备树节点属性在节点的{}中包含的内容就是节点的属性。通常一个节点包含多个属性信息，这些信息会传递到内核的信息描述中，驱动可以通过API函数去获取这些属性信息。 1234567intc: interrupt-controller@a01000 &#123; compatible = &quot;arm,cortex-a7-gic&quot;; #interrupt-cells = &lt;3&gt;; interrupt-controller; reg = &lt;0xa01000 0x1000&gt;, &lt;0xa02000 0x100&gt;;&#125;; compatible属性：字符串类型的属性。 compatible 属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。 设备树中没有代表了一个设备的节点都要有一个compatible属性，（设备驱动在匹配时需要使用compatible来匹配），compatible属性是用来查找节点的方法之一。节点名和节点路径都可以用来查找指定节点。 model属性：字符串属性类型 model属性用于指定设备的制造商和型号 1model = &quot;Embedfire i.MX6ULL Board&quot;; status属性：字符串属性类型 status属性用于指示设备的操作状态；可以通过status去禁止设备或者是启用设备。 123sound:sound&#123; status = &quot;disable&quot;;&#125; #address-cell和#size-cells #address-cell和#size-cells属性同时存在，在设备树ocrams结构中，他们使用在由子节点的设备节点，可以用于设置节点的reg属性的书写格式 1234567891011soc &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; compatible = &quot;simple-bus&quot;; interrupt-parent = &lt;&amp;gpc&gt;; ranges; ocrams: sram@900000 &#123; compatible = &quot;fsl,lpm-sram&quot;; reg = &lt;0x900000 0x4000&gt;; &#125;;&#125;; reg属性值由一串数字组成，reg &#x3D; &lt;0x900000 0x4000&gt;中 0x900000是数据地址（地址字段），0x4000是 长度字段（大小字段）。(cells 是一个 32 位宽的数字 ) #address-cells：指定reg属性”地址字段“的长度， #size-cells：指定reg属性”大小字段“的长度， 1234567891011#address-cells = &lt;1&gt;;#size-cells = &lt;1&gt;;reg = &lt;address size&gt;#address-cells = &lt;2&gt;;#size-cells = &lt;1&gt;;reg = &lt;address address size&gt;#address-cells = &lt;1&gt;;#size-cells = &lt;2&gt;;reg = &lt;address size size&gt; reg属性：属性值类型，地址，长度数据对。 reg 属性描述设备资源在其父总线定义的地址空间内的地址。 通常情况下用于表示一块寄存器的起始地址（偏移地址）和长度，在特定情况下也有不同的含义 。 ranges属性：属性值类型，任意数量的 &lt; 子地址、父地址、地址长度 &gt; 编码 该属性提供了子节点地址空间和父地址空间的映射（转换）方法，常见格式是ranges &#x3D; &lt;子地址，父地址，转换长度&gt;。若父地址和子地址空间无需转换，直接省略ranges属性。 12若#address-cells 和 #size-cells 都为 1ranges=&lt;0x0 0x10 0x20&gt; 将子地址0x0-0x20的地址空间映射到父地址0x20-(0x20+0x20)的地址。 追加、修改节点内容 1234&amp;cpu0 &#123; dc-supply = &lt;&amp;reg_gpio_dvfs&gt;; clock-frequency = &lt;800000000&gt;;&#125;； “&amp;cpu0”表示向“节点标签”为“cpu0”的节点追加数据，这个节点可能定义在本文件也可能定义在本文件所包含的设备树文件中 特殊节点：aliases子节点 作用是为其他节点起一个别名， 12345aliases &#123; can0 = &amp;flexcan1; can1 = &amp;flexcan2; ...&#125;; flexcan1”是一个节点的名字，设置别名后我们可以使用“can0”来指代 flexcan1 节点，与节点标签类似。 chosen子节点 123chosen &#123; stdout-path = &amp;uart1;&#125;; chosen 子节点不代表实际硬件，它主要用于给内核传递参数。这里只设置了“stdout-path &#x3D;&amp;uart1;”一条属性，表示系统标准输出 stdout 使用串口 uart1。 获取设备树节点信息使用of操作函数去获取设备节点资源。 查找节点函数device_node结构体： 1234567891011121314151617181920212223struct device_node &#123; const char *name; const char *type; phandle phandle; const char *full_name; struct fwnode_handle fwnode; struct property *properties; struct property *deadprops; /* removed properties */ struct device_node *parent; struct device_node *child; struct device_node *sibling;#if defined(CONFIG_OF_KOBJ) struct kobject kobj;#endif unsigned long _flags; void *data;#if defined(CONFIG_SPARC) const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans;#endif&#125;; name： 节点中属性为 name 的值 type： 节点中属性为 device_type 的值 full_name： 节点的名字，在 device_node 结构体后面放一个字符串， full_name 指向它 properties： 链表，连接该节点的所有属性 parent： 指向父节点 child： 指向子节点 sibling： 指向兄弟节点 1、根据节点路径寻找节点函数（推荐）获取device_node结构体； 1struct device_node *of_find_node_by_path(const char *path) path： 指定节点在设备树中的路径 返回值：device_node： 结构体指针 ，如果查找失败则返回 NULL 得到device_node 结构体之后我们就可以使用其他 of 函数获取节点的详细信息 2、根据节点名字寻找节点函数（不建议）12struct device_node *of_find_node_by_name(struct device_node *from,const char *name); from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果设置为 NULL 表示从根节点开始查找。 name： 要寻找的节点名。 返回值：device_node： 结构体指针 ，如果查找失败则返回 NULL 3、根据节点类型寻找节点函数（不建议）12struct device_node *of_find_node_by_type(struct device_node *from，constchar *type) from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果设置为 NULL 表示从根节点开始查找。 type： 要查找节点的类型，这个类型就是 device_node-&gt; type。 返回值：device_node： 结构体指针 ，如果查找失败则返回 NULL 4、根据节点类型和compatible属性寻找节点函数（不建议 ）12struct device_node *of_find_compatible_node(struct device_node *from,const char *type, const char *compatible) from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果设置为 NULL 表示从根节点开始查找。 type： 要查找节点的类型，这个类型就是 device_node-&gt; type。 compatible： 要查找节点的 compatible 属性。 返回值：device_node： 结构体指针 ，如果查找失败则返回 NULL 5、根据匹配表寻找节点函数123static inline struct device_node *of_find_matching_node_and_match(struct device_node *from, const struct of_device_id *matches,const struct of_device_id **match) from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果设置为 NULL 表示从根节点开始查找。 matches： 源匹配表，查找与该匹配表想匹配的设备节点。 of_device_id： 结构体如下。 123456struct of_device_id &#123; char name[32]; char type[32]; char compatible[128]; const void *data;&#125;; name： 节点中属性为 name 的值 type： 节点中属性为 device_type 的值 compatible： 节点的名字，在 device_node 结构体后面放一个字符串， full_name 指向它 data： 链表，连接该节点的所有属性 返回值：device_node： 结构体指针 ，如果查找失败则返回 NULL 6、寻找父节点函数1struct device_node *of_get_parent(const struct device_node *node) node： 指定谁（节点）要查找父节点。 返回值：device_node： device_node 类型的结构体指针，保存获取得到的节点。 失败返回NULL 7、寻找子节点函数12struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev) node： 指定谁（节点）要查找它的子节点 prev： 前一个子节点，寻找的是 prev 节点之后的节点。这是一个迭代寻找过程，例如寻找第二个子节点，这里就要填第一个子节点。参数为 NULL 表示寻找第一个子节点。 返回值：device_node： device_node 类型的结构体指针，保存获取得到的节点。 失败返回NULL 提取属性值的of函数我们获取了device_node结构体之后们就可以获取里面的设备节点属性信息 。 获取节点属性函数12struct property *of_find_property(const struct device_node *np,const char name,int *lenp np： 指定要获取那个设备节点的属性信息 name： 属性名。 lenp： 获取得到的属性值的大小，这个指针作为输出参数，这个参数“带回”的值是实际获取得到的属性大小。 返回值：获取得到的属性 结构体（property），失败返回NULL； property属性结构体 1234567struct property &#123; char *name; int length; void *value; struct property *next; ...&#125;; name： 属性名 length： 属性长度 value： 属性值 next： 下一个属性 读取整形属性函数读取属性函数是一组函数，分别为读取 8、 16、 32、 64 位数据。 123456789101112//8 位整数读取函数int of_property_read_u8_array(const struct device_node *np, const char *propname, u8 *out_values, size_t sz)//16 位整数读取函数int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz)//32 位整数读取函数int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values, size_t sz)//64 位整数读取函数int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz) np： 指定要读取那个设备节点结构体，也就是说读取那个设备节点的数据。 propname： 指定要获取设备节点的哪个属性。 out_values： 这是一个输出参数，是函数的“返回值”，保存读取得到的数据。 sz： 这是一个输入参数，它用于设置读取的长度。 返回值：返回值，成功返回 0，错误返回错误状态码（非零值）， -EINVAL（属性不存在）， -ENODATA（没有要读取的数据）， -EOVERFLOW（属性值列表太小）。 读取字符串属性函数12int of_property_read_string(const struct device_node *np,const char *propname,const char **out_string) np： 指定要获取那个设备节点的属性信息 propname： 属性名 out_string： 获取得到字符串指针，这是一个“输出”参数，带回一个字符串指针。也就是字符串属性值的首地址。 这个地址是“属性值”在内存中的真实位置，也就是说我们可以通过对地址操作获取整个字符串属性 返回值：返回值，成功返回 0，错误返回错误状态码 12int of_property_read_string_index(const struct device_node *np,const char *propname, int index,const char **out_string) 相比前面的函数增加了参数 index，它用于指定读取属性值中第几个字符串， index 从零开始计数。第一个函数只能得到属性值所在地址，也就是第一个字符串的地址，其他字符串需要我们手动修改移动地址，非常麻烦，推荐使用第二个函数。 …. 内存映射相关of函数of_ioremap函数，直接转换为虚拟地址我们获取相关寄存器地址后，需要将实际物理地址转化为虚拟地址。 内核提供了 of 函数，自动完成物理地址到虚拟地址的转换。 1void __iomem *of_iomap(struct device_node *np, int index) np： 指定要获取那个设备节点的属性信息。 index： 通常情况下 reg 属性包含多段， index 用于指定映射那一段，标号从 0 开始。 返回值：成功，得到转换得到的地址。失败返回 NULL。 常规获取地址的 of 函数 ，获取的是实际物理地址12int of_address_to_resource(struct device_node *dev, int index,struct resource *resource) np： 指定要获取那个设备节点的属性信息。 index： 通常情况下 reg 属性包含多段， index 用于指定映射那一段，标号从 0 开始。 r： 这是一个 resource 结构体，是“输出参数”用于返回得到的地址信息。 返回值：成功返回 0，失败返回错误状态码。 如何向设备树中添加自己的节点和获取信息1、向设备树里面添加设备节点找到&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-mmc-npi.dts的dts文件 进入&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F; 向dts设备树文件里面添加子节点。 12345678910led_test&#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; rgb_led_red@0x0209C000&#123; compatible = &quot;fire,rgb_led_red&quot;; reg = &lt;0x0209C000 0x00000020&gt;; status = &quot;okay&quot;; &#125;;&#125;; 使用命令只编译设备树进入&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1，在该目录下运行以下命令 12sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- npi_v7_defconfigsudo make ARCH=arm -j4 CROSS_COMPILE=arm-linux-gnueabihf- dtbs 编译成功后生成的设备树文件（.dtb）位于源码目录下的&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;，文件名为“imx6ull-mmc-npi.dtb” 替换开发板上面的imx6ull-mmc-npi.dtb将重新编译的imx6ull-mmc-npi.dtb 设备树文件，替换开发板上面的&#x2F;usr&#x2F;lib&#x2F;linux-image-4.19.35-imx6&#x2F;imx6ull-mmc-npi.dtb 的设备树文件。 Linux系统中查看设备树12ls /proc/device-treels /sys/firmware/devicetree/base 获取设备树信息使用of_find_node_by_path找到设备树节点，再去获取设备树子节点，再去获取子节点里面的寄存器信息。 在板卡上的部分 GPIO 可能会被系统占用，在使用前请根据需要修改 &#x2F;boot&#x2F;uEnv.txt 文件，可注释掉某些设备树插件的加载，重启系统，释放相应的 GPIO 引脚。","categories":[],"tags":[{"name":"Linux设备驱动","slug":"Linux设备驱动","permalink":"http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"}]},{"title":"平台设备驱动","slug":"平台设备驱动","date":"2022-11-23T12:50:30.000Z","updated":"2023-09-13T01:49:59.303Z","comments":true,"path":"2022/11/23/平台设备驱动/","link":"","permalink":"http://example.com/2022/11/23/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/","excerpt":"","text":"平台设备驱动平台总线-Linux内核引进的一种虚拟总线（platfrom bus） 平台总线平台总线的注册和匹配方式使用platfrom_bus_type来描述平台总线 12345678struct bus_type platform_bus_type = &#123; .name = &quot;platform&quot;, .dev_groups = platform_dev_groups, .match = platform_match, .uevent = platform_uevent, .pm = &amp;platform_dev_pm_ops ...&#125;; 平台设备总线在Linux启动时自动注册 1bus_register(&amp;platform_bus_type); 平台设备的匹配平台总线采用platform_match函数去匹配平台设备和平台驱动 平台设备去匹配设备可以通过四种方式： 通过设备树机制去进行匹配 通过设备树去获取设备信息，来进行匹配 12if (of_driver_match_device(dev, drv))return 1 ACPI匹配模式 12if (acpi_driver_match_device(dev, drv))return 1; id_table方式去匹配 通过我们在定义驱动结构体（platform_driver ）时提供的id_table数组，去比较id_table里面的 name成员与平台设备成员里面的的name成员，来进行匹配。 12if (pdrv-&gt;id_table)return platform_match_id(pdrv-&gt;id_table, pdev) != NULL; 12345678910111213static const struct platform_device_id *platform_match_id( const struct platform_device_id *id, struct platform_device *pdev)&#123; while (id-&gt;name[0]) &#123; if (strcmp(pdev-&gt;name, id-&gt;name) == 0) &#123; pdev-&gt;id_entry = id; return id; &#125; id++; &#125; return NULL;&#125; 如果要使用id_table方式去进行匹配我们需要在添加平台驱动的时候添加id_table数组元素。 字符串比较方式去匹配 1return (strcmp(pdev-&gt;name, drv-&gt;name) == 0); 上面四种匹配方式的先后顺序是从上到下，最上面的匹配方式优先级最高，最下面的匹配方式优先级最低。 什么时候进行平台总线匹配？每当有新的设备或者是新的驱动加入到总线时，总线会调用paltform_match函数去对新添加的设备或者是驱动，进行配对。 平台设备内核使用platform_device来描述平台设备1234567891011121314151617struct platform_device &#123; const char *name; int id; bool id_auto; struct device dev; u32 num_resources; struct resource *resource; const struct platform_device_id *id_entry; char *driver_override; /* Driver name to force a match */ /* MFD cell pointer */ struct mfd_cell *mfd_cell; /* arch specific additions */ struct pdev_archdata archdata;&#125;; name：设备名称，总线进行匹配时，会比较设备和驱动的名称是否一致； id ：设备的编号，如果Linux里面设备同名，则通过该编号来识别不同设备。 dev：继承Linux里面的设备模型中的device结构体，管理平台设备。 num_resources：记录资源的个数，当结构成员resource存放的是数组时，记录的是数组的个数。 使用ARRAY_SIZE计算数组大小。 resource：平台设备提供给驱动的资源，irq,dma,io,内存。 id_entry：平台设备提供的一种匹配方式。 使用resource 来描述提供给驱动的资源12345678struct resource &#123; resource_size_t start; resource_size_t end; const char *name; unsigned long flags; unsigned long desc; struct resource *parent, *sibling, *child;&#125;; 需要指定资源的名字（可有可无），指定资源的起始地址和结束地址，指定提供资源的类型。 start：资源的起始地址 end：资源的结束地址 name：指定资源的名字（可设置为NULL） flags：指定资源的类型 IORESOURCE_IO：用于IO地址空间，用于IO端口映射 IORESOURCE_MEM：用于外设的可直接寻址的地址空间 IORESOURCE_IRQ：指定该设备使用某个中断 IORESOURCE_DMA：指定去使用某个DMA通道 一般使用IO内存映射的方式（IORESOURCE_MEM）去访问内存，去读写寄存器。 注意：如果使用中断引脚或者是使用DMA通道只是用一个的话，start和end必须是相等的。平台设备采用platform_device 结构体中的dev对象里面的platform_data 来保私有数据1platform_device-&gt;device-&gt;platform_data 12345678910static struct platform_device red_led_device = &#123; .name = &quot;led_dev&quot;,/*需要和driver匹配的名字*/ .id = 1, .num_resources = ARRAY_SIZE(red_led_resource), .resource = red_led_resource, .dev = &#123; .release = red_led_release, .platform_data = red_hard_info,/*硬件信息*/ &#125;,&#125;; 平台设备提供的resource资源 1234567static struct resource red_led_resource[] = &#123; [0] = DEFINE_RES_MEM(GPIO1_DR, 4), [1] = DEFINE_RES_MEM(GPIO1_GDIR, 4), [2] = DEFINE_RES_MEM(IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04, 4), [3] = DEFINE_RES_MEM(CCM_CCGR1, 4), [4] = DEFINE_RES_MEM(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04, 4),&#125;; 平台设备的注册和注销我们定义和初始化platform_device 结构体后，需要将设备注册，挂载在平台设备总线上面。 平台设备的注册使用platform_device_register 函数将平台设备注册到平台设备总线上面去 1int platform_device_register(struct platform_device *pdev) 平台设备的注销注销挂载在设备总线上面的平台设备 1void platform_device_unregister(struct platform_device *pdev) 平台驱动内核使用platform_driver来描述平台驱动12345678910struct platform_driver &#123; int (*probe)(struct platform_device *); int (*remove)(struct platform_device *); void (*shutdown)(struct platform_device *); int (*suspend)(struct platform_device *, pm_message_t state); int (*resume)(struct platform_device *); struct device_driver driver; const struct platform_device_id *id_table; bool prevent_deferred_probe;&#125;; probe：平台总线和设备匹配成功之后执行，一般用来对设备的一系列初始化（需自己实现） remove：移除设备之后回调该函数。（需自己实现） driver ：继承device_driver对象 id_table：表示该驱动能够兼容的设备类型。 （需自己添加） 填充id_table结体来支持平台总线的id_table匹配模式。 1234struct platform_device_id &#123; char name[PLATFORM_NAME_SIZE]; kernel_ulong_t driver_data;&#125;; name：支持匹配的驱动名字 driver_data：保存驱动配置（有一些是寄存器配置） 平台驱动的注册和注销平台设备的注册：注册成功后在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;driver 目录下生成一个新的目录项1int platform_driver_register(struct platform_driver *drv); 平台设备的注销1void platform_driver_unregister(struct platform_driver *drv); 平台驱动获取设备信息（资源）平台驱动可以使用platform_get_resource() 函数去获取设备中的resource资源数据。12extern struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num); dev：指定要获取哪个平台设备的资源； type：指定获取资源的类型，如 IORESOURCE_MEM、 IORESOURCE_IO 等； num：指定要获取的资源编号。每个设备所需要资源的个数是不一定的，为此内核对这些资源进行了编号，对于不同的资源，编号之间是相互独立的。 平台驱动获取资源（和上面平台设备提供资源相对应） 12345platform_get_resource(pdev,IORESOURCE_MEM,0);platform_get_resource(pdev,IORESOURCE_MEM,1);platform_get_resource(pdev,IORESOURCE_MEM,2);platform_get_resource(pdev,IORESOURCE_MEM,3);platform_get_resource(pdev,IORESOURCE_MEM,4); 平台设备获取irq设备资源（获取中断引脚）1int platform_get_irq(struct platform_device *pdev, unsigned int num) dev：指定要获取哪个平台设备的资源； num： 指定要获取的资源编号。 平台设备获取私密资源（信息）获取platform_device-&gt;device-&gt;platform_data 保存的私有文件信息 1234static inline void *dev_get_platdata(const struct device *dev)&#123; return dev-&gt;platform_data;&#125; dev： struct device 结构体类型指针 创建平台设备步骤1、定义填充platform_device结构体12345678910static struct platform_device red_led_device = &#123; .name = &quot;led_dev&quot;,/*需要和driver匹配的名字*/ .id = 1, .num_resources = ARRAY_SIZE(red_led_resource), .resource = red_led_resource, .dev = &#123; .release = red_led_release, .platform_data = red_hard_info,/*硬件信息*/ &#125;,&#125;; 2、添加自定义resource资源结构体（以下示例）1234567static struct resource red_led_resource[] = &#123; [0] = DEFINE_RES_MEM(GPIO1_DR, 4), [1] = DEFINE_RES_MEM(GPIO1_GDIR, 4), [2] = DEFINE_RES_MEM(IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04, 4), [3] = DEFINE_RES_MEM(CCM_CCGR1, 4), [4] = DEFINE_RES_MEM(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04, 4),&#125;; 3、实现dev.release回调函数，和添加platform_data私密信息4、调用platform_device_register函数注册添加平台设备创建平台驱动步骤1、定义填充platform_driver结构体123456static struct platform_driver red_led_driver = &#123; .driver.name = &quot;led_dev&quot;, .remove = led_pdrv_remove, .probe = led_pdrv_probe, .id_table = led_id_table,&#125;; 2、实现remove，probe等回调函数3、添加id_table匹配方式1234struct platform_device_id led_id_table[] = &#123; &#123;.name = &quot;led_dev&quot;&#125;, &#123;&#125;&#125;; 4、调用probe函数中初始化平台设备的时候去获取平台资源，并将资源保存到平台驱动结构体中。 使用dev_get_platdata获取私密数据 使用platform_get_resource去获取resource数据 12345678static int probe(struct platform_device *pdev)&#123; dev_get_platdata(&amp;pdev-&gt;dev); platform_get_resource(pdev,IORESOURCE_MEM,0); latform_get_resource(pdev,IORESOURCE_MEM,1); platform_set_drvdata(pdev, cur_led);&#125; 使用devm_ioremap去将寄存器地址转化为虚拟地址 1devm_ioremap(&amp;pdev-&gt;dev, mem_dr-&gt;start, resource_size(mem_dr)); 5、调用platform_driver_register函数去注册添加驱动到平台总线上面","categories":[],"tags":[{"name":"Linux设备驱动","slug":"Linux设备驱动","permalink":"http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"}]},{"title":"Linux设备模型","slug":"Linux设备模型","date":"2022-11-23T12:31:45.000Z","updated":"2023-09-13T01:49:59.223Z","comments":true,"path":"2022/11/23/Linux设备模型/","link":"","permalink":"http://example.com/2022/11/23/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Linux 设备模型设备模型概念 device（设备）：挂载在某个的物理设备 dirver（驱动）：初始化物理设备和提供一些操作方式 bus（总线）：管理挂载在bus上面的设备和驱动 class （类）：管理相同功能的设备类别，进行统一管理 sys&#x2F;bus 目录下保存的是注册了的总线类型 devices目录下保存的是挂载在该总线上面的所有设备 driver目录下保存的是挂载在总线上面的所有驱动 sys&#x2F;class 目录下保存了在所有注册在kernel里面的设备类型 总线（bus）总线驱动则负责实现总线的各种行为，其管理着两个链表，分别是添加到该总线的设备链表以及 注册到该总线的驱动链表。当你向总线添加（移除）一个设备（驱动）时，便会在对应的列表上 添加新的节点，同时对挂载在该总线的驱动以及设备进行匹配，在匹配过程中会忽略掉那些已经 有驱动匹配的设备。 bus_type：用来描述总线123456789101112struct bus_type &#123; const char *name; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); ... struct subsys_private *p;&#125; name : 指定总线的名称，当新注册一种总线类型时，会在&#x2F;sys&#x2F;bus 目录创建一个新的目录， 目录名就是该参数的值。 bus_groups，dev_groups，drv_groups：分别表示驱动、设备以及总线的属性。 match：总线用来匹配新注册的设备或者是新的驱动。 uevent：总线上面发生添加或移除，就会调用该回调函数。 probe：总线上面的驱动和设备匹配成功之后，执行该回调函数。 remove：设备从总线上面移除是回调该处理函数。 p：用来存放私有数据。 bus总线注册和注销1、bus总线注册：注册成功后会在&#x2F;sys&#x2F;bus&#x2F; 目录下面生成 xxx 文件 &#x2F;sys&#x2F;bus&#x2F;xxx。 1int bus_register(struct bus_type *bus); 2、bus总线注销：注销bus总线 1void bus_unregister(struct bus_type *bus); 设备（device）device结构体描述物理设备1234567891011121314struct device &#123; const char *init_name; struct device *parent; struct bus_type *bus; struct device_driver *driver; void *platform_data; void *driver_data; struct device_node *of_node; dev_t devt; struct class *class; void (*release)(struct device *dev); const struct attribute_group **groups; struct device_private *p;&#125; name ：device（设备）名称 parent：该设备的父对象（在哪一个目录下面挂载） bus：挂载在哪一个总线 of_node：存放设备树中匹配节点 platform_data：特定设备的私有数据 driver_data：驱动的私有数据 class：指向了该设备对应类 devt：标识设备设备号 release：设备被注销时，调用该函数 groups：设备属性组（设备的属性文件） 设备(device)的注册和注销1、设备的注册：注册成功时会在该设备注册的总线目录下创建设备 1int device_register(struct device *dev); 2、设备的注销 1void device_unregister(struct device *dev); driver（驱动）使用device_driver结构体来描述驱动 123456789101112struct device_driver &#123; const char *name; struct bus_type *bus; struct module *owner; const char *mod_name; const struct of_device_id int (*probe) (struct device *dev); int (*remove) (struct device *dev); ... const struct attribute_group **groups; struct driver_private *p;&#125; name：driver（驱动）名称 bus：驱动依赖于哪个总线 owner：该驱动的拥有者 ，一般设置为 THIS_MODULE of_device_id：指定该驱动支持的设备类型 probe：驱动与设备匹配成功之后，执行该回调函数 remove：设备从操作系统中拔出，或者系统重启，会执行该回调函数 groups：驱动属性文件组 驱动（driver）的注册和注销1、驱动的注册：驱动注册成功之后会在该总线下面创建driver文件 1int driver_register(struct device_driver *drv); 2、驱动的注销 1void driver_unregister(struct device_driver *drv); 属性文件attribute属性文件1、属性文件：attribute 结构体来描述&#x2F;sys 目录下的文件 1234struct attribute &#123; const char *name; umode_t mode;&#125;; name : 指定文件的文件名； mode : 指定文件的权限， 2、属性文件组 1234struct attribute_group &#123; const char *name; struct attribute **attrs;&#125;； 设备属性文件设备属性文件接口： 12345struct device_attribute &#123; struct attribute attr; ssize_t (*show)(struct device *dev, struct device_attribute *attr,char *buf); ssize_t (*store)(struct device *dev, struct device_attribute *attr, const char *buf, size_t count); attr：设备属性文件 show：属性文件接口，是cat命令的回调函数接口 store：属性文件接口，是echo命令的回调接口 设备文件的创建：在挂载总线目录下面创建device文件 12extern int device_create_file(struct device *device, const struct device_attribute *entry); 设备文件的注销： 1extern void de vice_remove_file(struct device *dev, device是需要填充好的设备结构体，entry是自己定义的设备属性文件。 定义和填充device_attribute类型的变量： 12#define DEVICE_ATTR(_name, _mode, _show, _store)\\struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store) _name：设备结构体的文件名 _mode：文件权限（rwx） _show：cat回调函数实现 _store：echo回调函数实现 驱动属性文件驱动属性文件： 12345struct driver_attribute &#123; struct attribute attr; ssize_t (*show)(struct device_driver *driver, char *buf); ssize_t (*store)(struct device_driver *driver, const char *buf,size_t count);&#125;； 结构体成员同上面设备文件结构体一样。 驱动文件的创建：在挂载总线目录下面创建driver文件 12extern int __must_check driver_create_file(struct device_driver *driver, const struct driver_attribute *attr); 驱动文件的注销： 12extern void driver_remove_file(struct device_driver *driver, const struct driver_attribute *attr); driver是需要填充好的驱动结构体，attr是自己定义的驱动属性文件。 device是需要填充好的驱动结构体，attr是自己定义的设备属性文件。 12#define DRIVER_ATTR_RW(_name) \\struct driver_attribute driver_attr_##_name = __ATTR_RW(_name) 同上面设备结构体一样。 BUS总线属性文件bus总线结构体： 12345struct bus_attribute &#123; struct attribute attr; ssize_t (*show)(struct device_driver *driver, char *buf); ssize_t (*store)(struct device_driver *driver, const char *buf,size_t count);&#125;； 结构体成员同上面设备文件结构体一样。 bus总线的注册：在&#x2F;sys&#x2F;bus目录下面创建文件 12extern int __must_check bus_create_file(struct bus_type *,struct bus_attribute *); bus总线的注销： 1extern void bus_remove_file(struct bus_type *, struct bus_attribute *); 创建bus结构体和填充该结构体 12#define BUS_ATTR(_name, _mode, _show, _store) \\struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show,_store) 创建BUS，device，driver文件bus总线的创建步骤：bus_type类型结构体： 123456789101112131415161718192021struct bus_type &#123; const char *name; const char *dev_name; struct device *dev_root; const struct attribute_group **bus_groups; const struct attribute_group **dev_groups; const struct attribute_group **drv_groups; int (*match)(struct device *dev, struct device_driver *drv); int (*uevent)(struct device *dev, struct kobj_uevent_env *env); int (*probe)(struct device *dev); int (*remove)(struct device *dev); void (*shutdown)(struct device *dev); int (*online)(struct device *dev); int (*offline)(struct device *dev); int (*suspend)(struct device *dev, pm_message_t state); int (*resume)(struct device *dev); ...&#125;; 1、主要实现match匹配函数的回调函数 1int (*match)(struct device *dev, struct device_driver *drv); 2、填充bus_type结构体的name,match等成员（用于总线注册），并将总线导出 123456static struct bus_type xbus = &#123;.name = &quot;xbus&quot;,.match = xbus_match,&#125;;EXPORT_SYMBOL(xbus); 3、实现属性文件的store,show的回调函数实现，并且创建填充bus_attribute结构体，并且导出到用户空间。 1234ssize_t (*show)(struct bus_type *bus, char *buf);ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);BUS_ATTR(xbus_test, S_IRUSR, show, store); 4、使用bus_register注册总线和使用bus_create_file创建总线文件。 12bus_register(&amp;xbus);bus_create_file(&amp;xbus, &amp;bus_attr_xbus_test); 设备文件的创建步骤：创建成功后会在&#x2F;sys&#x2F;bus&#x2F;xbus&#x2F;devices&#x2F;目录下创建xdev设备文件 1、release回调函数的实现 1void (*release)(struct device *dev); 2、定义设备，并且填充结构体成员，挂载在（xbus）某个总线上面。 1234567extern struct bus_type xbus;static struct device xdev = &#123; .init_name = &quot;xdev&quot;, /*device file name*/ .bus = &amp;xbus, /*xdev belong to xbus*/ .release = xdevice_release,&#125;; 3、定义设备属性（device_attribute），实现show,store属性回调函数，并填充到结构体 12345ssize_t (*show)(struct device *dev, struct device_attribute *attr, char *buf);ssize_t (*store)(struct device *dev, struct device_attribute *attr, const char *buf, size_t count);DEVICE_ATTR(xdev_id, S_IRUSR|S_IWUSR, show, store); 4、使用device_rigister和device_create_file将设备结构体和属性文件注册到内核。 12device_register(&amp;xdev);device_create_file(&amp;xdev, &amp;dev_attr_xdev_id); 驱动属性文件的创建创建成功后会在&#x2F;sys&#x2F;bus&#x2F;xbus&#x2F;driver&#x2F;目录下创建xdev驱动文件 1、实现probe和remove函数的回调 12int (*probe) (struct device *dev);int (*remove) (struct device *dev); 2、创建xdriver对象，并且为xdriver对象填充数据。并且初始化挂载在那个总线上面 123456static struct device_driver xdriver = &#123; .name = &quot;xdev&quot;, .probe = probe, .bus = &amp;xbus, .remove = remove,&#125;; 3、创建属性文件对象，并且实现show,store回调函数，和填充对象数据 1234ssize_t (*show)(struct device_driver *driver, char *buf);ssize_t (*store)(struct device_driver *driver, const char *buf, size_t count);DEVICE_ATTR(xdev,S_IRUSR|S_IWUSR,show,store); 4、驱动的注册（driver_register ）和属性文件的注册（driver_create_file ） 12driver_register(&amp;xdrv);driver_create_file(&amp;xdriver, &amp;driver_attr_drvname);","categories":[],"tags":[{"name":"Linux设备驱动","slug":"Linux设备驱动","permalink":"http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"}]},{"title":"Linux应用编程-共享内存","slug":"Linux应用编程-共享内存","date":"2022-10-28T13:34:34.000Z","updated":"2023-09-13T01:49:59.211Z","comments":true,"path":"2022/10/28/Linux应用编程-共享内存/","link":"","permalink":"http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"Linux应用开发-共享内存共享内存的概念共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。 1、共享内存由以下特点： 1234- 共享内存是进程间通信中效率最高的方式之一。- 共享内存是系统出于多个进程之间通讯的考虑，而预留的的一块内存区，因此共享内存是以传输数据为目的的。- 共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。- 共享内存无同步无互斥。 2、共享内存的优缺点： 1234- 优点：使用共享内存进行进程间的通信非常方便，而且函数的接口也简单，数据的共享使进程间的数据不用传送，而是直接访问内存，加快了程序的效率。任意进程之间都可以对共享内存做读写操作。- 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段（如信号量、互斥量等）来进行进程间的同步工作。 共享内存API函数创建共享内存函数shmget() 函数的创建或获取一个共享内存对象，并返回共享内存标识符。 1234567891011121314151617int shmget(key_t key, size_t size, int shmflg);- key：标识共享内存的键值- size：共享内存大小，所有的内存分配操作都是以页为单位的，所以即使只申请只有一个字节的内存，内存也会分配整整一页。- shmflg：创建的共享内存的模式标志参数 * IPC_CREAT：如果内核中不存在关键字与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符。 * IPC_EXCL：如果内核中不存在键值与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存则报错。 * SHM_HUGETLB：使用“大页面”来分配共享内存，所谓的“大页面”指的是内核为了提高程序性能，对内存实行分页管理时，采用比默认尺寸（4KB）更大的分页，以减少缺页中断。 * SHM_NORESERVE：不在交换分区中为这块共享内存保留空间。返回值： shmget() 函数的返回值是共享内存的 ID。创建失败返回-1。错误代码：- EACCES：指定的消息队列已存在，但调用进程没有权限访问它- EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL 标志- EINVAL：创建共享内存时参数 size 小于 SHMMIN 或大于 SHMMAX。- ENFILE：已达到系统范围内打开文件总数的限制。- ENOENT：给定的 key 不存在任何共享内存，并且未指定 IPC_CREAT。- ENOMEM：内存不足，无法为共享内存分配内存。- EACCES：没有权限。 内存映射函数shmat() 映射函数 ，共享内存区对象映射到调用进程的地址空间 。 12345678910111213141516void *shmat(int shmid, const void *shmaddr, int shmflg);- shmid：共享内存 ID，通常是由 shmget() 函数返回的。- shmaddr：如果不为 NULL，则系统会根据 shmaddr 来选择一个合适的内存区域，如果为NULL，则系统会自动选择一个合适的虚拟内存空间地址去映射共享内存。- shmflg：操作共享内存的方式： * 0：可读可写 * SHM_RDONLY：以只读方式映射共享内存。 * SHM_REMAP：重新映射，此时 shmaddr 不能为 NULL。 * NULLSHM：自动选择比 shmaddr 小的最大页对齐地址。shmat() 函数调用成功后返回共享内存的起始地址。注意：- 共享内存只能以只读或者可读写方式映射，无法以只写方式映射。- shmat() 第二个参数 shmaddr 一般都设为 NULL，让系统自动找寻合适的地址。但当其确实不为空时，那么要求 SHM_RND 在 shmflg 必须被设置，这样的话系统将会选择比 shmaddr小而又最大的页对齐地址（即为 SHMLBA 的整数倍）作为共享内存区域的起始地址。如果没有设置 SHM_RND，那么 shmaddr 必须是严格的页对齐地址。 解除内存映射函数shmdt() 函数是用来解除进程与共享内存之间的映射的，在解除映射后，该进程不能再访问这个共享内存 。 1234int shmdt(const void *shmaddr);- shmaddr：映射的共享内存的起始地址。注意：该函数并不删除所指定的共享内存区，而只是将先前用 shmat() 函数映射好的共享内存脱离当前进程，共享内存还是存在于物理内存中。 获取或设置属性函数shmctl() 用于获取或者设置共享内存的相关属性。 123456789101112int shmctl(int shmid, int cmd, struct shmid_ds *buf);- shmid：共享内存标识符。- cmd：函数功能的控制命令，其取值如下： * IPC_STAT：获取属性信息，放置到 buf 中。 * IPC_SET：设置属性信息为 buf 指向的内容。 * IPC_RMID：删除这该共享内存。 * IPC_INFO：获得关于共享内存的系统限制值信息。 * SHM_INFO：获得系统为共享内存消耗的资源信息。 * SHM_STAT：与 IPC_STAT 具有相同的功能，但 shmid 为该 SHM 在内核中记录所有SHM 信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有 SHM 的相关信息。 * SHM_LOCK：禁止系统将该 SHM 交换至 swap 分区。 * SHM_UNLOCK：允许系统将该 SHM 交换至 swap 分。- 共享内存属性信息结构体指针（属性缓冲区）一般设为NULL","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-IPC信号量","slug":"Linux应用编程-IPC信号量","date":"2022-10-28T12:30:16.000Z","updated":"2023-09-13T01:49:59.210Z","comments":true,"path":"2022/10/28/Linux应用编程-IPC信号量/","link":"","permalink":"http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-IPC%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"Linux应用编程-信号量信号量的工作原理信号量的PV操作信号量只能进行两种操作：等待和发送信号，即 P 操作和 V 操作，锁行为就是 P 操作，解锁就是 V 操作，可以直接理解为 P 操作是申请资源， V 操作是释放资源。 ipcs -l 查看ipc信息 信号量的P操作： 123P 操作：如果有可用的资源（信号量值大于 0），则占用一个资源（给信号量值减去一，进入临界区代码） ; 如果没有可用的资源（信号量值等于 0），则阻塞，直到系统将资源分配给该进程（进入等待队列，一直等到资源轮到该进程）。 信号量的V操作： 12V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞的进程。如果没有进程等待它，则释放一个资源（给信号量值加一）。 在信号量进行 PV 操作时都为原子操作（因为它需要保护临界资源）。 原子操作：单指令的操作称为原子的，单条指令的执行是不会被打断的 IPC信号量函数创建或获取一个信号量semget 函数的功能是创建或者获取一个已经创建的信号量，如果成功则返回对应的信号量标识符，失败则返回-1。 123456789101112int semget(key_t key, int nsems, int semflg);- key：参数 key 用来标识系统内的信号量可以使用ftok函数创建或者是类似（key_t）123- nsems：参数用于在创建信号量的时候，表示可用的信号量数目。- semflg：参数用来指定标志位 * PC_CREAT：IPC_CREAT 标志创建新的信号量，即使该信号量已经存在（具有同一个键值的信号量已在系统中存在），也不会出错。 * IPC_EXCL：同时使用 IPC_EXCL 标志可以创建一个新的唯一的信号量，此时如果该信号量已经存在，该函数会返回出错。 * mode：创建文件模式 0666 创建信号量时，还受到以下系统信息的影响:• SEMMNI：系统中信号量总数的最大值。• SEMMSL：每个信号量中信号量元素个数的最大值。• SEMMNS：系统中所有信号量中的信号量元素总数的最大值。 信号量PV操作信号量的PV操作semop() 函数对信号量进行 PV 操作 。 12345678910111213141516171819int semop(int semid, struct sembuf *sops, size_t nsops);- semid： System V 信号量的标识符，用来标识一个信号量- sops：指向一个 struct sembuf 结构体数组的指针，该数组是一个信号量操作数组 struct sembuf &#123; unsigned short int sem_num; /* 信号量的序号从 0 ~ nsems-1 */ short int sem_op; /* 对信号量的操作， &gt;0, 0, &lt;0 */ short int sem_flg; /* 操作标识： 0， IPC_WAIT, SEM_UNDO */ &#125;; * set_num：用于标识信号量中的第几个信号量， 0 表示第 1 个， 1 表示第 2 个， nsems -1表示最后一个。 * sem_op：sem_op 标识对信号量的所进行的操作类型 ~ sem_op &gt; 0 表示进程未使用或者使用完毕交回资源，表示信号量V(释放操作)，sem_op 的值加到该信号量的信号量当前值 semval ~ sem_op &lt; 0 表示进程需要使用资源，表示信号量P操作（获取资源），当信号量当前值 semval 大于或者等于 -sem_op 时， semval 减掉 sem_op 的绝对值，为该进程分配对应数目的资源。 ~ sem_op = 0 表示进程要阻塞等待，直至信号量当前值 semval 变为 0 * sem_flg，信号量操作的属性标志 ~ IPC_NOWAIT 使对信号量的操作是非阻塞的，即指定了该标志，调用进程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将 errno 设置为 EAGAIN。 ~ SEM_UNDO 维护进程对信号量的调整值，进程退出的时候会自动还原它对信号量的操作 ~ 0 表示正常操作- nsops：表示上面 sops 数组的数量，如只有一个 sops 数组， nsops 就设置为 1 semctl属性函数semctl 函数主要是对信号量集的一系列控制操作，根据操作命令 cmd 的不同，执行不同的操作，第四个参数是可选的。 12345678910111213141516171819202122int semctl(int semid, int semnum, int cmd, ...);- semid： System V 信号量的标识符；- semnum：表示信号量集中的第 semnum 个信号量。它的取值范围： 0 ~ nsems-1 。- cmd：操作命令，主要有以下命令： * IPC_STAT：获取此信号量集合的 semid_ds 结构，存放在第四个参数的 buf 中。 * IPC_SET：通过第四个参数的 buf 来设定信号量集相关联的 semid_ds 中信号量集合权限为 sem_perm 中的 uid， gid， mode。 * IPC_RMID：从系统中删除该信号量集合。 * GETVAL：返回第 semnum 个信号量的值。 * SETVAL：设置第 semnum 个信号量的值，该值由第四个参数中的 val 指定。 * GETPID：返回第 semnum 个信号量的 sempid，最后一个操作的 pid。 * GETNCNT：返回第 semnum 个信号量的 semncnt。等待 semval 变为大于当前值的线程数。 * GETZCNT：返回第 semnum 个信号量的 semzcnt。等待 semval 变为 0 的线程数。 * GETALL：去信号量集合中所有信号量的值，将结果存放到的 array 所指向的数组。 * SETALL：按 arg.array 所指向的数组中的值，设置集合中所有信号量的值。- 第四个参数是可选的：如果使用该参数，该参数的类型为 union semun，它是多个特定命令的联合体 union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */ &#125;;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-消息队列","slug":"Linux应用编程-消息队列","date":"2022-10-27T13:54:25.000Z","updated":"2023-09-13T01:49:59.214Z","comments":true,"path":"2022/10/27/Linux应用编程-消息队列/","link":"","permalink":"http://example.com/2022/10/27/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"Linux应用编程-消息队列消息队列的基本概念消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。 消息队列特点： 12345- 在消息队列中，发送数据用 msgsnd()，接收数据用msgrcv()，消息队列对每个数据都有一个最大长度的限制。- 消息队列也可以独立于发送和接收进程而存在，在进程终止时，消息队列及其内容并不会被删除。- 消息队列提供有格式的字节流。- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级，接收程序可以通过消息类型有选择地接收数据- 消息队列可以实现消息的随机查询，消息不一定要以先进先出的顺序接收，也可以按消息的类型接收。 消息队列API函数 创建或打开消息队列API函数msgget() 123456789101112131415161718192021222324252627msgget() 函数创建的消息队列的数量会受到系统可支持的消息队列数量的限制；msgget() 函数的作用是创建或获取一个消息队列对象，并返回消息队列标识符。int msgget(key_t key, int msgflg);- key：消息队列的关键字值，多个进程可以通过它访问同一个消息队列。可通过ftok函数创建 • key_t ftok(const char *pathname, int proj_id); * path：合法路径 * proj_id：一个整数- msgflg：表示创建的消息队列的标志参数 • IPC_CREAT • IPC_EXCL • mode 这些参数是可以通过“｜”运算符联合起来的，因为它始终是 int 类型的参数。如 msgflag使用参数 IPC_CREAT | 0666 时表示，创建或返回已经存在的消息队列的标识符，且该消息队列的存取权限为0666。如果是 IPC_CREAT 为真表示：如果内核中不存在关键字与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符。而如果为 IPC_CREAT | IPC_EXCL 表示如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错。mode 指 IPC 对象存取权限，它使用 Linux 文件的数字权限表示方式，如 0600， 0666等。返回值： 成功返回队列表示符，失败返回 -1记录在error中的错误代码：– EACCES：指定的消息队列已存在，但调用进程没有权限访问它– EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL标志– ENOENT： key 指定的消息队列不存在同时 msgflg 中没有指定 IPC_CREAT 标志– ENOMEM：需要建立消息队列，但内存不足– ENOSPC：需要建立消息队列，但已达到系统的限制注意：当 key 被指定为 IPC_PRIVATE 时，系统会自动产生一个未用的 key 来对应一个新的消息队列对象，这个消息队列一般用于进程内部间的通信。 发送消息使用的API函数是 msgsnd() 123456789101112131415161718192021222324252627msgsnd() 函数把消息发送到已打开的消息队列末尾; int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);- msqid：消息队列标识符。- msgp：消息队列结构体，msgp 可以是任何类型的结构体，但第一个字段必须为 long 类型。 • struct s_msg&#123; long type; /* 必须大于 0, 消息类型 */ char mtext[１ ]; /* 消息正文，可以是其他任何类型 */ &#125; msgp;– msgsz：要发送消息的大小，不包含消息类型占用的 4 个字节，即 mtext 的长度。- msgflg：消息队列标志位参数 • 0：当消息队列满时， msgsnd() 函数将会阻塞，直到消息能写进消息队列； • IPC_NOWAIT：当消息队列已满的时候， msgsnd() 函数不等待立即返回； • IPC_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。返回值：成功返回0，失败返回-1记录在error中的错误代码：– EAGAIN：参数 msgflg 设为 IPC_NOWAIT，而消息队列已满。– EIDRM：标识符为 msqid 的消息队列已被删除。– EACCESS：无权限写入消息队列。– EFAULT：参数 msgp 指向无效的内存地址。– EINTR：队列已满而处于等待情况下被信号中断。– EINVAL：无效的参数 msqid、 msgsz 或参数消息类型 type 小于 0。msgsnd() 解除阻塞的条件有以下三个条件：- 消息队列中有容纳该消息的空间。- msqid 代表的消息队列被删除。- 调用 msgsnd 函数的进程被信号中断。 接收消息使用的API函数是 msgrcv() 123456789101112131415161718192021222324msgrcv() 函数是从标识符为 msqid 的消息队列读取消息并将消息存储到 msgp 中，读取后把此消息从消息队列中删除.ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int␣,msgflg);msqid：消息队列标识符。- msgp：存放消息的结构体，结构体类型要与 msgsnd() 函数发送的类型相同。- msgsz：要接收消息的大小，不包含消息类型占用的 4 个字节。- msgtyp 有多个可选的值：如果为 0 则表示接收第一个消息，如果大于 0 则表示接收类型等于 msgtyp 的第一个消息，而如果小于 0 则表示接收类型等于或者小于 msgtyp 绝对值的第一个消息。- msgflg 用于设置接收的处理方式，取值情况如下： • IPC_EXCEPT：与 msgtype 配合使用返回队列中第一个类型不为 msgtype 的消息 • IPC_NOWAIT：若在消息队列中并没有相应类型的消息可以接收，则函数立即返回，此时错误码为 ENOMSG • 0: 阻塞式接收消息，没有该类型的消息 msgrcv 函数一直阻塞等待 • IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃返回值： msgrcv() 函数如果接收消息成功则返回实际读取到的消息数据长度，否则返回-1错误代码：存放在error中– E2BIG：消息数据长度大于 msgsz 而 msgflag 没有设置 IPC_NOERROR– EIDRM：标识符为 msqid 的消息队列已被删除– EACCESS：无权限读取该消息队列– EFAULT：参数 msgp 指向无效的内存地址– ENOMSG：参数 msgflg 设为 IPC_NOWAIT，而消息队列中无消息可读– EINTR：等待读取队列内的消息情况下被信号中断msgrcv() 函数解除阻塞的条件也有三个：- 消息队列中有了满足条件的消息。- msqid 代表的消息队列被删除。- 调用 msgrcv() 函数的进程被信号中断。 控制消息队列使用的APIs函数是 msgctl() 1234567891011121314151617181920消息队列是可以被用户操作的，比如设置或者获取消息队列的相关属性，那么可以通过 msgctl()函数去处理它。int msgctl(int msqid, int cmd, struct msqid_ds *buf);- msqid：消息队列标识符。- cmd 用于设置使用什么操作命令 • IPC_SET 设置消息队列的属性，要设置的属性需先存储在结构体 msqid_ds 类型的 buf中，可设置的属性包括： msg_perm.uid、 msg_perm.gid、 msg_perm.mode 以及 msg_qbytes，储存在结构msqid_ds 中。 • IPC_RMID 立即删除该 MSG，并且唤醒所有阻塞在该 MSG 上的进程，同时忽略第三个参数。 • IPC_STAT 获取该 MSG 的信息，获取到的信息会储存在结构体 msqid_ds 类型的 buf 中。 • IPC_INFO 获得关于当前系统中 MSG 的限制值信息。 • MSG_INFO 获得关于当前系统中 MSG 的相关资源消耗信息。 • MSG_STAT 同 IPC_STAT，但 msgid 为该消息队列在内核中记录所有消息队列信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有消息队列的相关信息。- buf：相关信息结构体缓冲区。 • 返回值： • 成功： 0 • 出错： -1错误代码：- EACCESS：参数 cmd 为 IPC_STAT，确无权限读取该消息队列。- EFAULT：参数 buf 指向无效的内存地址。- EIDRM：标识符为 msqid 的消息队列已被删除。- EINVAL：无效的参数 cmd 或 msqid。- EPERM：参数 cmd 为 IPC_SET 或 IPC_RMID，却无足够的权限执行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-管道","slug":"Linux应用编程-管道","date":"2022-10-26T15:39:05.000Z","updated":"2023-09-13T01:49:59.214Z","comments":true,"path":"2022/10/26/Linux应用编程-管道/","link":"","permalink":"http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E7%AE%A1%E9%81%93/","excerpt":"","text":"Linux应用编程-管道管道分类匿名管道（父子之间进行通信）匿名管道：特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后 fork 产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的. 匿名管道没有名字，一般进程无法使用 open() 来获取他的描述符 ，所以匿名管道只能用于亲缘关系进程间通信 。 匿名管道有以下特征： 1234567• 没有名字，因此不能使用 open() 函数打开，但可以使用 close() 函数关闭。• 只提供单向通信（半双工），也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。• 只能用于具有血缘关系的进程间通信，通常用于父子进程建通信。• 管道是基于字节流来通信的。• 依赖于文件系统，它的生命周期随进程的结束而结束。• 写入操作不具有原子性，因此只能用于一对一的简单通信情形。• 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read() 和 write() 等函数。但是它又不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中，因此不能使用 lseek() 来定位。 pipe函数（所有进程间通信）pipe() 函数用于创建一个匿名管道，一个可用于进程间通信的单向数据通道。 123int pipe(int pipefd[2]);pipefd[0] 指管道的读取端， pipefd[1]指向管道的写端pipe函数返回 0 表示创建匿名管道成功 返回 -1 创建失败 创建匿名管道需要一下步骤： 123456• 父进程调用 pipe() 函数创建匿名管道，得到两个文件描述符 pipefd[0]、 pipefd[1]，分别指向管道的读取端和写入端。• 父进程调用 fork() 函数启动（创建）一个子进程，那么子进程将从父进程中继承这两个文件描述符 pipefd[0]、 pipefd[1]，它们指向同一匿名管道的读取端与写入端。• 由于匿名管道是利用环形队列实现的，数据将从写入端流入管道，从读取端流出，这样子就实现了进程间通信，但是这个匿名管道此时有两个读取端与两个写入端，因此需要进行接下来的操作。• 如果想要从父进程将数据传递给子进程，则父进程需要关闭读取端，子进程关闭写入端，如图数据从父进程流向子进程 所示。• 如果想要从子进程将数据传递给父进程，则父进程需要关闭写入端，子进程关闭读取端，如图数据从子进程流向父进程 所示。• 当不需要管道的时候，就在进程中将未关闭的一端关闭即可。 命名管道命名管道： 命名管道可以在多个无关的进程中交换数据（通信） . 命名管道一下特征： 123456• 有名字，存储于普通文件系统之中。• 任何具有相应权限的进程都可以使用 open() 来获取命名管道的文件描述符。• 跟普通文件一样：使用统一的 read()/write() 来读写。• 跟普通文件不同：不能使用 lseek() 来定位，原因是数据存储于内存中。• 具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。• 遵循先进先出（First In First Out）原则，最先被写入 FIFO 的数据，最先被读出来。 mkfifo函数： 1234567891011121314151617181920212223242526int mkfifo(const char * pathname,mode_t mode);- pathname 需要创建的FIFO文件名- mode mode模式及权限参数说明 • O_WRONLY：写管道。 • O_RDONLY：读管道。 • O_RDWR：读写管道。 • O_NONBLOCK：非阻塞。 • O_CREAT：如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。 • O_EXCL：如果使用 O_CREAT 时文件存在，那么可返回错误消息。这一参数可测试文件是否存在。返回值说明如下： • 0：成功 • EACCESS：参数 filename 所指定的目录路径无可执行的权限。 • EEXIST：参数 filename 所指定的文件已存在。 • ENAMETOOLONG：参数 filename 的路径名称太长。 • ENOENT：参数 filename 包含的目录不存在。 • ENOSPC：文件系统的剩余空间不足。 • ENOTDIR：参数 filename 路径中的目录存在但却非真正的目录。 • EROFS：参数 filename 指定的文件存在于只读文件系统内。mkfifo() 会根据参数 pathname 建立特殊的 FIFO 文件，而参数 mode 为该文件的模式与权限。对FIFO进行读操作：-阻塞类型的管道 管道内有数据就读取，没有数据就阻塞在那里-非阻塞类型的管道 不论 FIFO 内是否有数据，读进程都会立即执行读操作，管道内没有数据返回0对FIFO进行写操作：-阻塞类型的管道 写操作将一直阻塞到数据可以被写入。-非阻塞类型的管道 不能写入全部数据，则写操作进行部分写入或者调用失败。 access函数 12345678检查调用进程是否可以对指定的文件执行某种操作。int access(const char* pathname, int mode);- pathname 是文件的路径名+文件名- mode：指定access的作用，取值如下 • F_OK 值为0，判断文件是否存在 • X_OK 值为1，判断对文件是可执行权限 • W_OK 值为2，判断对文件是否有写权限 • R_OK 值为4，判断对文件是否有读权限","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-信号","slug":"Linux应用编程-信号","date":"2022-10-26T12:54:06.000Z","updated":"2023-09-13T01:49:59.210Z","comments":true,"path":"2022/10/26/Linux应用编程-信号/","link":"","permalink":"http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"Linux应用编程-信号Linux系统支持的信号1234567891011121314151617181920212223使用kill -l查看信号信号分类：- 信号值为1-31的信号属于非实时信号（不可靠信号）（不支持排队处理）- 信号值为34-64的信号为实时信号 （可靠信号）（支持排队处理）以下是常用的一些信号：SIGHUP 1 关闭终端 终止 SIGINT 2 ctrl+c 终止 SIGQUIT 3 ctrl+\\ 终止+转储 SIGABRT 6 abort() 停止+转储 SIGPE 8 算术错误 终止 SIGKILL 9 kill -9 pid 终止，不可捕获/忽略 SIGUSR1 10 自定义 忽略 SIGSEGV 11 段错误 终止+转储 SIGUSR2 12 自定义 忽略 SIGALRM 14 alarm() 终止 SIGTERM 15 kill pid 终止 SIGCHLD 17 (子)状态变化 忽略 SIGTOP 19 ctrl+z 暂停，不可忽略/捕获使用kill或者是pkill可以杀死进程• kill + pid 或者 kill + -9 + pid• pkill + 需要杀死的进程名称 信号处理信号的处理方式（实时信号 非实时信号） 123- 忽略信号- 捕捉信号- 让信号默认动作起作用 信号API函数捕获信号API函数： signal函数 12345678910//signal函数typedef void (*sighandler_t)(int); //信号处理函数sighandler_t signal(int signum, sighandler_t handler); //signal 捕获函数- signum 指定捕获的信号- handler 用户处理信号的方式 • SIG_IGN 忽略该信号 • SIG_DFL 采用系统默认方式处理信号 • 使用信号处理函数void sighandler_t(int);返回值：成功 上一次设置的handler 失败SIG_ERR sigaction函数 123456789101112131415161718192021//sigaction函数struct sigaction &#123; void (*sa_handler)(int); 是捕获信号后的处理函数 void (*sa_sigaction)(int, siginfo_t *, void *); 是扩展信号处理函数 sigset_t sa_mask; 是信号掩码 它指定了在执行信号处理函数期间阻塞的信号的掩码，被设置 在该掩码中的信号，在进程响应信号期间被临时阻塞。除非使用 SA_NODEFER 标志 否则即使是当前正在处理的响应的信号再次到来的时候也会被阻塞。 int sa_flags; 系列用于修改信号处理过程行为的标志 void (*sa_restorer)(void);&#125;;sa_flags：- SA_NOCLDSTOP 如果 signum 是 SIGCHLD，则在子进程停止或恢复时，不会传信号给调用 sigaction() 函数的进程。- SA_NOCLDWAIT 它表示父进程在它的子进程终止时不会收到 SIGCHLD 信号，这时子进程终止则不会成为僵尸进程。- SA_NODEFER 不要阻止从其自身的信号处理程序中接收信号，使进程对信号的屏蔽无效，即在信号处理函数执行期间仍能接收这个信号- SA_RESETHAND 信号处理之后重新设置为默认的处理方式。- SA_SIGINFO 指示使用 sa_sigaction 成员而不是使用 sa_handler 成员作为信号处理函数int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);- signum :指定捕获的信号- act :struct sigaction类型的结构体- oldact :返回原有的信号处理参数，一般设置为 NULL 即可。 发送信号API函数： kill函数 123456789kill函数向包括它本身在内的其他进程发送一个信号int kill(pid_t pid,int sig);- pid :pid取值 • pid &gt; 1：将信号 sig 发送到进程 ID 值为 pid 指定的进程。 • pid = 0：信号被发送到所有和当前进程在同一个进程组的进程。 • pid = -1：将 sig 发送到系统中所有的进程，但进程 1（init）除外。 • pid &lt; -1：将信号 sig 发送给进程组号为-pid （pid 绝对值）的每一个进程。- sig :发送的信号值-函数返回值：0 成功 1失败 raise函数 1234raise() 函数只是进程向自身发送信号的，而没有向其他进程发送信号.给当前进程发送指定信号（自己给自己发信号）kill(getpid(),sig) 等同于 raise(sig)int raise(int sig);函数只有一个参数 sig，它代表着发送的信号值，如果发送成功则返回 0，发送失败则返回-1 alarm函数 123alarm() 也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间 seconds 到时，它就向进程发送 SIGALRM 信号。unsigned int alarm(unsigned int seconds);如果在 seconds 秒内再次调用了 alarm() 函数设置了新的闹钟，则新的设置将覆盖前面的设置，即之前设置的秒数被新的闹钟时间取代。它的返回值是之前闹钟的剩余秒数，如果之前未设闹钟则返回 0。 信号集处理函数 屏蔽信号集：屏蔽某些信号 12- 手动去调用信号集函数- 某些场景系统自动取设置信号集 未处理信号集：如果信号集被屏蔽，则记录在未处理信号集中，直到屏蔽信号集解除对信号的屏蔽才会去处理 12- 非实时信号（1-31）：不排队，只留一个（不管来多少信号，只保留最近的一个信号，其他信号全部丢掉）- 实时信号（34-64）：排队，保留全部信号 信号集相关API 1234567891011121314int sigemptyset(sigset_t *set); //将信号集合初始化为0函数 不屏蔽信号int sigfillset(sigset_t *set); //将信号集合初始化为1函数 屏蔽信号int sigaddset(sigset_t *set); //将信号集合某一位设置为1int sigdelset(sigset_t *set); //将信号集合某一位设置为0int sigismember(const sigset_t *set, int signum); //判断某信号是否在屏蔽信号集里面//该函数可以根据参数指定的方法修改进程的信号屏蔽字//将屏蔽信号赋值给屏蔽信号集int sigprocmask(int how, const old_kernel_sigset_t *set,old_kernel_sigset_t *oldset);- how： • SIG_BLOCK:屏蔽某个信号，添加的信号屏蔽字不覆盖之前的，这是一个并集的关系（屏蔽集 |set ） • SIG_UNBLOCK:希望解除BLOCK的信号集合。解除信号集的屏蔽（屏蔽集 &amp;~ set） • SIG_SETMASK:该进程的信号屏蔽是set指向的值。（直接等于我们设置的信号集合）- set：需要传入的屏蔽信号集- oldset：保存旧的屏蔽集的值，NULL表示不保存","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-进程","slug":"Linux应用编程-进程","date":"2022-10-25T14:48:47.000Z","updated":"2023-09-13T01:49:59.215Z","comments":true,"path":"2022/10/25/Linux应用编程-进程/","link":"","permalink":"http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"Linux应用编程-进程fork()进程函数：fork()进程函数用于从一个已存在的进程中去启动一个新进程，新进程成为子进程，原来的进程称为父进程。fork()函数的本质是直接将父进程的内容复制一份，但是子进程与父进程也有不一样的地方。 子进程与父进程相同的内容： 进程的地址空间 进程上下文，代码段 进程的堆栈空间，和内存信息 进程的环境变量，标准的IO缓冲区 打开的文件描述符，信号响应函数，当前的工作路劲 子进程独有的内容： 子进程的进程号PID，PID是进程的唯一的标识符 记录锁，父进程对某文件加锁，子进程不会继承这把锁 挂起信号，父进程的响应但未处理的信号，子进程不会继承 fork函数 12345678pid_t fork(void);fork函数启动成功：父进程会返回子进程的pid,子进程返回0，启动失败：返回-1pid_t getpid(void);函数会返回当前进程pidpid_t getppid(void);函数会返回当前进程的父进程pid exec系列进程替换函数exec系列函数用于替换进程的执行程序，它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换 exec系列函数介绍： 1234567891011121314151617181920int execl(const char *path, const char *arg, ...)int execlp(const char *file, const char *arg, ...)int execle(const char *path, const char *arg, ..., char *const envp[])int execv(const char *path, char *const argv[])int execvp(const char *file, char *const argv[])int execve(const char *path, char *const argv[], char *const envp[])这些函数可以分为两大类execl、execlp和execle传递给子程序的参数个数是可变的。 execv、 execvp 和 execve 通过数组去装载子程序的参数，无论那种形式，参数都以一个空指针 NULL 结束.l----list 列表v----vector 数组参数介绍：const char *path:该参数需要输入文件路径，例如：&quot;/bin/ls&quot; &quot;/bin/pwd&quot;const char *file:该参数需要输入需要执行的应用程序名字，例如：&quot;ls&quot; &quot;pwd&quot;const char *arg:该参数需要输入对应字符，例如：&quot;ls&quot;,&quot;-al&quot;,NULL &quot;pwd&quot;,NULLconst char *agrv[]:该参数需要输入对应数组指针：例如：char *argv[]=&#123;&quot;pwd&quot;,NULL&#125;;！！注意：exec 系列函数是直接将当前进程给替换掉的，当调用 exec 系列函数后，当前进程将不会再继续执行， execl函数： 123456int execl(const char *path, const char *arg, ... )path:指定文件路径arg：执行文件所传递的参数 arg[0],arg[1]...arg[n],最后一个参数必须是NULL做结束标志该函数一般不会返回，除非遇到错误会返回-1 execv函数： 12345int execv(const char *path, char *const argv[])path:指定文件路径argv：执行文件所传递的参数是一个数组指针,最后一个参数必须是NULL做结束标志该函数一般不会返回，除非遇到错误会返回-1 进程的生老病死 进程终止 正常终止 123-main 函数返回-调用_exit()函数终止-调用exit()函数终止 异常终止 12-调用abort()函数异常终止-又系统信号终止 exit函数和_exit()函数： 123void _exit(int status);void exit(int status);传入一个status保存进程终止时的状态码 exit()函数和_exit()函数的异同： 12345exit() 和 _exit() 函数都是用来终止进程的，当程序执行到 exit() 或 _exit() 函数时，进程会无条件地停止剩下的所有操作，清除包括 PCB 在内的各种数据结构，并终止当前进程的运行。_exit() 函数:直接通过系统调用使进程终止运行,清除这个进程使用的内存空间，并销毁它在内核中的各种数据结构.exit() 函数是_exit()函数包装来的。在执行_exit()函数之前，需要清除&quot;IO缓冲区&quot;，有效的保存数据的完整性。清清除&quot;IO缓冲区&quot;是检查文件的打开情况，把文件缓冲区中的内容写回文件 等待进程当一个进程调用了exit()函数之后，该进程并不会直接消失，而是会变成僵尸进程。需要等待其父进程去回收僵尸进程，需要调用waitpid()或者wait()函数去回收僵尸进程并且，释放僵尸进程占有的内存空间，和了解进程终止的状态信息。调用wait函数会阻塞父进程。 wait函数和waitpid函数： 12345678910111213141516171819202122232425262728293031323334//wait函数pid_t wait(int *wstatus);调用wait函数之后 调用成功：返回子进程pid，和进程退出状态失败:返回-1pid_t waitpid(pid_t pid, int *wstatus, int options);pid: 欲等待的子进程的识别码。 • pid&lt;-1 等待进程组号为pid绝对值的任何子进程。 • pid&gt;0 等待进程号为pid的子进程。 • pid=-1 等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。 • pid=0 等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。wstatus：返回的状态值options：控制waitpid()函数的行为，如果不想使用这些选项，则可以把这个参数设为0。 • WNOHANG 如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这个函数上等待；如果结束了，则返回该子进程的进程号。 • WUNTRACED 如果子进程进入暂停状态，则马上返回。 调用wait函数之后 调用成功：返回子进程pid，和进程退出状态失败:返回-1//waitpid函数如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。waitpid(-1,&amp;status,0) = wait(&amp;status)//wait和waitpid函数调用之后返回 wstatus 的值• WIFEXITED(status) ：如果子进程正常结束，返回一个非零值• WEXITSTATUS(status)：如果 WIFEXITED 非零，返回子进程退出码• WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值• WTERMSIG(status) ：如果 WIFSIGNALED 非零，返回信号代码• WIFSTOPPED(status)：如果子进程被暂停，返回一个非零值• WSTOPSIG(status)：如果 WIFSTOPPED 非零，返回一个信号代码 进程组，会话，终端 进程组 123456789进程组：• 对相同的类型的进程进行管理进程组的诞生：• 在shell里面直接执行一个应用程序，对于大部分应用程序，自己就是进程组的首进程。进程组只有一个进程• 如果进程调用了fork函数，那么父子进程同属一个进程组，父进程为首进程• shell中通过管道执行连接起来的应用程序，两个程序同属一个进程组，第一个程序为进程组的首进程进程组id:pgid,由首进程pid决定 pgid：进程组所在的id号 会话（一般关联着一个终端） 123456会话：管理前后台进程组会话的诞生：• 调用调用setsid函数，新建一个会话，应用程序作为会话的第一个进程，称为会话首进程• 用户在终端正确登录之后，启动shell时linux系统会创建一个新的会话，shell进程作为会话首进程。会话id:sidsid:会话首进程id 前台进程组 123前台进程组：shell进程启动时，默认是前台进程组的首进程前台进程组的首进程会占用绘画所关联的终端来运行，shell启动其他应用程序时，其他程序成为首进程 后台进程组 1234567后台进程组的程序是不会占用终端的。在shell终端运行程序时，在后面加上&amp;的符号，可以指定程序运行在后台进程组里面。例：sleep 10 &amp;ctrl+z：会使进程进入后台，同时停止执行。返回终端jobs:查看有哪些后台进程组，和jobs idfg +job id可以把后台进程组切换为前台进程组 终端 12345678910物理终端• 串口终端• lcd终端伪终端（不依赖物理设备）• SSH远程连接产生的终端• 桌面系统产生的终端虚拟终端• linux内核自带的 ctrl+alt+f0~f6来打开不同的终端终端被关闭之后，会话中的所有进程都会被关掉 守护进程守护进程不受终端影响的，终端退出，而也可以继续在后台运行， 写守护进程步骤： 123456789101112• 创建一个子进程，父进程直接退出， - 使用fork()函数创建,• 创建一个新的会话 - 子进程使用setsid()函数创建一个新的会话，没有关联任何终端• 改变守护进程的当前工作目录，改为&quot;/&quot;。因为子进程会继承父进程的工作目录的。所以需要改变工作目录。 - 子进程使用chdir()函数实现• 重设文件权限的掩码（umask可以查看文件权限掩码 0022 -- 只写） 新建文件的权限默认使0666,需要与掩码进行与非(&amp;~)的运算才是实际的文件权限 -子进程使用umask()函数实现 umask直接设置为0• 关闭不需要的文件描述符 - 子进程使用close()函数实现 - 0，1，2文件描述符，分别对应终端的标准输入，输出，出错。不需要与终端相关联所以需要关闭这些文件描述符。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"函数返回二维数组地址","slug":"函数返回二维数组地址","date":"2022-10-22T13:37:41.000Z","updated":"2023-09-13T01:49:59.286Z","comments":true,"path":"2022/10/22/函数返回二维数组地址/","link":"","permalink":"http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/","excerpt":"","text":"返回二维数组地址int *(*p(int))[3]说明：1234//从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,//说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,//说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.//所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 返回二维数组地址方法11234567891011121314151617181920int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;int (*ptraar)[4];int (*vfunc(void))[4]&#123; return parr;&#125;int main()&#123; ptraar = vfunc(); printf(&quot;ptrarr %d\\r\\n&quot;,(*(*ptraar ) + 1)); //ptrarr[0][1] printf(&quot;ptrarr %d\\r\\n&quot;,ptrarr[0][1]); //ptrarr[0][1]&#125;//解析 ptraar = 二维数组首地址 (*ptraar ) = 二维数组元素首地址 (*(*ptraar ) = 一维数组元素首地址 (*(*ptraar ) + 1) = ptrarr[0][1] 返回二维数组地址方法21234567891011int prrs[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;void * func(void)&#123; return prrs;&#125;void *ins;ins = func();ptraar = (int (*)[4])ins;printf(&quot;ptrarr %d\\r\\n&quot;,*(*(ptraar + 1) + 2 )); 返回二维数组地址指针12345678910111213141516171819202122232425int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;int *ptesarr[3][4]=&#123;&#123;&amp;arrss[0],&amp;arrss[1],&amp;arrss[2],&amp;arrss[3]&#125;, &#123;&amp;arrss[4],&amp;arrss[5],&amp;arrss[6],&amp;arrss[7]&#125;, &#123;&amp;arrss[8],&amp;arrss[9],&amp;arrss[10],&amp;arrss[11]&#125;&#125;; int *(*psst)[4];int *(*functions(void))[4]&#123; return ptesarr;&#125;int main()&#123; psst = functions(); printf(&quot;psst ptr = %d\\r\\n&quot;,*(*(*(psst+0)) + 3));//*psst[0][3] printf(&quot;psst ptr arr= %d\\r\\n&quot;,*(psst[1][3]));//*psst[1][3]&#125;// 解析 *psst[2][3] = *(psst[2][3]) *(pstt[2][3]) = *((*(pstt+2)+3)) pstt二维数组首地址 *(pstt) = [二维数组元素首地址] *(*(pstt)) = [一维数组元素首地址] *(*(*(pstt + 2)) + 3) = [二维数组首地址 + 2][一维数组元素首地址 + 3]","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"单链表头插法","slug":"单链表头插法","date":"2022-10-22T13:31:29.000Z","updated":"2023-09-14T08:34:31.942Z","comments":true,"path":"2022/10/22/单链表头插法/","link":"","permalink":"http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/","excerpt":"","text":"单链表头插法单链表数据结构定义1234struct node&#123; struct node *next; int index;&#125; 链表头初始化1static struct node *headHandle = NULL; 链表创建和初始化12345678910111213void node_init(struct node *handle)&#123; memset(handel,0,sizeof(struct node)); struct node *target = headHandle; while(target)&#123; /*判断新节点是否和前面节点一样*/ if(target == handle)&#123; return; &#125; target = target-&gt;next; &#125; handle-&gt;next = headHandle; headHandle = handle;&#125; 删除链表123456789101112void node_delete(struct node *handle)&#123; struct node **cur; for(cur = &amp;headHandle;*cur;)&#123; struct node *entry = *cur; if(entry == handle)&#123; *cur = entry-&gt;next; return; &#125;else&#123; cur = &amp;entry-&gt;next; &#125; &#125;&#125; 链表遍历123456void node_traverse(void)&#123; struct node *target = headHandle; for(;target;target= target-&gt;next)&#123; /*handle*/ &#125;&#125;","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"gitbash安装使用gcc和make","slug":"gitbash安装使用gcc和make","date":"2022-09-24T11:50:14.000Z","updated":"2023-09-13T01:49:59.233Z","comments":true,"path":"2022/09/24/gitbash安装使用gcc和make/","link":"","permalink":"http://example.com/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/","excerpt":"","text":"Git安装gcc编译器和make工具1、gcc编译器和make工具下载http://www.equation.com/servlet/equation.cmd?fa=fortra 2、gcc和make的安装双击下载好的exe,一直点击继续，知道安装结束。 3、配置gcc的环境 找到Git的安装目录，在Git的安装目录下面找到Git\\etc\\profile.d\\env.sh配置文件 打开env.sh文件，添加export PATH&#x3D;”$HOME&#x2F;gcc&#x2F;bin:$PATH” 保存之后，双击env.sh就配置完成 如果添加之后不能保存env.sh文件，就设置权限","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"LED字符设备","slug":"LED字符设备","date":"2022-09-14T14:01:58.000Z","updated":"2023-09-13T01:49:59.209Z","comments":true,"path":"2022/09/14/LED字符设备/","link":"","permalink":"http://example.com/2022/09/14/LED%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","excerpt":"","text":"LED字符设备1、实现虚拟IO映射和读写 虚拟地址映射 12345678910111213使用ioremap函数进行虚拟地址映射函数原型：void __iomem *ioremap(resource_size_t res_cookie, size_t size);参数：res_cookie：实际的物理地址size：映射长度(一般4个字节)返回值： void __iomem*类型的指针，指向被映射的虚拟地址__iomem:主要是用于编译器的检查地址在内核空间的有效性example:#define CCM_CCGR1_BASE (0x020C406C)static void __iomem *IMX6ULL_CCM_CCGR1;IMX6ULL_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE,4); 虚拟地址映射的取消 1234567使用iounmap函数取消虚拟地址映射函数原型：void iounmap(volatile void __iomem *iomem_cookie);参数：iomem_cookie：指向虚拟地址的指针example：iounmap(IMX6ULL_CCM_CCGR1); 虚拟地址的读写 1234567891011121314151617//虚拟地址的读取 8 16 32static inline u8 ioread8(const volatile void __iomem *addr) //8位的读取static inline u16 ioread16(const volatile void __iomem *addr) //16位的读取static inline u32 ioread32(const volatile void __iomem *addr) //32位的读取参数：addr：void __iomem *类型的虚拟地址返回值：u32/u16/u8类型的数据//虚拟地址的写 8 16 32static inline void iowrite8(u8 value, volatile void __iomem *addr)//写入8位数据static inline void iowrite16(u8 value, volatile void __iomem *addr)//写入16位数据static inline void iowrite32(u32 value, volatile void __iomem *addr)//写入32位数据参数：value：写入一个u32/u16/u8类型的数据addr：void __iomem *类型的虚拟地址 2、实现驱动接口 file_operations 结构体的实现 1234567//实现file_operation结构体static struct file_operations led_chrdev_fops = &#123; .owner = THIS_MODULE, .open = led_open, .write = led_write, .release = led_release,&#125;; 操作接口函数的实现 1234//write release open函数的实现static int led_open(struct inode *inode, struct file *filp)static int led_release(struct inode *inode, struct file *filp)static ssize_t led_write(struct file *filp, const char __user *buf,size_t count, loff_t *ppos) 3、数据的拷贝 copy_from_user拷贝用户空间的数据 12345copy_from_user(void *to, const void __user *from, unsigned long n);参数：to：将数据拷贝到内核地址from：需要拷贝的用户空间的地址n：需要拷贝数据的长度 copy_to_user将内核空间数据拷贝到用户空间 1234copy_to_user(void __user *to, const void *from, unsigned long n)to：将数据拷贝到用户空间from：需要拷贝的内核空间数据的地址n：需要拷贝数据的长度 4、添加、删除LED字符设备 使用register_chrdev函数添加LED字符设备（用mknod 创建字符设备文件） 1234567891011121314151617//字符设备注册添加static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)参数：major：主设备号name：设备名字fops：file_operations的指针指向操作接口使用mknod /dev/led c 200 0 //创建一个字符设备/dev/led 主设备号为200 次设备号为0//字符设备注销static inline void unregister_chrdev(unsigned int major, const char *name)参数：major：主设备号name：设备名字//使用register_chrdev函数注册添加字符设备 注册成功会占用1个主设备号和256多个次设备号 使用其他方式添加字符设备 12345678910//动态申请主设备号alloc_chrdev_region();//创建class类class_create(); //cdev设备结构体与file_operations相关联cdev_init();//设备注册-添加设备到cdev_map哈希表中ret = cdev_add();//创建字符设备文件device_create(); 使用其他方式删除字符设备 12345678//删除字符设备文件device_destroy();//删除注册的字符设备（注销设备）cdev_del();//注销设备号unregister_chrdev_region();//删除设备逻辑类class_destroy();","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"字符设备","slug":"字符设备","date":"2022-09-14T10:36:18.000Z","updated":"2023-09-13T01:49:59.291Z","comments":true,"path":"2022/09/14/字符设备/","link":"","permalink":"http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","excerpt":"","text":"字符设备驱动设备驱动框架 1、设备号的申请和注销 设备号的定义 1static struct cdev chrdev; 使用register_chrdev_region函数静态申请设备号 1234567register_chrdev_region函数用于静态地为一个字符设备申请一个或多个设备编号。一般用于指定手动分配主设备号。函数原型：int register_chrdev_region(dev_t from, unsigned count, const char *name)参数：from：需要注册的设备号，不能与被注册的设备号相同count：需要申请的设备号个数name：申请的设备号名称 在 &quot;cat /proc/devices&quot;下可查看到设备名称和设备号返回值：0成功 其他失败 调用alloc_chrdev_region函数动态的申请设备号 12345678调用alloc_chrdev_region函数，内核会自动分配给我们一个尚未使用的主设备号。函数原型：int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)参数：dev：指向dev_t类型数据的指针变量，用于存放分配到的设备编号的起始值；baseminor：次设备号的起始值，通常为0count：指定需要分配的设备编号个数name：设备名称返回值：返回0成功 注销申请的字符设备号 12345使用xxx_chrdev_region()函数申请的设备号可以使用unregister_chrdev_region()注销函数原型：void unregister_chrdev_region(dev_t from, unsigned count)参数：from：指定需要注销的字符设备的设备编号起始值count：指定需要注销的字符设备编号的个数，该值应与申请函数的count值相等 register_chrdev函数申请设备号 1234567891011register_chrdev函数用于分配设备号函数原型：static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)&#123; return __register_chrdev(major, 0, 256, name, fops);&#125;参数：major：用于指定要申请的字符设备的主设备号，major = 0 时，内核会自动分配一个未使用的主设备号。name：设备名称fops：用于操作该设备的函数接口指针返回值：主设备号 unregister_chrdev注销申请的字符设备号 123456789使用register函数申请的设备号，则应该使用unregister_chrdev函数进行注销。函数原型：static inline void unregister_chrdev(unsigned int major, const char *name)&#123;__unregister_chrdev(major, 0, 256, name);&#125;参数：major：指定需要释放的字符设备的主设备号name：执行需要释放的字符设备的名称 设备号宏 1234567#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))MINOR(dev)：用来获取该设备文件的次设备号MINOR(dev)：用来获取该设备文件的主设备号MKDEV(ma,mi)：将主设备号和次设备号一起转成dev_t类型的设备号 2、实现file_operations结构体和初始化cdev 实现file_operations结构体里面的函数 1234567891011static struct file_operations led_chrdev_fops = &#123; .owner = THIS_MODULE, .open = led_chrdev_open, .release = led_chrdev_release, .write = led_chrdev_write,&#125;;实现我们需要用的函数：static int led_chrdev_open(struct inode *inode, struct file *filp)；static int led_chrdev_release(struct inode *inode, struct file *filp)；static ssize_t led_chrdev_write(struct file *filp, const char __user * buf, size_t count, loff_t * ppos)； 初始化cdev 12345使用cdev_init函数将cdev和file_operations 相关联起来函数原型：void cdev_init(struct cdev *cdev, const struct file_operations *fops)参数：cdev：struct cdev类型的指针变量，指向需要关联的字符设备结构体；fops：file_operations类型的结构体指针变量，一般将实现操作该设备的结构体file_operations结构体作为实参。 3、设备注册和注销 设备注册 1234567cdev_add函数用于向内核的cdev_map散列表添加一个新的字符设备函数原型：int cdev_add(struct cdev *p, dev_t dev, unsigned count)参数：p：struct cdev类型的指针，用于指定需要添加的字符设备dev：dev_t类型变量，用于指定设备的起始编号count：指定注册多少个设备返回值：返回为0 添加成功 设备注销 1234cdev_del函数用于向内核的cdev_map散列表删除注册的字符设备函数原型：void cdev_del(struct cdev *p)参数：p：struct cdev类型的指针，用于指定需要删除的字符设备； 4、设备的逻辑类的创建和删除 动态创建设备的逻辑类 12345678910111213class_create()用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。此函数的执行效果就是在/sys/class/目录下创建一个新的文件夹。宏原型：#define class_create(owner, name) \\(&#123; \\ static struct lock_class_key __key; \\ __class_create(owner, name, &amp;__key); \\&#125;)参数：owner：一个struct module结构体类型的指针，一般赋值为THIS_MODULEname：代表即将创建的struct class变量的名字，用于给struct class的name字段赋值class_create(THISMODULE,&quot;chrdev&quot;); //在 /sys/class/目录下面创建一个chrdev文件 删除设备的逻辑类 12345函数class_destroy()用于删除设备的逻辑类即从Linux内核系统中删除设备的逻辑类。此函数执行的效果是删除函数__class_create()或宏class_create()在/sys/class/目录下创建的逻辑类对应的文件夹。函数原型：void class_destroy(struct class *cls);参数：cls：创建成功的class设备的逻辑类 5、设备节点的创建和销毁 代码设备节点的创建 12345678910111213141516device_create函数创建一个设备并将其注册到文件系统函数原型：struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)参数：class：指向这个设备应该注册到的struct类的指针parent：指向此新设备的父结构设备（如果有）的指针devt：要添加的char设备的开发drvdata：要添加到设备进行回调的数据fmt：输入设备名称返回值：成功返回 struct device 结构体指针, 错误时返回ERR_PTR().example:struct class *led_chrdev_class;led_chrdev_class = class_create(THIS_MODULE, &quot;led_chrdev&quot;); //在 /dev/目录下面创建led_chrdev的设备节点文件device_create(led_chrdev_class, NULL, cur_dev, NULL,DEV_NAME &quot;%d&quot;, i); 代码设备节点的销毁 123456789101112使用device_destroy删除使用device_create函数创建的设备函数原型：void device_destroy(struct class *class, dev_t devt)参数：class：指向注册此设备的struct类的指针；devt：以前注册的设备的开发example:static dev_t devno;//已分配的主设备号dev_t cur_dev;cur_dev = MKDEV(MAJOR(devno), MINOR(devno) + i); //将主设备和次设备转化成dev_t类型的设备号device_destroy(led_chrdev_class, cur_dev);//销毁设备节点class_destroy(led_chrdev_class); 注意：class_create 和 class_destroy是成对出现的不可只单独使用其中一个。 使用mknod命令创建节点 12345678910可以使用mknod命令创建设备节点。用法：mknod 设备名 设备类型 主设备号 次设备号设备类型：- b 创建（有缓冲的）区块特殊文件- c,u 创建(没有缓冲的)字符特殊文件- p 创建先进先出(FIFO)特殊文件example://创建一个字符设备/dev/led 主设备号为200 次设备号为0mknod /dev/led c 200 0 6、字符设备驱动流程 设备驱动流程 设备卸载流程 常用命令1234lsmod 显示已载入系统的模块modinfo+模块名字 查看模块详细信息ls /dev/ 查看设备节点cat /proc/devices 查看设备和设备号","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"内核模块","slug":"内核模块","date":"2022-09-10T14:04:20.000Z","updated":"2023-09-13T01:49:59.280Z","comments":true,"path":"2022/09/10/内核模块/","link":"","permalink":"http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"","text":"内核模块内核模块概念-现代内核派系1、现代内核派系-关键功能和服务功能均在内核空间提供（linux） 运行效率高 扩展性差 2、微内核-内核空间提供关键功能，服务功能在用户空间提供 运行效率低 扩展性较高 两者区别如下图： 内核模块实验环境搭建1、搭建开发板环境 开发板烧录Debain镜像-当前开发板内核版本：4.19.35-imx6 启动开发板，搭建nfs客户端，挂载共享文件夹 获取debain镜像内核源码-编译 2、获取内核源码-编译（4.19.35-imx6） 获取linux内核源码 1git clone https://gitee.com/Embedfire/ebf_linux_kernel_6ull_depth1 安装工具配置环境 1sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop 开始编译，构建内核 12./make_deb.sh (如果权限不足加上sudo)修改build_opts=&quot;$&#123;build_opts&#125; O=X&quot;,可以改变安装的路径，X=你想要存放的路径 获取编译的出来的内核文件的相关文件 12将路径下存放的当前的内核相关文件 拷贝到你的工程路径下面/home/kernel/bulid 内核模块所需头文件123#include &lt;linux/module.h&gt; //包含内核模块信声明的相关函数#include &lt;linux/init.h&gt; // 包含module_init module_exit 函数声明#include &lt;linux/kernel.h&gt; //包含内核提供的各种函数，例如printk内核模块打印函数 内核模块函数&#x2F;命令1、内核模块加载、卸载12内核加载命令：insmod内核卸载命令：rmmod 2、内核函数入口，出口 内核函数模块入口-加载模块式函数自动执行，进行初始化操作 内核函数模块出口-卸载模块是函数自动执行，进行清理工作 12内核模块入口函数： module_init();内核模块出口函数： module_exit(); 3、内核模块信息声明 MODULE_LICENSE：内核模块版权声明，模块接受软件许可协议 MODULE_AUTHOR：描述模块作者信息 MODULE_DESCRIPTION：对模块的简单介绍 MODULE_ALIAS：给模块设置一个别名 1234内核模块版权声明，模块接受软件许可协议 MODULE_LICENSE();描述模块作者信息 MODULE_AUTHOR();对模块的简单介绍 MODULE_DESCRIPTION();给模块设置一个别名 MODULE_ALIAS(); 4、内核模块打印函数 printk内核模块打印函数-需要指定打印等级 123456789101112131415161718//打印等级0-7#define KERN_EMERG &quot;&lt;0&gt;&quot; 通常是系统崩溃前的信息#define KERN_ALERT &quot;&lt;1&gt;&quot; 需要立即处理的消息#define KERN_CRIT &quot;&lt;2&gt;&quot; 严重情况#define KERN_ERR &quot;&lt;3&gt;&quot; 错误情况#define KERN_WARNING &quot;&lt;4&gt;&quot; 有问题的情况#define KERN_NOTICE &quot;&lt;5&gt;&quot; 注意信息#define KERN_INFO &quot;&lt;6&gt;&quot; 普通消息#define KERN_DEBUG &quot;&lt;7&gt;&quot; 调试信息打印内核所有打印信息：dmesg查看当前系统的printk打印等级：cat /proc/sys/kernel/printk下图的4417对应4 当前控制台日志级别4 默认消息日志级别1 最小的控制台级别7 默认控制台日志级别 5、模块参数 模块参数：根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性 模块参数函数：module_param 1234567891011121314module_param(name,type,perm);- name 参数名- type 参数类型- perm 读写权限数据类型对应type类型：int类型： int&lt;------------&gt; intchar类型: char&lt;-----------&gt; bytebool类型： bool&lt;-----------&gt; bool字符串类型: char*&lt;----------&gt; charpperm读写权限：- 不可以设置执行权限 如0777- 在sys/modules/模块名/paramters 目录下生成该参数对应的文件名 在加载模块时可以在后面加上模块参数： 12//模块加载时可以给变量赋值的模块参数sudo insmod modpram.ko itype=123 ctype=21 btype=1 stype=&quot;hellos&quot; 在函数里面使用的模块参数： 6、符号共享 内核模块可以共享导出的符号表 可以变量共享和函数共享 符号共享函数：EXPORT_SYMBOL 12EXPORT_SYMBOL(sym);sym:变量名或者是函数名 查看符号表 12cat /proc/kallsyms | grep xxxxxx:需要查看的模块名 7、模块加载 模块手动加载 121、模块加载时必须先加载相关依赖模块2、模块卸载时必须先卸载模块，在卸载依赖模块 模块自动加载 将所有内核模块统一放在 “&#x2F;lib&#x2F;modules&#x2F;内核版本”目录下 1cp *.ko /lib/modules/4.19.35-imx6 建立模块依赖关系 1depmod -a 查看模块依赖关系 1cat /lib/modules/4.19.35-imx6/modlue.dep 加载、卸载模块及其依赖关系 123加载模块及依赖： modprobe xxx下载模块及依赖： modprobe -r xxxxxx：需要操作的模块","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"使用hexo搭建个人博客","slug":"使用hexo搭建个人博客","date":"2022-09-08T16:21:19.000Z","updated":"2023-09-13T01:49:59.280Z","comments":true,"path":"2022/09/09/使用hexo搭建个人博客/","link":"","permalink":"http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用hexo搭建个人博客1、安装环境依赖 安装git（按照默认操作即可） 1如果点击鼠标右键 能够打开git bash 说明git 安装成功 安装node.js 123鼠标右键打开git bash查看node 是否安装成功node -v 安装hexo 12345安装hexo1、桌面新建一个文件夹 blog，git bash 进入文件夹2、设置淘宝镜像原（npm config set registry http://registry.npm.taobao.org）//可要可不要3、安装hexo npm install hexo-cli -g4、检测hexo是否安装完成 hexo -v 生成博客文件 生成博客文件 123打开githexo init blog(如果没有进入到blog文件夹)hexo init (如果进入到blog文件夹) 预览博客文件 12hexo s将生成的网址复制到网页执行，可以看到博客文件 部署博客到gitee平台 在gitee创建一个仓库，创建仓库名称使用gitee用户名。（如果不适用用户名，需要再仓库名后面加.gitee.io） 仓库创建成功后，复制HTTP 链接网址。 配置博客配置文件 _config.yml 1234deploy: type: &#x27;git&#x27; //选择git repo: https://gitee.com/yys_cn_ccs/zhaoqaun.git //gitee http 链接地址 branch: master //git 分支的配置 安装hexo部署工具 1npm install hexo-deployer-git --save 生成静态链接文件（public） 1hexo g 部署（需要输入gitee用户名字加密码） 1hexo d 开启gitee服务 打开gitee 点击右上角“服务”—-选择Gitee Pages 点击部署。 设置hexo主题1、去找到自己希望的 hexi主题，搜索主题名字。 2、将下载好的主题下载后放在 themes 文件下面 ，然后配置博客配置文件 _config.yml，将langscape修改成需要配置的主题名字。如果主题需要一些依赖，根据作者下面提示安装 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 3、安装pure 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 4、pure的依赖 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 使用hexo开始写博客 开始写博客 1hexo new newpapername 博客写完之后 123hexo cleanhexo ghexo d hexo基本配置网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址 参数 描述 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 permalink_defaults 永久链接中各部分的默认值","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-30T12:16:49.877Z","updated":"2023-09-13T01:49:59.241Z","comments":true,"path":"2022/08/30/hello-world/","link":"","permalink":"http://example.com/2022/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hexo如何在网页上面显示图片","slug":"hexo如何在网页上面显示图片","date":"2022-08-29T09:24:28.000Z","updated":"2022-08-30T12:16:49.877Z","comments":true,"path":"2022/08/29/hexo如何在网页上面显示图片/","link":"","permalink":"http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"","text":"hexo如何在网页上面显示图片1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径 2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。1npm install https://github.com/CodeFalling/hexo-asset-image --save 3、配置_config_yml文件12//设置 post_asset_folder 为truepost_asset_folder: true","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"数组指针和指针数组","slug":"数组指针和指针数组","date":"2022-08-29T06:25:05.000Z","updated":"2022-08-30T12:16:49.880Z","comments":true,"path":"2022/08/29/数组指针和指针数组/","link":"","permalink":"http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组指针和指针数组1、数组指针 数组指针：指向数组的指针，优先级顺序是：（）&gt; [] &gt; * 12//根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针int （*p1）[5]; 对于语句“int ( * p1)[5]”，“()”的优先级比“[]”高，“*”号和 p1 构成一个指针的定义，指针变量名为 p1，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p1 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如下所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。 123 -------------------------------------------p1 ----&gt; | int * | init * | int * | init * | int * | ------------------------------------------- 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main()&#123; int (*p)[5]; //定义一个数组指针 int arr[5] = &#123;1,2,3,4,5&#125;; //定义一个数组 p = &amp;arr; //p指向数组首地址 printf(&quot;p0 value = %d\\r\\n&quot;,*(*p + 0)); //arr[0] printf(&quot;p1 value = %d\\r\\n&quot;,*(*p + 1)); //arr[1] printf(&quot;p2 value = %d\\r\\n&quot;,*(*p + 2)); //arr[2] printf(&quot;p3 value = %d\\r\\n&quot;,*(*p + 3)); //arr[3] printf(&quot;p4 value = %d\\r\\n&quot;,*(*p + 4)); //arr[4] return 0;&#125;//p 代表的是数组首地址//arr 代表的是整个数组首元素首地址//&amp;arr 代表整个数组首地址(对数组首元素首地址取地址得到数组首地址)//*p 代表数组首元素首地址//*p+1 代表数组首元素地址 + 1//**p //表示数组首元素首地址对应的值//将二维数组赋给指针#include &lt;stdio.h&gt;int main()&#123; int b[3][4]; int (*pp)[4];//定义一个数组指针，指向含四个元素的一维数组 pp = b;//将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的 pp++;//该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1] return 0;&#125;//根据上面二维数组可以得出，数组指针也称指向一维数组的指针，所以数组指针也称行指针。 2、指针数组 指针数组：装着指针的数组，优先级顺序：[] &gt;* 12int *p2[5];//根据优先级，先看[]，则p是一个数组，再结合*，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。 对于int *p2[5] 来说，因为“ [] ”的优先级要比 “ * ”的优先级要高，所以p2先和“ [] ”结合，构成一个数组的定义，数组名为p2,而“ int ”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如下所示。因此他是一个指针数组。 1234 p2----------------------------------------------------------------------------| | | | |int * int * int * int * int * 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; // ptr 里面存放的是 5个字符串的首元素地址 char *ptr[5]=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;blos&quot;,&quot;456&quot;,&quot;hhels&quot;&#125;; int a = 1; int b = 2; int *p[2]; p[0] = &amp;a; p[1] = &amp;b; printf(&quot;%d\\r\\n&quot;,*p[0]); printf(&quot;%d\\r\\n&quot;,*p[1]); printf(&quot;%s\\r\\n&quot;,ptr[0]); printf(&quot;%s\\r\\n&quot;,ptr[1]); return 0;&#125; 对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针.","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"git初始化连接远程仓库","slug":"git初始化连接远程仓库","date":"2022-08-26T14:47:35.000Z","updated":"2022-08-30T12:16:49.876Z","comments":true,"path":"2022/08/26/git初始化连接远程仓库/","link":"","permalink":"http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"如何使用git1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）123456//配置用户名git config --global user.name &quot;yourname&quot;//配置邮箱git config --global user.email &quot;youremail&quot;//查看是否配置成功git config --list --global 2、初始化git仓库1git init 3、配置ssh公钥 生成公钥 1ssh-keygen -t rsa -C &quot;youremail&quot; //youremail是前面global配置的email 查看获取公钥 1cat ~/.ssh/id_rsa.pub 将获取到的公钥添加到gitee上面 查看公钥是否配置成功 1ssh -T git@gitee.com 远程仓库的添加和查看 12345//远程仓库添加git remote add origin +(远程仓库地址)//git remote add origin git@gitee.com:linux_4/drivers-imx6ull.git//查看远程仓库git remote 拉取远程分支 1git pull origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"git的一些常用操作","slug":"git的一些常用操作","date":"2022-08-26T13:42:20.000Z","updated":"2022-08-30T12:16:49.876Z","comments":true,"path":"2022/08/26/git的一些常用操作/","link":"","permalink":"http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"git常用命令1、单个文件加入缓存区12git add +需要加入缓存的文件git add . //将所有文件加入跟踪 2、撤销add添加缓存命令12git reset + 想要撤销的文件git reset . //撤销add 的所有文件 3、将缓存区里面的内容提交&#x2F;修改1234//提交git commit -m &quot;需要添加的注释&quot;//修改commit提交的信息git commit --amend + 修改commit提交的信息 4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支123456789101112//创建分支git branch + 创建分支名//查看分支git branch//切换分支git checkout + 切换分支名//切换分支 如果没有分支就创建分支 git checkout -b +分支名//分支合并git merge + 分支名称 5、删除分支1234//删除时需要做检查git branch -d +分支名称 （要做检查的删除分支）//删除时不需要做任何检查git branch -D +分支名称 （不做任何检查的强制删除） 6、查看提交的历史信息123456//查看提交的详细历史信息git log git log --graph --oneline (以图形化界面查看)//获取每条日志的简要信息git log --pretty=oneline//查看本地的操作历史git reflog 7、配置SSH公钥123456//生成公钥ssh-keygen -t rsa -C &quot;youremail@example.com&quot;//获取公钥cat ~/.ssh/id_rsa.pub//查看公钥是否添加成功 ssh -T git@gitee.com 8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取12345678910111213//远程仓库的添加git remote add origin +(远程仓库地址)//远程仓库的查看 git remote//远程仓库的推送 git push origin master git pull --rebase origin master（如果推送不成功使用这个）（保持远端和本地数据同步） //与远端分支关系绑定 git push --set-upstream origin master:master （与远端关系绑定） （本地master） (远端master) //删除指定远程分支 git push origin --delete master git push origin :master //指定拉取分支 git pull origin master（如果pull出现冲突，可以版本回退和 封存修改，pull之后在还原） 9、查看本地分支与远程分支的对应关系1git branch -vv 10、git克隆1git clone + 克隆地址 11、git版本回退12//git 回退到你想要回退的版本号git reset --hard + 版本对应的id 12、强制拉取合并分支1git pull origin master --allow-unrelated-histories 13、删除远程仓库1git remote rm origin 14、创建远端仓库分支1git pull origin + 本地分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"markdown使用说明","slug":"markdown使用说明","date":"2022-08-25T15:17:46.000Z","updated":"2022-08-30T12:16:49.879Z","comments":true,"path":"2022/08/25/markdown使用说明/","link":"","permalink":"http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"markdown 使用说明功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G 标题的创建直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式、12345678910111213*强调文本* _强调文本_**加粗文本** __加粗文本__==标记文本==~~删除文本~~&gt; 引用文本H~2~O is是液体。2^10^ 运算结果是 1024. 强调文本 强调文本 加粗文本 加粗文本 &#x3D;&#x3D;标记文本&#x3D;&#x3D; 删除文本 引用文本 H2O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片1链接: [link](https://www.csdn.net/). 链接: link. 生成列表12345678910- 项目 - 项目 - 项目1. 项目12. 项目23. 项目3- [ ] 计划任务- [x] 完成任务 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建表格12345项目 | Value-------- | -----电脑 | $1600手机 | $12导管 | $1 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中，居左，居右123456使用`:---------:`居中使用`:----------`居左使用`----------:`居右| 第一列 | 第二列 | 第三列 ||:-----------:| :-------------:|:-------------|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | 使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 创建一个注脚123一个具有注脚的文本。[^2][^2]: 注脚的解释 一个具有注脚的文本。^2 流程图123456789这将产生一个流程图。:​```mermaidgraph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D​``` 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D","categories":[],"tags":[{"name":"md","slug":"md","permalink":"http://example.com/tags/md/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://example.com/tags/Qt/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"单片机","slug":"单片机","permalink":"http://example.com/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"},{"name":"MQTT","slug":"MQTT","permalink":"http://example.com/tags/MQTT/"},{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Linux设备驱动","slug":"Linux设备驱动","permalink":"http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"},{"name":"Linux驱动开发","slug":"Linux驱动开发","permalink":"http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"md","slug":"md","permalink":"http://example.com/tags/md/"}]}