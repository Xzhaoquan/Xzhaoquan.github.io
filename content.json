{"meta":{"title":"个人博客","subtitle":"Siwat","description":"","author":"Napat","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Linux应用编程-共享内存","slug":"Linux应用编程-共享内存","date":"2022-10-28T13:34:34.000Z","updated":"2022-10-29T13:02:40.172Z","comments":true,"path":"2022/10/28/Linux应用编程-共享内存/","link":"","permalink":"http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/","excerpt":"","text":"Linux应用开发-共享内存共享内存的概念共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。 1、共享内存由以下特点： 1234- 共享内存是进程间通信中效率最高的方式之一。- 共享内存是系统出于多个进程之间通讯的考虑，而预留的的一块内存区，因此共享内存是以传输数据为目的的。- 共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。- 共享内存无同步无互斥。 2、共享内存的优缺点： 1234- 优点：使用共享内存进行进程间的通信非常方便，而且函数的接口也简单，数据的共享使进程间的数据不用传送，而是直接访问内存，加快了程序的效率。任意进程之间都可以对共享内存做读写操作。- 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往往要借助其他的手段（如信号量、互斥量等）来进行进程间的同步工作。 共享内存API函数创建共享内存函数shmget() 函数的创建或获取一个共享内存对象，并返回共享内存标识符。 1234567891011121314151617int shmget(key_t key, size_t size, int shmflg);- key：标识共享内存的键值- size：共享内存大小，所有的内存分配操作都是以页为单位的，所以即使只申请只有一个字节的内存，内存也会分配整整一页。- shmflg：创建的共享内存的模式标志参数 * IPC_CREAT：如果内核中不存在关键字与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符。 * IPC_EXCL：如果内核中不存在键值与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存则报错。 * SHM_HUGETLB：使用“大页面”来分配共享内存，所谓的“大页面”指的是内核为了提高程序性能，对内存实行分页管理时，采用比默认尺寸（4KB）更大的分页，以减少缺页中断。 * SHM_NORESERVE：不在交换分区中为这块共享内存保留空间。返回值： shmget() 函数的返回值是共享内存的 ID。创建失败返回-1。错误代码：- EACCES：指定的消息队列已存在，但调用进程没有权限访问它- EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL 标志- EINVAL：创建共享内存时参数 size 小于 SHMMIN 或大于 SHMMAX。- ENFILE：已达到系统范围内打开文件总数的限制。- ENOENT：给定的 key 不存在任何共享内存，并且未指定 IPC_CREAT。- ENOMEM：内存不足，无法为共享内存分配内存。- EACCES：没有权限。 内存映射函数shmat() 映射函数 ，共享内存区对象映射到调用进程的地址空间 。 12345678910111213141516void *shmat(int shmid, const void *shmaddr, int shmflg);- shmid：共享内存 ID，通常是由 shmget() 函数返回的。- shmaddr：如果不为 NULL，则系统会根据 shmaddr 来选择一个合适的内存区域，如果为NULL，则系统会自动选择一个合适的虚拟内存空间地址去映射共享内存。- shmflg：操作共享内存的方式： * 0：可读可写 * SHM_RDONLY：以只读方式映射共享内存。 * SHM_REMAP：重新映射，此时 shmaddr 不能为 NULL。 * NULLSHM：自动选择比 shmaddr 小的最大页对齐地址。shmat() 函数调用成功后返回共享内存的起始地址。注意：- 共享内存只能以只读或者可读写方式映射，无法以只写方式映射。- shmat() 第二个参数 shmaddr 一般都设为 NULL，让系统自动找寻合适的地址。但当其确实不为空时，那么要求 SHM_RND 在 shmflg 必须被设置，这样的话系统将会选择比 shmaddr小而又最大的页对齐地址（即为 SHMLBA 的整数倍）作为共享内存区域的起始地址。如果没有设置 SHM_RND，那么 shmaddr 必须是严格的页对齐地址。 解除内存映射函数shmdt() 函数是用来解除进程与共享内存之间的映射的，在解除映射后，该进程不能再访问这个共享内存 。 1234int shmdt(const void *shmaddr);- shmaddr：映射的共享内存的起始地址。注意：该函数并不删除所指定的共享内存区，而只是将先前用 shmat() 函数映射好的共享内存脱离当前进程，共享内存还是存在于物理内存中。 获取或设置属性函数shmctl() 用于获取或者设置共享内存的相关属性。 123456789101112int shmctl(int shmid, int cmd, struct shmid_ds *buf);- shmid：共享内存标识符。- cmd：函数功能的控制命令，其取值如下： * IPC_STAT：获取属性信息，放置到 buf 中。 * IPC_SET：设置属性信息为 buf 指向的内容。 * IPC_RMID：删除这该共享内存。 * IPC_INFO：获得关于共享内存的系统限制值信息。 * SHM_INFO：获得系统为共享内存消耗的资源信息。 * SHM_STAT：与 IPC_STAT 具有相同的功能，但 shmid 为该 SHM 在内核中记录所有SHM 信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有 SHM 的相关信息。 * SHM_LOCK：禁止系统将该 SHM 交换至 swap 分区。 * SHM_UNLOCK：允许系统将该 SHM 交换至 swap 分。- 共享内存属性信息结构体指针（属性缓冲区）一般设为NULL","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-IPC信号量","slug":"Linux应用编程-IPC信号量","date":"2022-10-28T12:30:16.000Z","updated":"2022-10-29T13:02:31.807Z","comments":true,"path":"2022/10/28/Linux应用编程-IPC信号量/","link":"","permalink":"http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-IPC%E4%BF%A1%E5%8F%B7%E9%87%8F/","excerpt":"","text":"Linux应用编程-信号量信号量的工作原理信号量的PV操作信号量只能进行两种操作：等待和发送信号，即 P 操作和 V 操作，锁行为就是 P 操作，解锁就是 V 操作，可以直接理解为 P 操作是申请资源， V 操作是释放资源。 ipcs -l 查看ipc信息 信号量的P操作： 123P 操作：如果有可用的资源（信号量值大于 0），则占用一个资源（给信号量值减去一，进入临界区代码） ; 如果没有可用的资源（信号量值等于 0），则阻塞，直到系统将资源分配给该进程（进入等待队列，一直等到资源轮到该进程）。 信号量的V操作： 12V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞的进程。如果没有进程等待它，则释放一个资源（给信号量值加一）。 在信号量进行 PV 操作时都为原子操作（因为它需要保护临界资源）。 原子操作：单指令的操作称为原子的，单条指令的执行是不会被打断的 IPC信号量函数创建或获取一个信号量semget 函数的功能是创建或者获取一个已经创建的信号量，如果成功则返回对应的信号量标识符，失败则返回-1。 123456789101112int semget(key_t key, int nsems, int semflg);- key：参数 key 用来标识系统内的信号量可以使用ftok函数创建或者是类似（key_t）123- nsems：参数用于在创建信号量的时候，表示可用的信号量数目。- semflg：参数用来指定标志位 * PC_CREAT：IPC_CREAT 标志创建新的信号量，即使该信号量已经存在（具有同一个键值的信号量已在系统中存在），也不会出错。 * IPC_EXCL：同时使用 IPC_EXCL 标志可以创建一个新的唯一的信号量，此时如果该信号量已经存在，该函数会返回出错。 * mode：创建文件模式 0666 创建信号量时，还受到以下系统信息的影响:• SEMMNI：系统中信号量总数的最大值。• SEMMSL：每个信号量中信号量元素个数的最大值。• SEMMNS：系统中所有信号量中的信号量元素总数的最大值。 信号量PV操作信号量的PV操作semop() 函数对信号量进行 PV 操作 。 12345678910111213141516171819int semop(int semid, struct sembuf *sops, size_t nsops);- semid： System V 信号量的标识符，用来标识一个信号量- sops：指向一个 struct sembuf 结构体数组的指针，该数组是一个信号量操作数组 struct sembuf &#123; unsigned short int sem_num; /* 信号量的序号从 0 ~ nsems-1 */ short int sem_op; /* 对信号量的操作， &gt;0, 0, &lt;0 */ short int sem_flg; /* 操作标识： 0， IPC_WAIT, SEM_UNDO */ &#125;; * set_num：用于标识信号量中的第几个信号量， 0 表示第 1 个， 1 表示第 2 个， nsems -1表示最后一个。 * sem_op：sem_op 标识对信号量的所进行的操作类型 ~ sem_op &gt; 0 表示进程未使用或者使用完毕交回资源，表示信号量V(释放操作)，sem_op 的值加到该信号量的信号量当前值 semval ~ sem_op &lt; 0 表示进程需要使用资源，表示信号量P操作（获取资源），当信号量当前值 semval 大于或者等于 -sem_op 时， semval 减掉 sem_op 的绝对值，为该进程分配对应数目的资源。 ~ sem_op = 0 表示进程要阻塞等待，直至信号量当前值 semval 变为 0 * sem_flg，信号量操作的属性标志 ~ IPC_NOWAIT 使对信号量的操作是非阻塞的，即指定了该标志，调用进程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将 errno 设置为 EAGAIN。 ~ SEM_UNDO 维护进程对信号量的调整值，进程退出的时候会自动还原它对信号量的操作 ~ 0 表示正常操作- nsops：表示上面 sops 数组的数量，如只有一个 sops 数组， nsops 就设置为 1 semctl属性函数semctl 函数主要是对信号量集的一系列控制操作，根据操作命令 cmd 的不同，执行不同的操作，第四个参数是可选的。 12345678910111213141516171819202122int semctl(int semid, int semnum, int cmd, ...);- semid： System V 信号量的标识符；- semnum：表示信号量集中的第 semnum 个信号量。它的取值范围： 0 ~ nsems-1 。- cmd：操作命令，主要有以下命令： * IPC_STAT：获取此信号量集合的 semid_ds 结构，存放在第四个参数的 buf 中。 * IPC_SET：通过第四个参数的 buf 来设定信号量集相关联的 semid_ds 中信号量集合权限为 sem_perm 中的 uid， gid， mode。 * IPC_RMID：从系统中删除该信号量集合。 * GETVAL：返回第 semnum 个信号量的值。 * SETVAL：设置第 semnum 个信号量的值，该值由第四个参数中的 val 指定。 * GETPID：返回第 semnum 个信号量的 sempid，最后一个操作的 pid。 * GETNCNT：返回第 semnum 个信号量的 semncnt。等待 semval 变为大于当前值的线程数。 * GETZCNT：返回第 semnum 个信号量的 semzcnt。等待 semval 变为 0 的线程数。 * GETALL：去信号量集合中所有信号量的值，将结果存放到的 array 所指向的数组。 * SETALL：按 arg.array 所指向的数组中的值，设置集合中所有信号量的值。- 第四个参数是可选的：如果使用该参数，该参数的类型为 union semun，它是多个特定命令的联合体 union semun &#123; int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */ &#125;;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-消息队列","slug":"Linux应用编程-消息队列","date":"2022-10-27T13:54:25.000Z","updated":"2022-10-29T13:02:53.990Z","comments":true,"path":"2022/10/27/Linux应用编程-消息队列/","link":"","permalink":"http://example.com/2022/10/27/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"","text":"Linux应用编程-消息队列消息队列的基本概念消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。 消息队列特点： 12345- 在消息队列中，发送数据用 msgsnd()，接收数据用msgrcv()，消息队列对每个数据都有一个最大长度的限制。- 消息队列也可以独立于发送和接收进程而存在，在进程终止时，消息队列及其内容并不会被删除。- 消息队列提供有格式的字节流。- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级，接收程序可以通过消息类型有选择地接收数据- 消息队列可以实现消息的随机查询，消息不一定要以先进先出的顺序接收，也可以按消息的类型接收。 消息队列API函数 创建或打开消息队列API函数msgget() 123456789101112131415161718192021222324252627msgget() 函数创建的消息队列的数量会受到系统可支持的消息队列数量的限制；msgget() 函数的作用是创建或获取一个消息队列对象，并返回消息队列标识符。int msgget(key_t key, int msgflg);- key：消息队列的关键字值，多个进程可以通过它访问同一个消息队列。可通过ftok函数创建 • key_t ftok(const char *pathname, int proj_id); * path：合法路径 * proj_id：一个整数- msgflg：表示创建的消息队列的标志参数 • IPC_CREAT • IPC_EXCL • mode 这些参数是可以通过“｜”运算符联合起来的，因为它始终是 int 类型的参数。如 msgflag使用参数 IPC_CREAT | 0666 时表示，创建或返回已经存在的消息队列的标识符，且该消息队列的存取权限为0666。如果是 IPC_CREAT 为真表示：如果内核中不存在关键字与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符。而如果为 IPC_CREAT | IPC_EXCL 表示如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错。mode 指 IPC 对象存取权限，它使用 Linux 文件的数字权限表示方式，如 0600， 0666等。返回值： 成功返回队列表示符，失败返回 -1记录在error中的错误代码：– EACCES：指定的消息队列已存在，但调用进程没有权限访问它– EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL标志– ENOENT： key 指定的消息队列不存在同时 msgflg 中没有指定 IPC_CREAT 标志– ENOMEM：需要建立消息队列，但内存不足– ENOSPC：需要建立消息队列，但已达到系统的限制注意：当 key 被指定为 IPC_PRIVATE 时，系统会自动产生一个未用的 key 来对应一个新的消息队列对象，这个消息队列一般用于进程内部间的通信。 发送消息使用的API函数是 msgsnd() 123456789101112131415161718192021222324252627msgsnd() 函数把消息发送到已打开的消息队列末尾; int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);- msqid：消息队列标识符。- msgp：消息队列结构体，msgp 可以是任何类型的结构体，但第一个字段必须为 long 类型。 • struct s_msg&#123; long type; /* 必须大于 0, 消息类型 */ char mtext[１ ]; /* 消息正文，可以是其他任何类型 */ &#125; msgp;– msgsz：要发送消息的大小，不包含消息类型占用的 4 个字节，即 mtext 的长度。- msgflg：消息队列标志位参数 • 0：当消息队列满时， msgsnd() 函数将会阻塞，直到消息能写进消息队列； • IPC_NOWAIT：当消息队列已满的时候， msgsnd() 函数不等待立即返回； • IPC_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。返回值：成功返回0，失败返回-1记录在error中的错误代码：– EAGAIN：参数 msgflg 设为 IPC_NOWAIT，而消息队列已满。– EIDRM：标识符为 msqid 的消息队列已被删除。– EACCESS：无权限写入消息队列。– EFAULT：参数 msgp 指向无效的内存地址。– EINTR：队列已满而处于等待情况下被信号中断。– EINVAL：无效的参数 msqid、 msgsz 或参数消息类型 type 小于 0。msgsnd() 解除阻塞的条件有以下三个条件：- 消息队列中有容纳该消息的空间。- msqid 代表的消息队列被删除。- 调用 msgsnd 函数的进程被信号中断。 接收消息使用的API函数是 msgrcv() 123456789101112131415161718192021222324msgrcv() 函数是从标识符为 msqid 的消息队列读取消息并将消息存储到 msgp 中，读取后把此消息从消息队列中删除.ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int␣,msgflg);msqid：消息队列标识符。- msgp：存放消息的结构体，结构体类型要与 msgsnd() 函数发送的类型相同。- msgsz：要接收消息的大小，不包含消息类型占用的 4 个字节。- msgtyp 有多个可选的值：如果为 0 则表示接收第一个消息，如果大于 0 则表示接收类型等于 msgtyp 的第一个消息，而如果小于 0 则表示接收类型等于或者小于 msgtyp 绝对值的第一个消息。- msgflg 用于设置接收的处理方式，取值情况如下： • IPC_EXCEPT：与 msgtype 配合使用返回队列中第一个类型不为 msgtype 的消息 • IPC_NOWAIT：若在消息队列中并没有相应类型的消息可以接收，则函数立即返回，此时错误码为 ENOMSG • 0: 阻塞式接收消息，没有该类型的消息 msgrcv 函数一直阻塞等待 • IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃返回值： msgrcv() 函数如果接收消息成功则返回实际读取到的消息数据长度，否则返回-1错误代码：存放在error中– E2BIG：消息数据长度大于 msgsz 而 msgflag 没有设置 IPC_NOERROR– EIDRM：标识符为 msqid 的消息队列已被删除– EACCESS：无权限读取该消息队列– EFAULT：参数 msgp 指向无效的内存地址– ENOMSG：参数 msgflg 设为 IPC_NOWAIT，而消息队列中无消息可读– EINTR：等待读取队列内的消息情况下被信号中断msgrcv() 函数解除阻塞的条件也有三个：- 消息队列中有了满足条件的消息。- msqid 代表的消息队列被删除。- 调用 msgrcv() 函数的进程被信号中断。 控制消息队列使用的APIs函数是 msgctl() 1234567891011121314151617181920消息队列是可以被用户操作的，比如设置或者获取消息队列的相关属性，那么可以通过 msgctl()函数去处理它。int msgctl(int msqid, int cmd, struct msqid_ds *buf);- msqid：消息队列标识符。- cmd 用于设置使用什么操作命令 • IPC_SET 设置消息队列的属性，要设置的属性需先存储在结构体 msqid_ds 类型的 buf中，可设置的属性包括： msg_perm.uid、 msg_perm.gid、 msg_perm.mode 以及 msg_qbytes，储存在结构msqid_ds 中。 • IPC_RMID 立即删除该 MSG，并且唤醒所有阻塞在该 MSG 上的进程，同时忽略第三个参数。 • IPC_STAT 获取该 MSG 的信息，获取到的信息会储存在结构体 msqid_ds 类型的 buf 中。 • IPC_INFO 获得关于当前系统中 MSG 的限制值信息。 • MSG_INFO 获得关于当前系统中 MSG 的相关资源消耗信息。 • MSG_STAT 同 IPC_STAT，但 msgid 为该消息队列在内核中记录所有消息队列信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有消息队列的相关信息。- buf：相关信息结构体缓冲区。 • 返回值： • 成功： 0 • 出错： -1错误代码：- EACCESS：参数 cmd 为 IPC_STAT，确无权限读取该消息队列。- EFAULT：参数 buf 指向无效的内存地址。- EIDRM：标识符为 msqid 的消息队列已被删除。- EINVAL：无效的参数 cmd 或 msqid。- EPERM：参数 cmd 为 IPC_SET 或 IPC_RMID，却无足够的权限执行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-管道","slug":"Linux应用编程-管道","date":"2022-10-26T15:39:05.000Z","updated":"2022-10-29T13:02:45.336Z","comments":true,"path":"2022/10/26/Linux应用编程-管道/","link":"","permalink":"http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E7%AE%A1%E9%81%93/","excerpt":"","text":"Linux应用编程-管道管道分类匿名管道（父子之间进行通信）匿名管道：特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后 fork 产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的. 匿名管道没有名字，一般进程无法使用 open() 来获取他的描述符 ，所以匿名管道只能用于亲缘关系进程间通信 。 匿名管道有以下特征： 1234567• 没有名字，因此不能使用 open() 函数打开，但可以使用 close() 函数关闭。• 只提供单向通信（半双工），也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。• 只能用于具有血缘关系的进程间通信，通常用于父子进程建通信。• 管道是基于字节流来通信的。• 依赖于文件系统，它的生命周期随进程的结束而结束。• 写入操作不具有原子性，因此只能用于一对一的简单通信情形。• 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read() 和 write() 等函数。但是它又不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中，因此不能使用 lseek() 来定位。 pipe函数（所有进程间通信）pipe() 函数用于创建一个匿名管道，一个可用于进程间通信的单向数据通道。 123int pipe(int pipefd[2]);pipefd[0] 指管道的读取端， pipefd[1]指向管道的写端pipe函数返回 0 表示创建匿名管道成功 返回 -1 创建失败 创建匿名管道需要一下步骤： 123456• 父进程调用 pipe() 函数创建匿名管道，得到两个文件描述符 pipefd[0]、 pipefd[1]，分别指向管道的读取端和写入端。• 父进程调用 fork() 函数启动（创建）一个子进程，那么子进程将从父进程中继承这两个文件描述符 pipefd[0]、 pipefd[1]，它们指向同一匿名管道的读取端与写入端。• 由于匿名管道是利用环形队列实现的，数据将从写入端流入管道，从读取端流出，这样子就实现了进程间通信，但是这个匿名管道此时有两个读取端与两个写入端，因此需要进行接下来的操作。• 如果想要从父进程将数据传递给子进程，则父进程需要关闭读取端，子进程关闭写入端，如图数据从父进程流向子进程 所示。• 如果想要从子进程将数据传递给父进程，则父进程需要关闭写入端，子进程关闭读取端，如图数据从子进程流向父进程 所示。• 当不需要管道的时候，就在进程中将未关闭的一端关闭即可。 命名管道命名管道： 命名管道可以在多个无关的进程中交换数据（通信） . 命名管道一下特征： 123456• 有名字，存储于普通文件系统之中。• 任何具有相应权限的进程都可以使用 open() 来获取命名管道的文件描述符。• 跟普通文件一样：使用统一的 read()/write() 来读写。• 跟普通文件不同：不能使用 lseek() 来定位，原因是数据存储于内存中。• 具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。• 遵循先进先出（First In First Out）原则，最先被写入 FIFO 的数据，最先被读出来。 mkfifo函数： 1234567891011121314151617181920212223242526int mkfifo(const char * pathname,mode_t mode);- pathname 需要创建的FIFO文件名- mode mode模式及权限参数说明 • O_WRONLY：写管道。 • O_RDONLY：读管道。 • O_RDWR：读写管道。 • O_NONBLOCK：非阻塞。 • O_CREAT：如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。 • O_EXCL：如果使用 O_CREAT 时文件存在，那么可返回错误消息。这一参数可测试文件是否存在。返回值说明如下： • 0：成功 • EACCESS：参数 filename 所指定的目录路径无可执行的权限。 • EEXIST：参数 filename 所指定的文件已存在。 • ENAMETOOLONG：参数 filename 的路径名称太长。 • ENOENT：参数 filename 包含的目录不存在。 • ENOSPC：文件系统的剩余空间不足。 • ENOTDIR：参数 filename 路径中的目录存在但却非真正的目录。 • EROFS：参数 filename 指定的文件存在于只读文件系统内。mkfifo() 会根据参数 pathname 建立特殊的 FIFO 文件，而参数 mode 为该文件的模式与权限。对FIFO进行读操作：-阻塞类型的管道 管道内有数据就读取，没有数据就阻塞在那里-非阻塞类型的管道 不论 FIFO 内是否有数据，读进程都会立即执行读操作，管道内没有数据返回0对FIFO进行写操作：-阻塞类型的管道 写操作将一直阻塞到数据可以被写入。-非阻塞类型的管道 不能写入全部数据，则写操作进行部分写入或者调用失败。 access函数 12345678检查调用进程是否可以对指定的文件执行某种操作。int access(const char* pathname, int mode);- pathname 是文件的路径名+文件名- mode：指定access的作用，取值如下 • F_OK 值为0，判断文件是否存在 • X_OK 值为1，判断对文件是可执行权限 • W_OK 值为2，判断对文件是否有写权限 • R_OK 值为4，判断对文件是否有读权限","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-信号","slug":"Linux应用编程-信号","date":"2022-10-26T12:54:06.000Z","updated":"2022-10-29T13:03:00.149Z","comments":true,"path":"2022/10/26/Linux应用编程-信号/","link":"","permalink":"http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/","excerpt":"","text":"Linux应用编程-信号Linux系统支持的信号1234567891011121314151617181920212223使用kill -l查看信号信号分类：- 信号值为1-31的信号属于非实时信号（不可靠信号）（不支持排队处理）- 信号值为34-64的信号为实时信号 （可靠信号）（支持排队处理）以下是常用的一些信号：SIGHUP 1 关闭终端 终止 SIGINT 2 ctrl+c 终止 SIGQUIT 3 ctrl+\\ 终止+转储 SIGABRT 6 abort() 停止+转储 SIGPE 8 算术错误 终止 SIGKILL 9 kill -9 pid 终止，不可捕获/忽略 SIGUSR1 10 自定义 忽略 SIGSEGV 11 段错误 终止+转储 SIGUSR2 12 自定义 忽略 SIGALRM 14 alarm() 终止 SIGTERM 15 kill pid 终止 SIGCHLD 17 (子)状态变化 忽略 SIGTOP 19 ctrl+z 暂停，不可忽略/捕获使用kill或者是pkill可以杀死进程• kill + pid 或者 kill + -9 + pid• pkill + 需要杀死的进程名称 信号处理信号的处理方式（实时信号 非实时信号） 123- 忽略信号- 捕捉信号- 让信号默认动作起作用 信号API函数捕获信号API函数： signal函数 12345678910//signal函数typedef void (*sighandler_t)(int); //信号处理函数sighandler_t signal(int signum, sighandler_t handler); //signal 捕获函数- signum 指定捕获的信号- handler 用户处理信号的方式 • SIG_IGN 忽略该信号 • SIG_DFL 采用系统默认方式处理信号 • 使用信号处理函数void sighandler_t(int);返回值：成功 上一次设置的handler 失败SIG_ERR sigaction函数 123456789101112131415161718192021//sigaction函数struct sigaction &#123; void (*sa_handler)(int); 是捕获信号后的处理函数 void (*sa_sigaction)(int, siginfo_t *, void *); 是扩展信号处理函数 sigset_t sa_mask; 是信号掩码 它指定了在执行信号处理函数期间阻塞的信号的掩码，被设置 在该掩码中的信号，在进程响应信号期间被临时阻塞。除非使用 SA_NODEFER 标志 否则即使是当前正在处理的响应的信号再次到来的时候也会被阻塞。 int sa_flags; 系列用于修改信号处理过程行为的标志 void (*sa_restorer)(void);&#125;;sa_flags：- SA_NOCLDSTOP 如果 signum 是 SIGCHLD，则在子进程停止或恢复时，不会传信号给调用 sigaction() 函数的进程。- SA_NOCLDWAIT 它表示父进程在它的子进程终止时不会收到 SIGCHLD 信号，这时子进程终止则不会成为僵尸进程。- SA_NODEFER 不要阻止从其自身的信号处理程序中接收信号，使进程对信号的屏蔽无效，即在信号处理函数执行期间仍能接收这个信号- SA_RESETHAND 信号处理之后重新设置为默认的处理方式。- SA_SIGINFO 指示使用 sa_sigaction 成员而不是使用 sa_handler 成员作为信号处理函数int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);- signum :指定捕获的信号- act :struct sigaction类型的结构体- oldact :返回原有的信号处理参数，一般设置为 NULL 即可。 发送信号API函数： kill函数 123456789kill函数向包括它本身在内的其他进程发送一个信号int kill(pid_t pid,int sig);- pid :pid取值 • pid &gt; 1：将信号 sig 发送到进程 ID 值为 pid 指定的进程。 • pid = 0：信号被发送到所有和当前进程在同一个进程组的进程。 • pid = -1：将 sig 发送到系统中所有的进程，但进程 1（init）除外。 • pid &lt; -1：将信号 sig 发送给进程组号为-pid （pid 绝对值）的每一个进程。- sig :发送的信号值-函数返回值：0 成功 1失败 raise函数 1234raise() 函数只是进程向自身发送信号的，而没有向其他进程发送信号.给当前进程发送指定信号（自己给自己发信号）kill(getpid(),sig) 等同于 raise(sig)int raise(int sig);函数只有一个参数 sig，它代表着发送的信号值，如果发送成功则返回 0，发送失败则返回-1 alarm函数 123alarm() 也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间 seconds 到时，它就向进程发送 SIGALRM 信号。unsigned int alarm(unsigned int seconds);如果在 seconds 秒内再次调用了 alarm() 函数设置了新的闹钟，则新的设置将覆盖前面的设置，即之前设置的秒数被新的闹钟时间取代。它的返回值是之前闹钟的剩余秒数，如果之前未设闹钟则返回 0。 信号集处理函数 屏蔽信号集：屏蔽某些信号 12- 手动去调用信号集函数- 某些场景系统自动取设置信号集 未处理信号集：如果信号集被屏蔽，则记录在未处理信号集中，直到屏蔽信号集解除对信号的屏蔽才会去处理 12- 非实时信号（1-31）：不排队，只留一个（不管来多少信号，只保留最近的一个信号，其他信号全部丢掉）- 实时信号（34-64）：排队，保留全部信号 信号集相关API 1234567891011121314int sigemptyset(sigset_t *set); //将信号集合初始化为0函数 不屏蔽信号int sigfillset(sigset_t *set); //将信号集合初始化为1函数 屏蔽信号int sigaddset(sigset_t *set); //将信号集合某一位设置为1int sigdelset(sigset_t *set); //将信号集合某一位设置为0int sigismember(const sigset_t *set, int signum); //判断某信号是否在屏蔽信号集里面//该函数可以根据参数指定的方法修改进程的信号屏蔽字//将屏蔽信号赋值给屏蔽信号集int sigprocmask(int how, const old_kernel_sigset_t *set,old_kernel_sigset_t *oldset);- how： • SIG_BLOCK:屏蔽某个信号，添加的信号屏蔽字不覆盖之前的，这是一个并集的关系（屏蔽集 |set ） • SIG_UNBLOCK:希望解除BLOCK的信号集合。解除信号集的屏蔽（屏蔽集 &amp;~ set） • SIG_SETMASK:该进程的信号屏蔽是set指向的值。（直接等于我们设置的信号集合）- set：需要传入的屏蔽信号集- oldset：保存旧的屏蔽集的值，NULL表示不保存","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"Linux应用编程-进程","slug":"Linux应用编程-进程","date":"2022-10-25T14:48:47.000Z","updated":"2022-10-29T13:02:49.402Z","comments":true,"path":"2022/10/25/Linux应用编程-进程/","link":"","permalink":"http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/","excerpt":"","text":"Linux应用编程-进程fork()进程函数：fork()进程函数用于从一个已存在的进程中去启动一个新进程，新进程成为子进程，原来的进程称为父进程。fork()函数的本质是直接将父进程的内容复制一份，但是子进程与父进程也有不一样的地方。 子进程与父进程相同的内容： 进程的地址空间 进程上下文，代码段 进程的堆栈空间，和内存信息 进程的环境变量，标准的IO缓冲区 打开的文件描述符，信号响应函数，当前的工作路劲 子进程独有的内容： 子进程的进程号PID，PID是进程的唯一的标识符 记录锁，父进程对某文件加锁，子进程不会继承这把锁 挂起信号，父进程的响应但未处理的信号，子进程不会继承 fork函数 12345678pid_t fork(void);fork函数启动成功：父进程会返回子进程的pid,子进程返回0，启动失败：返回-1pid_t getpid(void);函数会返回当前进程pidpid_t getppid(void);函数会返回当前进程的父进程pid exec系列进程替换函数exec系列函数用于替换进程的执行程序，它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换 exec系列函数介绍： 1234567891011121314151617181920int execl(const char *path, const char *arg, ...)int execlp(const char *file, const char *arg, ...)int execle(const char *path, const char *arg, ..., char *const envp[])int execv(const char *path, char *const argv[])int execvp(const char *file, char *const argv[])int execve(const char *path, char *const argv[], char *const envp[])这些函数可以分为两大类execl、execlp和execle传递给子程序的参数个数是可变的。 execv、 execvp 和 execve 通过数组去装载子程序的参数，无论那种形式，参数都以一个空指针 NULL 结束.l----list 列表v----vector 数组参数介绍：const char *path:该参数需要输入文件路径，例如：&quot;/bin/ls&quot; &quot;/bin/pwd&quot;const char *file:该参数需要输入需要执行的应用程序名字，例如：&quot;ls&quot; &quot;pwd&quot;const char *arg:该参数需要输入对应字符，例如：&quot;ls&quot;,&quot;-al&quot;,NULL &quot;pwd&quot;,NULLconst char *agrv[]:该参数需要输入对应数组指针：例如：char *argv[]=&#123;&quot;pwd&quot;,NULL&#125;;！！注意：exec 系列函数是直接将当前进程给替换掉的，当调用 exec 系列函数后，当前进程将不会再继续执行， execl函数： 123456int execl(const char *path, const char *arg, ... )path:指定文件路径arg：执行文件所传递的参数 arg[0],arg[1]...arg[n],最后一个参数必须是NULL做结束标志该函数一般不会返回，除非遇到错误会返回-1 execv函数： 12345int execv(const char *path, char *const argv[])path:指定文件路径argv：执行文件所传递的参数是一个数组指针,最后一个参数必须是NULL做结束标志该函数一般不会返回，除非遇到错误会返回-1 进程的生老病死 进程终止 正常终止 123-main 函数返回-调用_exit()函数终止-调用exit()函数终止 异常终止 12-调用abort()函数异常终止-又系统信号终止 exit函数和_exit()函数： 123void _exit(int status);void exit(int status);传入一个status保存进程终止时的状态码 exit()函数和_exit()函数的异同： 12345exit() 和 _exit() 函数都是用来终止进程的，当程序执行到 exit() 或 _exit() 函数时，进程会无条件地停止剩下的所有操作，清除包括 PCB 在内的各种数据结构，并终止当前进程的运行。_exit() 函数:直接通过系统调用使进程终止运行,清除这个进程使用的内存空间，并销毁它在内核中的各种数据结构.exit() 函数是_exit()函数包装来的。在执行_exit()函数之前，需要清除&quot;IO缓冲区&quot;，有效的保存数据的完整性。清清除&quot;IO缓冲区&quot;是检查文件的打开情况，把文件缓冲区中的内容写回文件 等待进程当一个进程调用了exit()函数之后，该进程并不会直接消失，而是会变成僵尸进程。需要等待其父进程去回收僵尸进程，需要调用waitpid()或者wait()函数去回收僵尸进程并且，释放僵尸进程占有的内存空间，和了解进程终止的状态信息。调用wait函数会阻塞父进程。 wait函数和waitpid函数： 12345678910111213141516171819202122232425262728293031323334//wait函数pid_t wait(int *wstatus);调用wait函数之后 调用成功：返回子进程pid，和进程退出状态失败:返回-1pid_t waitpid(pid_t pid, int *wstatus, int options);pid: 欲等待的子进程的识别码。 • pid&lt;-1 等待进程组号为pid绝对值的任何子进程。 • pid&gt;0 等待进程号为pid的子进程。 • pid=-1 等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。 • pid=0 等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。wstatus：返回的状态值options：控制waitpid()函数的行为，如果不想使用这些选项，则可以把这个参数设为0。 • WNOHANG 如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这个函数上等待；如果结束了，则返回该子进程的进程号。 • WUNTRACED 如果子进程进入暂停状态，则马上返回。 调用wait函数之后 调用成功：返回子进程pid，和进程退出状态失败:返回-1//waitpid函数如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。waitpid(-1,&amp;status,0) = wait(&amp;status)//wait和waitpid函数调用之后返回 wstatus 的值• WIFEXITED(status) ：如果子进程正常结束，返回一个非零值• WEXITSTATUS(status)：如果 WIFEXITED 非零，返回子进程退出码• WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值• WTERMSIG(status) ：如果 WIFSIGNALED 非零，返回信号代码• WIFSTOPPED(status)：如果子进程被暂停，返回一个非零值• WSTOPSIG(status)：如果 WIFSTOPPED 非零，返回一个信号代码 进程组，会话，终端 进程组 123456789进程组：• 对相同的类型的进程进行管理进程组的诞生：• 在shell里面直接执行一个应用程序，对于大部分应用程序，自己就是进程组的首进程。进程组只有一个进程• 如果进程调用了fork函数，那么父子进程同属一个进程组，父进程为首进程• shell中通过管道执行连接起来的应用程序，两个程序同属一个进程组，第一个程序为进程组的首进程进程组id:pgid,由首进程pid决定 pgid：进程组所在的id号 会话（一般关联着一个终端） 123456会话：管理前后台进程组会话的诞生：• 调用调用setsid函数，新建一个会话，应用程序作为会话的第一个进程，称为会话首进程• 用户在终端正确登录之后，启动shell时linux系统会创建一个新的会话，shell进程作为会话首进程。会话id:sidsid:会话首进程id 前台进程组 123前台进程组：shell进程启动时，默认是前台进程组的首进程前台进程组的首进程会占用绘画所关联的终端来运行，shell启动其他应用程序时，其他程序成为首进程 后台进程组 1234567后台进程组的程序是不会占用终端的。在shell终端运行程序时，在后面加上&amp;的符号，可以指定程序运行在后台进程组里面。例：sleep 10 &amp;ctrl+z：会使进程进入后台，同时停止执行。返回终端jobs:查看有哪些后台进程组，和jobs idfg +job id可以把后台进程组切换为前台进程组 终端 12345678910物理终端• 串口终端• lcd终端伪终端（不依赖物理设备）• SSH远程连接产生的终端• 桌面系统产生的终端虚拟终端• linux内核自带的 ctrl+alt+f0~f6来打开不同的终端终端被关闭之后，会话中的所有进程都会被关掉 守护进程守护进程不受终端影响的，终端退出，而也可以继续在后台运行， 写守护进程步骤： 123456789101112• 创建一个子进程，父进程直接退出， - 使用fork()函数创建,• 创建一个新的会话 - 子进程使用setsid()函数创建一个新的会话，没有关联任何终端• 改变守护进程的当前工作目录，改为&quot;/&quot;。因为子进程会继承父进程的工作目录的。所以需要改变工作目录。 - 子进程使用chdir()函数实现• 重设文件权限的掩码（umask可以查看文件权限掩码 0022 -- 只写） 新建文件的权限默认使0666,需要与掩码进行与非(&amp;~)的运算才是实际的文件权限 -子进程使用umask()函数实现 umask直接设置为0• 关闭不需要的文件描述符 - 子进程使用close()函数实现 - 0，1，2文件描述符，分别对应终端的标准输入，输出，出错。不需要与终端相关联所以需要关闭这些文件描述符。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"}]},{"title":"函数返回二维数组地址","slug":"函数返回二维数组地址","date":"2022-10-22T13:37:41.000Z","updated":"2022-10-22T13:38:51.309Z","comments":true,"path":"2022/10/22/函数返回二维数组地址/","link":"","permalink":"http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/","excerpt":"","text":"返回二维数组地址int *(*p(int))[3]说明：1234//从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,//说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,//说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.//所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数. 返回二维数组地址方法11234567891011121314151617181920int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;int (*ptraar)[4];int (*vfunc(void))[4]&#123; return parr;&#125;int main()&#123; ptraar = vfunc(); printf(&quot;ptrarr %d\\r\\n&quot;,(*(*ptraar ) + 1)); //ptrarr[0][1] printf(&quot;ptrarr %d\\r\\n&quot;,ptrarr[0][1]); //ptrarr[0][1]&#125;//解析 ptraar = 二维数组首地址 (*ptraar ) = 二维数组元素首地址 (*(*ptraar ) = 一维数组元素首地址 (*(*ptraar ) + 1) = ptrarr[0][1] 返回二维数组地址方法21234567891011int prrs[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;void * func(void)&#123; return prrs;&#125;void *ins;ins = func();ptraar = (int (*)[4])ins;printf(&quot;ptrarr %d\\r\\n&quot;,*(*(ptraar + 1) + 2 )); 返回二维数组地址指针12345678910111213141516171819202122232425int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;int *ptesarr[3][4]=&#123;&#123;&amp;arrss[0],&amp;arrss[1],&amp;arrss[2],&amp;arrss[3]&#125;, &#123;&amp;arrss[4],&amp;arrss[5],&amp;arrss[6],&amp;arrss[7]&#125;, &#123;&amp;arrss[8],&amp;arrss[9],&amp;arrss[10],&amp;arrss[11]&#125;&#125;; int *(*psst)[4];int *(*functions(void))[4]&#123; return ptesarr;&#125;int main()&#123; psst = functions(); printf(&quot;psst ptr = %d\\r\\n&quot;,*(*(*(psst+0)) + 3));//*psst[0][3] printf(&quot;psst ptr arr= %d\\r\\n&quot;,*(psst[1][3]));//*psst[1][3]&#125;// 解析 *psst[2][3] = *(psst[2][3]) *(pstt[2][3]) = *((*(pstt+2)+3)) pstt二维数组首地址 *(pstt) = [二维数组元素首地址] *(*(pstt)) = [一维数组元素首地址] *(*(*(pstt + 2)) + 3) = [二维数组首地址 + 2][一维数组元素首地址 + 3]","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"单链表头插法","slug":"单链表头插法","date":"2022-10-22T13:31:29.000Z","updated":"2022-10-22T13:34:58.569Z","comments":true,"path":"2022/10/22/单链表头插法/","link":"","permalink":"http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/","excerpt":"","text":"单链表头插法单链表数据结构定义12345678typedef struct timer&#123; int value; //数据 struct timer *next;//节点&#125;timer;//定义头指针head_handlestatic struct timer *head_handle; 链表初始化123456void timer_init(struct timer *handle,int value)&#123; memset(handle,0,sizeof(struct timer)); handle-&gt;buff = NULL; handle-&gt;value = value;&#125; 创建链表（头插法） 123456789101112131415161718192021int start_timer(struct timer *handle)&#123; struct timer *target = head_handle; while(target) &#123; if(target == handle) //判断新创建的节点是否和以前创建的是否相同 &#123; return -1; &#125; target = target-&gt;next; &#125; handle-&gt;next = head_handle; head_handle = handle; return 0;&#125;//new_node1节点创建之前头节点 head_handle == NULL//new_node1节点创建之后头节点 head_handle == new_node1//当前链表链接顺序：new_node1-&gt;head_handle//new_node2节点创建之后头节点 head_handle == new_node2//当前链表链接顺序：new_node2-&gt;new_node1-&gt;head_handle 删除链表 1234567891011121314151617void timer_stop(struct timer *handle)&#123; struct timer **curr; for(curr = &amp;head_handle;*curr;) &#123; struct timer *entry = *curr; if(entry == handle) &#123; *curr = entry-&gt;next; return ; &#125; else &#123; curr = &amp;entry-&gt;next; &#125; &#125;&#125; 链表遍历12345678910void timer_traverse(void)&#123; struct timer *target; //根据链表头节点遍历整个链表 for(target = head_handle;target;target = target-&gt;next) &#123; printf(&quot;timer value : %d\\r\\n&quot;,target-&gt;value); &#125; printf(&quot;\\r\\n&quot;);&#125;","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"gitbash安装使用gcc和make","slug":"gitbash安装使用gcc和make","date":"2022-09-24T11:50:14.000Z","updated":"2022-09-24T12:03:46.403Z","comments":true,"path":"2022/09/24/gitbash安装使用gcc和make/","link":"","permalink":"http://example.com/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/","excerpt":"","text":"Git安装gcc编译器和make工具1、gcc编译器和make工具下载http://www.equation.com/servlet/equation.cmd?fa=fortra 2、gcc和make的安装双击下载好的exe,一直点击继续，知道安装结束。 3、配置gcc的环境 找到Git的安装目录，在Git的安装目录下面找到Git\\etc\\profile.d\\env.sh配置文件 打开env.sh文件，添加export PATH&#x3D;”$HOME&#x2F;gcc&#x2F;bin:$PATH” 保存之后，双击env.sh就配置完成 如果添加之后不能保存env.sh文件，就设置权限","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"LED字符设备","slug":"LED字符设备","date":"2022-09-14T14:01:58.000Z","updated":"2022-10-29T13:03:15.681Z","comments":true,"path":"2022/09/14/LED字符设备/","link":"","permalink":"http://example.com/2022/09/14/LED%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","excerpt":"","text":"LED字符设备1、实现虚拟IO映射和读写 虚拟地址映射 12345678910111213使用ioremap函数进行虚拟地址映射函数原型：void __iomem *ioremap(resource_size_t res_cookie, size_t size);参数：res_cookie：实际的物理地址size：映射长度(一般4个字节)返回值： void __iomem*类型的指针，指向被映射的虚拟地址__iomem:主要是用于编译器的检查地址在内核空间的有效性example:#define CCM_CCGR1_BASE (0x020C406C)static void __iomem *IMX6ULL_CCM_CCGR1;IMX6ULL_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE,4); 虚拟地址映射的取消 1234567使用iounmap函数取消虚拟地址映射函数原型：void iounmap(volatile void __iomem *iomem_cookie);参数：iomem_cookie：指向虚拟地址的指针example：iounmap(IMX6ULL_CCM_CCGR1); 虚拟地址的读写 1234567891011121314151617//虚拟地址的读取 8 16 32static inline u8 ioread8(const volatile void __iomem *addr) //8位的读取static inline u16 ioread16(const volatile void __iomem *addr) //16位的读取static inline u32 ioread32(const volatile void __iomem *addr) //32位的读取参数：addr：void __iomem *类型的虚拟地址返回值：u32/u16/u8类型的数据//虚拟地址的写 8 16 32static inline void iowrite8(u8 value, volatile void __iomem *addr)//写入8位数据static inline void iowrite16(u8 value, volatile void __iomem *addr)//写入16位数据static inline void iowrite32(u32 value, volatile void __iomem *addr)//写入32位数据参数：value：写入一个u32/u16/u8类型的数据addr：void __iomem *类型的虚拟地址 2、实现驱动接口 file_operations 结构体的实现 1234567//实现file_operation结构体static struct file_operations led_chrdev_fops = &#123; .owner = THIS_MODULE, .open = led_open, .write = led_write, .release = led_release,&#125;; 操作接口函数的实现 1234//write release open函数的实现static int led_open(struct inode *inode, struct file *filp)static int led_release(struct inode *inode, struct file *filp)static ssize_t led_write(struct file *filp, const char __user *buf,size_t count, loff_t *ppos) 3、数据的拷贝 copy_from_user拷贝用户空间的数据 12345copy_from_user(void *to, const void __user *from, unsigned long n);参数：to：将数据拷贝到内核地址from：需要拷贝的用户空间的地址n：需要拷贝数据的长度 4、添加、删除LED字符设备 使用register_chrdev函数添加LED字符设备（用mknod 创建字符设备文件） 1234567891011121314151617//字符设备注册添加static inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops)参数：major：主设备号name：设备名字fops：file_operations的指针指向操作接口使用mknod /dev/led c 200 0 //创建一个字符设备/dev/led 主设备号为200 次设备号为0//字符设备注销static inline void unregister_chrdev(unsigned int major, const char *name)参数：major：主设备号name：设备名字//使用register_chrdev函数注册添加字符设备 注册成功会占用1个主设备号和256多个次设备号 使用其他方式添加字符设备 12345678910//动态申请主设备号alloc_chrdev_region();//创建class类class_create(); //cdev设备结构体与file_operations相关联cdev_init();//设备注册-添加设备到cdev_map哈希表中ret = cdev_add();//创建字符设备文件device_create(); 使用其他方式删除字符设备 12345678//删除字符设备文件device_destroy();//删除注册的字符设备（注销设备）cdev_del();//注销设备号unregister_chrdev_region();//删除设备逻辑类class_destroy();","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"字符设备","slug":"字符设备","date":"2022-09-14T10:36:18.000Z","updated":"2022-10-29T13:03:22.990Z","comments":true,"path":"2022/09/14/字符设备/","link":"","permalink":"http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","excerpt":"","text":"字符设备驱动设备驱动框架 1、设备号的申请和注销 设备号的定义 1static struct cdev chrdev; 使用register_chrdev_region函数静态申请设备号 1234567register_chrdev_region函数用于静态地为一个字符设备申请一个或多个设备编号。一般用于指定手动分配主设备号。函数原型：int register_chrdev_region(dev_t from, unsigned count, const char *name)参数：from：需要注册的设备号，不能与被注册的设备号相同count：需要申请的设备号个数name：申请的设备号名称 在 &quot;cat /proc/devices&quot;下可查看到设备名称和设备号返回值：0成功 其他失败 调用alloc_chrdev_region函数动态的申请设备号 12345678调用alloc_chrdev_region函数，内核会自动分配给我们一个尚未使用的主设备号。函数原型：int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)参数：dev：指向dev_t类型数据的指针变量，用于存放分配到的设备编号的起始值；baseminor：次设备号的起始值，通常为0count：指定需要分配的设备编号个数name：设备名称返回值：返回0成功 注销申请的字符设备号 12345使用xxx_chrdev_region()函数申请的设备号可以使用unregister_chrdev_region()注销函数原型：void unregister_chrdev_region(dev_t from, unsigned count)参数：from：指定需要注销的字符设备的设备编号起始值count：指定需要注销的字符设备编号的个数，该值应与申请函数的count值相等 register_chrdev函数申请设备号 1234567891011register_chrdev函数用于分配设备号函数原型：static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)&#123; return __register_chrdev(major, 0, 256, name, fops);&#125;参数：major：用于指定要申请的字符设备的主设备号，major = 0 时，内核会自动分配一个未使用的主设备号。name：设备名称fops：用于操作该设备的函数接口指针返回值：主设备号 unregister_chrdev注销申请的字符设备号 123456789使用register函数申请的设备号，则应该使用unregister_chrdev函数进行注销。函数原型：static inline void unregister_chrdev(unsigned int major, const char *name)&#123;__unregister_chrdev(major, 0, 256, name);&#125;参数：major：指定需要释放的字符设备的主设备号name：执行需要释放的字符设备的名称 设备号宏 1234567#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))MINOR(dev)：用来获取该设备文件的次设备号MINOR(dev)：用来获取该设备文件的主设备号MKDEV(ma,mi)：将主设备号和次设备号一起转成dev_t类型的设备号 2、实现file_operations结构体和初始化cdev 实现file_operations结构体里面的函数 1234567891011static struct file_operations led_chrdev_fops = &#123; .owner = THIS_MODULE, .open = led_chrdev_open, .release = led_chrdev_release, .write = led_chrdev_write,&#125;;实现我们需要用的函数：static int led_chrdev_open(struct inode *inode, struct file *filp)；static int led_chrdev_release(struct inode *inode, struct file *filp)；static ssize_t led_chrdev_write(struct file *filp, const char __user * buf, size_t count, loff_t * ppos)； 初始化cdev 12345使用cdev_init函数将cdev和file_operations 相关联起来函数原型：void cdev_init(struct cdev *cdev, const struct file_operations *fops)参数：cdev：struct cdev类型的指针变量，指向需要关联的字符设备结构体；fops：file_operations类型的结构体指针变量，一般将实现操作该设备的结构体file_operations结构体作为实参。 3、设备注册和注销 设备注册 1234567cdev_add函数用于向内核的cdev_map散列表添加一个新的字符设备函数原型：int cdev_add(struct cdev *p, dev_t dev, unsigned count)参数：p：struct cdev类型的指针，用于指定需要添加的字符设备dev：dev_t类型变量，用于指定设备的起始编号count：指定注册多少个设备返回值：返回为0 添加成功 设备注销 1234cdev_del函数用于向内核的cdev_map散列表删除注册的字符设备函数原型：void cdev_del(struct cdev *p)参数：p：struct cdev类型的指针，用于指定需要删除的字符设备； 4、设备的逻辑类的创建和删除 动态创建设备的逻辑类 12345678910111213class_create()用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。此函数的执行效果就是在/sys/class/目录下创建一个新的文件夹。宏原型：#define class_create(owner, name) \\(&#123; \\ static struct lock_class_key __key; \\ __class_create(owner, name, &amp;__key); \\&#125;)参数：owner：一个struct module结构体类型的指针，一般赋值为THIS_MODULEname：代表即将创建的struct class变量的名字，用于给struct class的name字段赋值class_create(THISMODULE,&quot;chrdev&quot;); //在 /sys/class/目录下面创建一个chrdev文件 删除设备的逻辑类 12345函数class_destroy()用于删除设备的逻辑类即从Linux内核系统中删除设备的逻辑类。此函数执行的效果是删除函数__class_create()或宏class_create()在/sys/class/目录下创建的逻辑类对应的文件夹。函数原型：void class_destroy(struct class *cls);参数：cls：创建成功的class设备的逻辑类 5、设备节点的创建和销毁 代码设备节点的创建 12345678910111213141516device_create函数创建一个设备并将其注册到文件系统函数原型：struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)参数：class：指向这个设备应该注册到的struct类的指针parent：指向此新设备的父结构设备（如果有）的指针devt：要添加的char设备的开发drvdata：要添加到设备进行回调的数据fmt：输入设备名称返回值：成功返回 struct device 结构体指针, 错误时返回ERR_PTR().example:struct class *led_chrdev_class;led_chrdev_class = class_create(THIS_MODULE, &quot;led_chrdev&quot;); //在 /dev/目录下面创建led_chrdev的设备节点文件device_create(led_chrdev_class, NULL, cur_dev, NULL,DEV_NAME &quot;%d&quot;, i); 代码设备节点的销毁 123456789101112使用device_destroy删除使用device_create函数创建的设备函数原型：void device_destroy(struct class *class, dev_t devt)参数：class：指向注册此设备的struct类的指针；devt：以前注册的设备的开发example:static dev_t devno;//已分配的主设备号dev_t cur_dev;cur_dev = MKDEV(MAJOR(devno), MINOR(devno) + i); //将主设备和次设备转化成dev_t类型的设备号device_destroy(led_chrdev_class, cur_dev);//销毁设备节点class_destroy(led_chrdev_class); 注意：class_create 和 class_destroy是成对出现的不可只单独使用其中一个。 使用mknod命令创建节点 12345678910可以使用mknod命令创建设备节点。用法：mknod 设备名 设备类型 主设备号 次设备号设备类型：- b 创建（有缓冲的）区块特殊文件- c,u 创建(没有缓冲的)字符特殊文件- p 创建先进先出(FIFO)特殊文件example://创建一个字符设备/dev/led 主设备号为200 次设备号为0mknod /dev/led c 200 0 6、字符设备驱动流程 设备驱动流程 设备卸载流程 常用命令1234lsmod 显示已载入系统的模块modinfo+模块名字 查看模块详细信息ls /dev/ 查看设备节点cat /proc/devices 查看设备和设备号","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"内核模块","slug":"内核模块","date":"2022-09-10T14:04:20.000Z","updated":"2022-10-29T13:03:29.403Z","comments":true,"path":"2022/09/10/内核模块/","link":"","permalink":"http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"","text":"内核模块内核模块概念-现代内核派系1、现代内核派系-关键功能和服务功能均在内核空间提供（linux） 运行效率高 扩展性差 2、微内核-内核空间提供关键功能，服务功能在用户空间提供 运行效率低 扩展性较高 两者区别如下图： 内核模块实验环境搭建1、搭建开发板环境 开发板烧录Debain镜像-当前开发板内核版本：4.19.35-imx6 启动开发板，搭建nfs客户端，挂载共享文件夹 获取debain镜像内核源码-编译 2、获取内核源码-编译（4.19.35-imx6） 获取linux内核源码 1git clone https://gitee.com/Embedfire/ebf_linux_kernel_6ull_depth1 安装工具配置环境 1sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop 开始编译，构建内核 12./make_deb.sh (如果权限不足加上sudo)修改build_opts=&quot;$&#123;build_opts&#125; O=X&quot;,可以改变安装的路径，X=你想要存放的路径 获取编译的出来的内核文件的相关文件 12将路径下存放的当前的内核相关文件 拷贝到你的工程路径下面/home/kernel/bulid 内核模块所需头文件123#include &lt;linux/module.h&gt; //包含内核模块信声明的相关函数#include &lt;linux/init.h&gt; // 包含module_init module_exit 函数声明#include &lt;linux/kernel.h&gt; //包含内核提供的各种函数，例如printk内核模块打印函数 内核模块函数&#x2F;命令1、内核模块加载、卸载12内核加载命令：insmod内核卸载命令：rmmod 2、内核函数入口，出口 内核函数模块入口-加载模块式函数自动执行，进行初始化操作 内核函数模块出口-卸载模块是函数自动执行，进行清理工作 12内核模块入口函数： module_init();内核模块出口函数： module_exit(); 3、内核模块信息声明 MODULE_LICENSE：内核模块版权声明，模块接受软件许可协议 MODULE_AUTHOR：描述模块作者信息 MODULE_DESCRIPTION：对模块的简单介绍 MODULE_ALIAS：给模块设置一个别名 1234内核模块版权声明，模块接受软件许可协议 MODULE_LICENSE();描述模块作者信息 MODULE_AUTHOR();对模块的简单介绍 MODULE_DESCRIPTION();给模块设置一个别名 MODULE_ALIAS(); 4、内核模块打印函数 printk内核模块打印函数-需要指定打印等级 123456789101112131415161718//打印等级0-7#define KERN_EMERG &quot;&lt;0&gt;&quot; 通常是系统崩溃前的信息#define KERN_ALERT &quot;&lt;1&gt;&quot; 需要立即处理的消息#define KERN_CRIT &quot;&lt;2&gt;&quot; 严重情况#define KERN_ERR &quot;&lt;3&gt;&quot; 错误情况#define KERN_WARNING &quot;&lt;4&gt;&quot; 有问题的情况#define KERN_NOTICE &quot;&lt;5&gt;&quot; 注意信息#define KERN_INFO &quot;&lt;6&gt;&quot; 普通消息#define KERN_DEBUG &quot;&lt;7&gt;&quot; 调试信息打印内核所有打印信息：dmesg查看当前系统的printk打印等级：cat /proc/sys/kernel/printk下图的4417对应4 当前控制台日志级别4 默认消息日志级别1 最小的控制台级别7 默认控制台日志级别 5、模块参数 模块参数：根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性 模块参数函数：module_param 1234567891011121314module_param(name,type,perm);- name 参数名- type 参数类型- perm 读写权限数据类型对应type类型：int类型： int&lt;------------&gt; intchar类型: char&lt;-----------&gt; bytebool类型： bool&lt;-----------&gt; bool字符串类型: char*&lt;----------&gt; charpperm读写权限：- 不可以设置执行权限 如0777- 在sys/modules/模块名/paramters 目录下生成该参数对应的文件名 6、符号共享 内核模块可以共享导出的符号表 可以变量共享和函数共享 符号共享函数：EXPORT_SYMBOL 12EXPORT_SYMBOL(sym);sym:变量名或者是函数名 查看符号表 12cat /proc/kallsyms | grep xxxxxx:需要查看的模块名 7、模块加载 模块手动加载 121、模块加载时必须先加载相关依赖模块2、模块卸载时必须先卸载模块，在卸载依赖模块 模块自动加载 将所有内核模块统一放在 “&#x2F;lib&#x2F;modules&#x2F;内核版本”目录下 1cp *.ko /lib/modules/4.19.35-imx6 建立模块依赖关系 1depmod -a 查看模块依赖关系 1cat /lib/modules/4.19.35-imx6/modlue.dep 加载、卸载模块及其依赖关系 123加载模块及依赖： modprobe xxx下载模块及依赖： modprobe -r xxxxxx：需要操作的模块","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"}]},{"title":"使用hexo搭建个人博客","slug":"使用hexo搭建个人博客","date":"2022-09-08T16:21:19.000Z","updated":"2022-09-08T16:21:56.763Z","comments":true,"path":"2022/09/09/使用hexo搭建个人博客/","link":"","permalink":"http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用hexo搭建个人博客1、安装环境依赖 安装git（按照默认操作即可） 1如果点击鼠标右键 能够打开git bash 说明git 安装成功 安装node.js 123鼠标右键打开git bash查看node 是否安装成功node -v 安装hexo 12345安装hexo1、桌面新建一个文件夹 blog，git bash 进入文件夹2、设置淘宝镜像原（npm config set registry http://registry.npm.taobao.org）//可要可不要3、安装hexo npm install hexo-cli -g4、检测hexo是否安装完成 hexo -v 生成博客文件 生成博客文件 123打开githexo init blog(如果没有进入到blog文件夹)hexo init (如果进入到blog文件夹) 预览博客文件 12hexo s将生成的网址复制到网页执行，可以看到博客文件 部署博客到gitee平台 在gitee创建一个仓库，创建仓库名称使用gitee用户名。（如果不适用用户名，需要再仓库名后面加.gitee.io） 仓库创建成功后，复制HTTP 链接网址。 配置博客配置文件 _config.yml 1234deploy: type: &#x27;git&#x27; //选择git repo: https://gitee.com/yys_cn_ccs/zhaoqaun.git //gitee http 链接地址 branch: master //git 分支的配置 安装hexo部署工具 1npm install hexo-deployer-git --save 生成静态链接文件（public） 1hexo g 部署（需要输入gitee用户名字加密码） 1hexo d 开启gitee服务 打开gitee 点击右上角“服务”—-选择Gitee Pages 点击部署。 设置hexo主题1、去找到自己希望的 hexi主题，搜索主题名字。 2、将下载好的主题下载后放在 themes 文件下面 ，然后配置博客配置文件 _config.yml，将langscape修改成需要配置的主题名字。如果主题需要一些依赖，根据作者下面提示安装 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 3、安装pure 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 4、pure的依赖 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 使用hexo开始写博客 开始写博客 1hexo new newpapername 博客写完之后 123hexo cleanhexo ghexo d hexo基本配置网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址 参数 描述 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 permalink_defaults 永久链接中各部分的默认值","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-30T12:16:49.877Z","updated":"2022-08-30T12:27:49.047Z","comments":true,"path":"2022/08/30/hello-world/","link":"","permalink":"http://example.com/2022/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hexo如何在网页上面显示图片","slug":"hexo如何在网页上面显示图片","date":"2022-08-29T09:24:28.000Z","updated":"2022-08-30T12:16:49.877Z","comments":true,"path":"2022/08/29/hexo如何在网页上面显示图片/","link":"","permalink":"http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"","text":"hexo如何在网页上面显示图片1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径 2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。1npm install https://github.com/CodeFalling/hexo-asset-image --save 3、配置_config_yml文件12//设置 post_asset_folder 为truepost_asset_folder: true","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"数组指针和指针数组","slug":"数组指针和指针数组","date":"2022-08-29T06:25:05.000Z","updated":"2022-08-30T12:16:49.880Z","comments":true,"path":"2022/08/29/数组指针和指针数组/","link":"","permalink":"http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组指针和指针数组1、数组指针 数组指针：指向数组的指针，优先级顺序是：（）&gt; [] &gt; * 12//根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针int （*p1）[5]; 对于语句“int ( * p1)[5]”，“()”的优先级比“[]”高，“*”号和 p1 构成一个指针的定义，指针变量名为 p1，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p1 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如下所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。 123 -------------------------------------------p1 ----&gt; | int * | init * | int * | init * | int * | ------------------------------------------- 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main()&#123; int (*p)[5]; //定义一个数组指针 int arr[5] = &#123;1,2,3,4,5&#125;; //定义一个数组 p = &amp;arr; //p指向数组首地址 printf(&quot;p0 value = %d\\r\\n&quot;,*(*p + 0)); //arr[0] printf(&quot;p1 value = %d\\r\\n&quot;,*(*p + 1)); //arr[1] printf(&quot;p2 value = %d\\r\\n&quot;,*(*p + 2)); //arr[2] printf(&quot;p3 value = %d\\r\\n&quot;,*(*p + 3)); //arr[3] printf(&quot;p4 value = %d\\r\\n&quot;,*(*p + 4)); //arr[4] return 0;&#125;//p 代表的是数组首地址//arr 代表的是整个数组首元素首地址//&amp;arr 代表整个数组首地址(对数组首元素首地址取地址得到数组首地址)//*p 代表数组首元素首地址//*p+1 代表数组首元素地址 + 1//**p //表示数组首元素首地址对应的值//将二维数组赋给指针#include &lt;stdio.h&gt;int main()&#123; int b[3][4]; int (*pp)[4];//定义一个数组指针，指向含四个元素的一维数组 pp = b;//将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的 pp++;//该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1] return 0;&#125;//根据上面二维数组可以得出，数组指针也称指向一维数组的指针，所以数组指针也称行指针。 2、指针数组 指针数组：装着指针的数组，优先级顺序：[] &gt;* 12int *p2[5];//根据优先级，先看[]，则p是一个数组，再结合*，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。 对于int *p2[5] 来说，因为“ [] ”的优先级要比 “ * ”的优先级要高，所以p2先和“ [] ”结合，构成一个数组的定义，数组名为p2,而“ int ”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如下所示。因此他是一个指针数组。 1234 p2----------------------------------------------------------------------------| | | | |int * int * int * int * int * 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; // ptr 里面存放的是 5个字符串的首元素地址 char *ptr[5]=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;blos&quot;,&quot;456&quot;,&quot;hhels&quot;&#125;; int a = 1; int b = 2; int *p[2]; p[0] = &amp;a; p[1] = &amp;b; printf(&quot;%d\\r\\n&quot;,*p[0]); printf(&quot;%d\\r\\n&quot;,*p[1]); printf(&quot;%s\\r\\n&quot;,ptr[0]); printf(&quot;%s\\r\\n&quot;,ptr[1]); return 0;&#125; 对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针.","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"git初始化连接远程仓库","slug":"git初始化连接远程仓库","date":"2022-08-26T14:47:35.000Z","updated":"2022-08-30T12:16:49.876Z","comments":true,"path":"2022/08/26/git初始化连接远程仓库/","link":"","permalink":"http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"如何使用git1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）123456//配置用户名git config --global user.name &quot;yourname&quot;//配置邮箱git config --global user.email &quot;youremail&quot;//查看是否配置成功git config --list --global 2、初始化git仓库1git init 3、配置ssh公钥 生成公钥 1ssh-keygen -t rsa -C &quot;youremail&quot; //youremail是前面global配置的email 查看获取公钥 1cat ~/.ssh/id_rsa.pub 将获取到的公钥添加到gitee上面 查看公钥是否配置成功 1ssh -T git@gitee.com 远程仓库的添加和查看 12345//远程仓库添加git remote add origin +(远程仓库地址)//git remote add origin git@gitee.com:linux_4/drivers-imx6ull.git//查看远程仓库git remote 拉取远程分支 1git pull origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"git的一些常用操作","slug":"git的一些常用操作","date":"2022-08-26T13:42:20.000Z","updated":"2022-08-30T12:16:49.876Z","comments":true,"path":"2022/08/26/git的一些常用操作/","link":"","permalink":"http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"git常用命令1、单个文件加入缓存区12git add +需要加入缓存的文件git add . //将所有文件加入跟踪 2、撤销add添加缓存命令12git reset + 想要撤销的文件git reset . //撤销add 的所有文件 3、将缓存区里面的内容提交&#x2F;修改1234//提交git commit -m &quot;需要添加的注释&quot;//修改commit提交的信息git commit --amend + 修改commit提交的信息 4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支123456789101112//创建分支git branch + 创建分支名//查看分支git branch//切换分支git checkout + 切换分支名//切换分支 如果没有分支就创建分支 git checkout -b +分支名//分支合并git merge + 分支名称 5、删除分支1234//删除时需要做检查git branch -d +分支名称 （要做检查的删除分支）//删除时不需要做任何检查git branch -D +分支名称 （不做任何检查的强制删除） 6、查看提交的历史信息123456//查看提交的详细历史信息git log git log --graph --oneline (以图形化界面查看)//获取每条日志的简要信息git log --pretty=oneline//查看本地的操作历史git reflog 7、配置SSH公钥123456//生成公钥ssh-keygen -t rsa -C &quot;youremail@example.com&quot;//获取公钥cat ~/.ssh/id_rsa.pub//查看公钥是否添加成功 ssh -T git@gitee.com 8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取12345678910111213//远程仓库的添加git remote add origin +(远程仓库地址)//远程仓库的查看 git remote//远程仓库的推送 git push origin master git pull --rebase origin master（如果推送不成功使用这个）（保持远端和本地数据同步） //与远端分支关系绑定 git push --set-upstream origin master:master （与远端关系绑定） （本地master） (远端master) //删除指定远程分支 git push origin --delete master git push origin :master //指定拉取分支 git pull origin master（如果pull出现冲突，可以版本回退和 封存修改，pull之后在还原） 9、查看本地分支与远程分支的对应关系1git branch -vv 10、git克隆1git clone + 克隆地址 11、git版本回退12//git 回退到你想要回退的版本号git reset --hard + 版本对应的id 12、强制拉取合并分支1git pull origin master --allow-unrelated-histories 13、删除远程仓库1git remote rm origin 14、创建远端仓库分支1git pull origin + 本地分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"markdown使用说明","slug":"markdown使用说明","date":"2022-08-25T15:17:46.000Z","updated":"2022-08-30T12:16:49.879Z","comments":true,"path":"2022/08/25/markdown使用说明/","link":"","permalink":"http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"markdown 使用说明功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G 标题的创建直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式、12345678910111213*强调文本* _强调文本_**加粗文本** __加粗文本__==标记文本==~~删除文本~~&gt; 引用文本H~2~O is是液体。2^10^ 运算结果是 1024. 强调文本 强调文本 加粗文本 加粗文本 &#x3D;&#x3D;标记文本&#x3D;&#x3D; 删除文本 引用文本 H2O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片1链接: [link](https://www.csdn.net/). 链接: link. 生成列表12345678910- 项目 - 项目 - 项目1. 项目12. 项目23. 项目3- [ ] 计划任务- [x] 完成任务 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建表格12345项目 | Value-------- | -----电脑 | $1600手机 | $12导管 | $1 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中，居左，居右123456使用`:---------:`居中使用`:----------`居左使用`----------:`居右| 第一列 | 第二列 | 第三列 ||:-----------:| :-------------:|:-------------|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | 使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 创建一个注脚123一个具有注脚的文本。[^2][^2]: 注脚的解释 一个具有注脚的文本。^2 流程图123456789这将产生一个流程图。:​```mermaidgraph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D​``` 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D","categories":[],"tags":[{"name":"md","slug":"md","permalink":"http://example.com/tags/md/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"Linux应用开发","slug":"Linux应用开发","permalink":"http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"linux驱动开发","slug":"linux驱动开发","permalink":"http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"md","slug":"md","permalink":"http://example.com/tags/md/"}]}