{"meta":{"title":"个人博客","subtitle":"xZhaoquan","description":"","author":"xZhaoquan","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"字符设备","slug":"字符设备","date":"2022-09-14T10:36:18.000Z","updated":"2022-09-14T13:27:19.571Z","comments":true,"path":"2022/09/14/字符设备/","link":"","permalink":"http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/","excerpt":"","text":"字符设备驱动设备驱动框架 1、设备号的申请和注销 设备号的定义 1static struct cdev chrdev; 使用register_chrdev_region函数静态申请设备号 1234567register_chrdev_region函数用于静态地为一个字符设备申请一个或多个设备编号。函数原型：int register_chrdev_region(dev_t from, unsigned count, const char *name)参数：from：需要注册的设备号，不能与被注册的设备号相同count：需要申请的设备号个数name：申请的设备号名称 在 &quot;cat /proc/devices&quot;下可查看到设备名称和设备号返回值：0成功 其他失败 调用alloc_chrdev_region函数动态的申请设备号 12345678调用alloc_chrdev_region函数，内核会自动分配给我们一个尚未使用的主设备号。函数原型：int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)参数：dev：指向dev_t类型数据的指针变量，用于存放分配到的设备编号的起始值；baseminor：次设备号的起始值，通常为0count：指定需要分配的设备编号个数name：设备名称返回值：返回0成功 注销申请的字符设备号 12345使用xxx_chrdev_region()函数申请的设备号可以使用unregister_chrdev_region()注销函数原型：void unregister_chrdev_region(dev_t from, unsigned count)参数：from：指定需要注销的字符设备的设备编号起始值count：指定需要注销的字符设备编号的个数，该值应与申请函数的count值相等 register_chrdev函数申请设备号 1234567891011register_chrdev函数用于分配设备号函数原型：static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)&#123; return __register_chrdev(major, 0, 256, name, fops);&#125;参数：major：用于指定要申请的字符设备的主设备号，major = 0 时，内核会自动分配一个未使用的主设备号。name：设备名称fops：用于操作该设备的函数接口指针返回值：主设备号 unregister_chrdev注销申请的字符设备号 123456789使用register函数申请的设备号，则应该使用unregister_chrdev函数进行注销。函数原型：static inline void unregister_chrdev(unsigned int major, const char *name)&#123;__unregister_chrdev(major, 0, 256, name);&#125;参数：major：指定需要释放的字符设备的主设备号name：执行需要释放的字符设备的名称 设备号宏 1234567#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi))MINOR(dev)：用来获取该设备文件的次设备号MINOR(dev)：用来获取该设备文件的主设备号MKDEV(ma,mi)：将主设备号和次设备号一起转成dev_t类型的设备号 2、实现file_operations结构体和初始化cdev 实现file_operations结构体里面的函数 1234567891011static struct file_operations led_chrdev_fops = &#123; .owner = THIS_MODULE, .open = led_chrdev_open, .release = led_chrdev_release, .write = led_chrdev_write,&#125;;实现我们需要用的函数：static int led_chrdev_open(struct inode *inode, struct file *filp)；static int led_chrdev_release(struct inode *inode, struct file *filp)；static ssize_t led_chrdev_write(struct file *filp, const char __user * buf, size_t count, loff_t * ppos)； 初始化cdev 12345使用cdev_init函数将cdev和file_operations 相关联起来函数原型：void cdev_init(struct cdev *cdev, const struct file_operations *fops)参数：cdev：struct cdev类型的指针变量，指向需要关联的字符设备结构体；fops：file_operations类型的结构体指针变量，一般将实现操作该设备的结构体file_operations结构体作为实参。 3、设备注册和注销 设备注册 1234567cdev_add函数用于向内核的cdev_map散列表添加一个新的字符设备函数原型：int cdev_add(struct cdev *p, dev_t dev, unsigned count)参数：p：struct cdev类型的指针，用于指定需要添加的字符设备dev：dev_t类型变量，用于指定设备的起始编号count：指定注册多少个设备返回值：返回为0 添加成功 设备注销 1234cdev_del函数用于向内核的cdev_map散列表删除注册的字符设备函数原型：void cdev_del(struct cdev *p)参数：p：struct cdev类型的指针，用于指定需要删除的字符设备； 4、设备的逻辑类的创建和删除 动态创建设备的逻辑类 12345678910111213class_create()用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。此函数的执行效果就是在/sys/class/目录下创建一个新的文件夹。宏原型：#define class_create(owner, name) \\(&#123; \\ static struct lock_class_key __key; \\ __class_create(owner, name, &amp;__key); \\&#125;)参数：owner：一个struct module结构体类型的指针，一般赋值为THIS_MODULEname：代表即将创建的struct class变量的名字，用于给struct class的name字段赋值class_create(THISMODULE,&quot;chrdev&quot;); //在 /sys/class/目录下面创建一个chrdev文件 删除设备的逻辑类 12345函数class_destroy()用于删除设备的逻辑类即从Linux内核系统中删除设备的逻辑类。此函数执行的效果是删除函数__class_create()或宏class_create()在/sys/class/目录下创建的逻辑类对应的文件夹。函数原型：void class_destroy(struct class *cls);参数：cls：创建成功的class设备的逻辑类 5、设备节点的创建和销毁 代码设备节点的创建 12345678910111213141516device_create函数创建一个设备并将其注册到文件系统函数原型：struct device *device_create(struct class *class, struct device *parent, dev_t devt, void *drvdata, const char *fmt, ...)参数：class：指向这个设备应该注册到的struct类的指针parent：指向此新设备的父结构设备（如果有）的指针devt：要添加的char设备的开发drvdata：要添加到设备进行回调的数据fmt：输入设备名称返回值：成功返回 struct device 结构体指针, 错误时返回ERR_PTR().example:struct class *led_chrdev_class;led_chrdev_class = class_create(THIS_MODULE, &quot;led_chrdev&quot;); //在 /dev/目录下面创建led_chrdev的设备节点文件device_create(led_chrdev_class, NULL, cur_dev, NULL,DEV_NAME &quot;%d&quot;, i); 代码设备节点的销毁 123456789101112使用device_destroy删除使用device_create函数创建的设备函数原型：void device_destroy(struct class *class, dev_t devt)参数：class：指向注册此设备的struct类的指针；devt：以前注册的设备的开发example:static dev_t devno;//已分配的主设备号dev_t cur_dev;cur_dev = MKDEV(MAJOR(devno), MINOR(devno) + i); //将主设备和次设备转化成dev_t类型的设备号device_destroy(led_chrdev_class, cur_dev);//销毁设备节点class_destroy(led_chrdev_class); 注意：class_create 和 class_destroy是成对出现的不可只单独使用其中一个。 使用mknod命令创建节点 12345678910可以使用mknod命令创建设备节点。用法：mknod 设备名 设备类型 主设备号 次设备号设备类型：- b 创建（有缓冲的）区块特殊文件- c,u 创建(没有缓冲的)字符特殊文件- p 创建先进先出(FIFO)特殊文件example://创建一个字符设备/dev/led 主设备号为200 次设备号为0mknod /dev/led c 200 0 6、字符设备驱动流程 设备驱动流程 设备卸载流程 常用命令1234lsmod 显示已载入系统的模块modinfo+模块名字 查看模块详细信息ls /dev/ 查看设备节点cat /proc/devices 查看设备和设备号","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"内核模块","slug":"内核模块","date":"2022-09-10T14:04:20.000Z","updated":"2022-09-11T03:45:40.319Z","comments":true,"path":"2022/09/10/内核模块/","link":"","permalink":"http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","excerpt":"","text":"内核模块内核模块概念-现代内核派系1、现代内核派系-关键功能和服务功能均在内核空间提供（linux） 运行效率高 扩展性差 2、微内核-内核空间提供关键功能，服务功能在用户空间提供 运行效率低 扩展性较高 两者区别如下图： 内核模块实验环境搭建1、搭建开发板环境 开发板烧录Debain镜像-当前开发板内核版本：4.19.35-imx6 启动开发板，搭建nfs客户端，挂载共享文件夹 获取debain镜像内核源码-编译 2、获取内核源码-编译（4.19.35-imx6） 获取linux内核源码 1git clone https://gitee.com/Embedfire/ebf_linux_kernel_6ull_depth1 安装工具配置环境 1sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop 开始编译，构建内核 12./make_deb.sh (如果权限不足加上sudo)修改build_opts=&quot;$&#123;build_opts&#125; O=X&quot;,可以改变安装的路径，X=你想要存放的路径 获取编译的出来的内核文件的相关文件 12将路径下存放的当前的内核相关文件 拷贝到你的工程路径下面/home/kernel/bulid 内核模块所需头文件123#include &lt;linux/module.h&gt; //包含内核模块信声明的相关函数#include &lt;linux/init.h&gt; // 包含module_init module_exit 函数声明#include &lt;linux/kernel.h&gt; //包含内核提供的各种函数，例如printk内核模块打印函数 内核模块函数&#x2F;命令1、内核模块加载、卸载12内核加载命令：insmod内核卸载命令：rmmod 2、内核函数入口，出口 内核函数模块入口-加载模块式函数自动执行，进行初始化操作 内核函数模块出口-卸载模块是函数自动执行，进行清理工作 12内核模块入口函数： module_init();内核模块出口函数： module_exit(); 3、内核模块信息声明 MODULE_LICENSE：内核模块版权声明，模块接受软件许可协议 MODULE_AUTHOR：描述模块作者信息 MODULE_DESCRIPTION：对模块的简单介绍 MODULE_ALIAS：给模块设置一个别名 1234内核模块版权声明，模块接受软件许可协议 MODULE_LICENSE();描述模块作者信息 MODULE_AUTHOR();对模块的简单介绍 MODULE_DESCRIPTION();给模块设置一个别名 MODULE_ALIAS(); 4、内核模块打印函数 printk内核模块打印函数-需要指定打印等级 123456789101112131415161718//打印等级0-7#define KERN_EMERG &quot;&lt;0&gt;&quot; 通常是系统崩溃前的信息#define KERN_ALERT &quot;&lt;1&gt;&quot; 需要立即处理的消息#define KERN_CRIT &quot;&lt;2&gt;&quot; 严重情况#define KERN_ERR &quot;&lt;3&gt;&quot; 错误情况#define KERN_WARNING &quot;&lt;4&gt;&quot; 有问题的情况#define KERN_NOTICE &quot;&lt;5&gt;&quot; 注意信息#define KERN_INFO &quot;&lt;6&gt;&quot; 普通消息#define KERN_DEBUG &quot;&lt;7&gt;&quot; 调试信息打印内核所有打印信息：dmesg查看当前系统的printk打印等级：cat /proc/sys/kernel/printk下图的4417对应4 当前控制台日志级别4 默认消息日志级别1 最小的控制台级别7 默认控制台日志级别 5、模块参数 模块参数：根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性 模块参数函数：module_param 1234567891011121314module_param(name,type,perm);- name 参数名- type 参数类型- perm 读写权限数据类型对应type类型：int类型： int&lt;------------&gt; intchar类型: char&lt;-----------&gt; bytebool类型： bool&lt;-----------&gt; bool字符串类型: char*&lt;----------&gt; charpperm读写权限：- 不可以设置执行权限 如0777- 在sys/modules/模块名/paramters 目录下生成该参数对应的文件名 6、符号共享 内核模块可以共享导出的符号表 可以变量共享和函数共享 符号共享函数：EXPORT_SYMBOL 12EXPORT_SYMBOL(sym);sym:变量名或者是函数名 查看符号表 12cat /proc/kallsyms | grep xxxxxx:需要查看的模块名 7、模块加载 模块手动加载 121、模块加载时必须先加载相关依赖模块2、模块卸载时必须先卸载模块，在卸载依赖模块 模块自动加载 将所有内核模块统一放在 “&#x2F;lib&#x2F;modules&#x2F;内核版本”目录下 1cp *.ko /lib/modules/4.19.35-imx6 建立模块依赖关系 1depmod -a 查看模块依赖关系 1cat /lib/modules/4.19.35-imx6/modlue.dep 加载、卸载模块及其依赖关系 123加载模块及依赖： modprobe xxx下载模块及依赖： modprobe -r xxxxxx：需要操作的模块","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"使用hexo搭建个人博客","slug":"使用hexo搭建个人博客","date":"2022-09-08T16:21:19.000Z","updated":"2022-09-08T16:21:56.763Z","comments":true,"path":"2022/09/09/使用hexo搭建个人博客/","link":"","permalink":"http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用hexo搭建个人博客1、安装环境依赖 安装git（按照默认操作即可） 1如果点击鼠标右键 能够打开git bash 说明git 安装成功 安装node.js 123鼠标右键打开git bash查看node 是否安装成功node -v 安装hexo 12345安装hexo1、桌面新建一个文件夹 blog，git bash 进入文件夹2、设置淘宝镜像原（npm config set registry http://registry.npm.taobao.org）//可要可不要3、安装hexo npm install hexo-cli -g4、检测hexo是否安装完成 hexo -v 生成博客文件 生成博客文件 123打开githexo init blog(如果没有进入到blog文件夹)hexo init (如果进入到blog文件夹) 预览博客文件 12hexo s将生成的网址复制到网页执行，可以看到博客文件 部署博客到gitee平台 在gitee创建一个仓库，创建仓库名称使用gitee用户名。（如果不适用用户名，需要再仓库名后面加.gitee.io） 仓库创建成功后，复制HTTP 链接网址。 配置博客配置文件 _config.yml 1234deploy: type: &#x27;git&#x27; //选择git repo: https://gitee.com/yys_cn_ccs/zhaoqaun.git //gitee http 链接地址 branch: master //git 分支的配置 安装hexo部署工具 1npm install hexo-deployer-git --save 生成静态链接文件（public） 1hexo g 部署（需要输入gitee用户名字加密码） 1hexo d 开启gitee服务 打开gitee 点击右上角“服务”—-选择Gitee Pages 点击部署。 设置hexo主题1、去找到自己希望的 hexi主题，搜索主题名字。 2、将下载好的主题下载后放在 themes 文件下面 ，然后配置博客配置文件 _config.yml，将langscape修改成需要配置的主题名字。如果主题需要一些依赖，根据作者下面提示安装 1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape 3、安装pure 1git clone https://github.com/cofess/hexo-theme-pure.git themes/pure 4、pure的依赖 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 使用hexo开始写博客 开始写博客 1hexo new newpapername 博客写完之后 123hexo cleanhexo ghexo d hexo基本配置网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 网址 参数 描述 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 permalink_defaults 永久链接中各部分的默认值","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-08-30T12:16:49.877Z","updated":"2022-08-30T12:27:49.047Z","comments":true,"path":"2022/08/30/hello-world/","link":"","permalink":"http://example.com/2022/08/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"hexo如何在网页上面显示图片","slug":"hexo如何在网页上面显示图片","date":"2022-08-29T09:24:28.000Z","updated":"2022-08-30T12:16:49.877Z","comments":true,"path":"2022/08/29/hexo如何在网页上面显示图片/","link":"","permalink":"http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/","excerpt":"","text":"hexo如何在网页上面显示图片1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径 2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。1npm install https://github.com/CodeFalling/hexo-asset-image --save 3、配置_config_yml文件12//设置 post_asset_folder 为truepost_asset_folder: true","categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"}]},{"title":"数组指针和指针数组","slug":"数组指针和指针数组","date":"2022-08-29T06:25:05.000Z","updated":"2022-08-30T12:16:49.880Z","comments":true,"path":"2022/08/29/数组指针和指针数组/","link":"","permalink":"http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/","excerpt":"","text":"数组指针和指针数组1、数组指针 数组指针：指向数组的指针，优先级顺序是：（）&gt; [] &gt; * 12//根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针int （*p1）[5]; 对于语句“int ( * p1)[5]”，“()”的优先级比“[]”高，“*”号和 p1 构成一个指针的定义，指针变量名为 p1，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p1 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如下所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。 123 -------------------------------------------p1 ----&gt; | int * | init * | int * | init * | int * | ------------------------------------------- 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main()&#123; int (*p)[5]; //定义一个数组指针 int arr[5] = &#123;1,2,3,4,5&#125;; //定义一个数组 p = &amp;arr; //p指向数组首地址 printf(&quot;p0 value = %d\\r\\n&quot;,*(*p + 0)); //arr[0] printf(&quot;p1 value = %d\\r\\n&quot;,*(*p + 1)); //arr[1] printf(&quot;p2 value = %d\\r\\n&quot;,*(*p + 2)); //arr[2] printf(&quot;p3 value = %d\\r\\n&quot;,*(*p + 3)); //arr[3] printf(&quot;p4 value = %d\\r\\n&quot;,*(*p + 4)); //arr[4] return 0;&#125;//p 代表的是数组首地址//arr 代表的是整个数组首元素首地址//&amp;arr 代表整个数组首地址(对数组首元素首地址取地址得到数组首地址)//*p 代表数组首元素首地址//*p+1 代表数组首元素地址 + 1//**p //表示数组首元素首地址对应的值//将二维数组赋给指针#include &lt;stdio.h&gt;int main()&#123; int b[3][4]; int (*pp)[4];//定义一个数组指针，指向含四个元素的一维数组 pp = b;//将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的 pp++;//该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1] return 0;&#125;//根据上面二维数组可以得出，数组指针也称指向一维数组的指针，所以数组指针也称行指针。 2、指针数组 指针数组：装着指针的数组，优先级顺序：[] &gt;* 12int *p2[5];//根据优先级，先看[]，则p是一个数组，再结合*，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。 对于int *p2[5] 来说，因为“ [] ”的优先级要比 “ * ”的优先级要高，所以p2先和“ [] ”结合，构成一个数组的定义，数组名为p2,而“ int ”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如下所示。因此他是一个指针数组。 1234 p2----------------------------------------------------------------------------| | | | |int * int * int * int * int * 1234567891011121314151617181920#include &lt;stdio.h&gt;int main()&#123; // ptr 里面存放的是 5个字符串的首元素地址 char *ptr[5]=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;blos&quot;,&quot;456&quot;,&quot;hhels&quot;&#125;; int a = 1; int b = 2; int *p[2]; p[0] = &amp;a; p[1] = &amp;b; printf(&quot;%d\\r\\n&quot;,*p[0]); printf(&quot;%d\\r\\n&quot;,*p[1]); printf(&quot;%s\\r\\n&quot;,ptr[0]); printf(&quot;%s\\r\\n&quot;,ptr[1]); return 0;&#125; 对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针.","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"git初始化连接远程仓库","slug":"git初始化连接远程仓库","date":"2022-08-26T14:47:35.000Z","updated":"2022-08-30T12:16:49.876Z","comments":true,"path":"2022/08/26/git初始化连接远程仓库/","link":"","permalink":"http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/","excerpt":"","text":"如何使用git1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）123456//配置用户名git config --global user.name &quot;yourname&quot;//配置邮箱git config --global user.email &quot;youremail&quot;//查看是否配置成功git config --list --global 2、初始化git仓库1git init 3、配置ssh公钥 生成公钥 1ssh-keygen -t rsa -C &quot;youremail&quot; //youremail是前面global配置的email 查看获取公钥 1cat ~/.ssh/id_rsa.pub 将获取到的公钥添加到gitee上面 查看公钥是否配置成功 1ssh -T git@gitee.com 远程仓库的添加和查看 12345//远程仓库添加git remote add origin +(远程仓库地址)//git remote add origin git@gitee.com:linux_4/drivers-imx6ull.git//查看远程仓库git remote 拉取远程分支 1git pull origin master","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"git的一些常用操作","slug":"git的一些常用操作","date":"2022-08-26T13:42:20.000Z","updated":"2022-08-30T12:16:49.876Z","comments":true,"path":"2022/08/26/git的一些常用操作/","link":"","permalink":"http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","excerpt":"","text":"git常用命令1、单个文件加入缓存区12git add +需要加入缓存的文件git add . //将所有文件加入跟踪 2、撤销add添加缓存命令12git reset + 想要撤销的文件git reset . //撤销add 的所有文件 3、将缓存区里面的内容提交&#x2F;修改1234//提交git commit -m &quot;需要添加的注释&quot;//修改commit提交的信息git commit --amend + 修改commit提交的信息 4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支123456789101112//创建分支git branch + 创建分支名//查看分支git branch//切换分支git checkout + 切换分支名//切换分支 如果没有分支就创建分支 git checkout -b +分支名//分支合并git merge + 分支名称 5、删除分支1234//删除时需要做检查git branch -d +分支名称 （要做检查的删除分支）//删除时不需要做任何检查git branch -D +分支名称 （不做任何检查的强制删除） 6、查看提交的历史信息123456//查看提交的详细历史信息git log git log --graph --oneline (以图形化界面查看)//获取每条日志的简要信息git log --pretty=oneline//查看本地的操作历史git reflog 7、配置SSH公钥123456//生成公钥ssh-keygen -t rsa -C &quot;youremail@example.com&quot;//获取公钥cat ~/.ssh/id_rsa.pub//查看公钥是否添加成功 ssh -T git@gitee.com 8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取12345678910111213//远程仓库的添加git remote add origin +(远程仓库地址)//远程仓库的查看 git remote//远程仓库的推送 git push origin master git pull --rebase origin master（如果推送不成功使用这个）（保持远端和本地数据同步） //与远端分支关系绑定 git push --set-upstream origin master:master （与远端关系绑定） （本地master） (远端master) //删除指定远程分支 git push origin --delete master git push origin :master //指定拉取分支 git pull origin master（如果pull出现冲突，可以版本回退和 封存修改，pull之后在还原） 9、查看本地分支与远程分支的对应关系1git branch -vv 10、git克隆1git clone + 克隆地址 11、git版本回退12//git 回退到你想要回退的版本号git reset --hard + 版本对应的id 12、强制拉取合并分支1git pull origin master --allow-unrelated-histories 13、删除远程仓库1git remote rm origin 14、创建远端仓库分支1git pull origin + 本地分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"markdown使用说明","slug":"markdown使用说明","date":"2022-08-25T15:17:46.000Z","updated":"2022-08-30T12:16:49.879Z","comments":true,"path":"2022/08/25/markdown使用说明/","link":"","permalink":"http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","excerpt":"","text":"markdown 使用说明功能快捷键撤销：Ctrl/Command + Z重做：Ctrl/Command + Y加粗：Ctrl/Command + B斜体：Ctrl/Command + I标题：Ctrl/Command + Shift + H无序列表：Ctrl/Command + Shift + U有序列表：Ctrl/Command + Shift + O检查列表：Ctrl/Command + Shift + C插入代码：Ctrl/Command + Shift + K插入链接：Ctrl/Command + Shift + L插入图片：Ctrl/Command + Shift + G查找：Ctrl/Command + F替换：Ctrl/Command + G 标题的创建直接输入1次#，并按下space后，将生成1级标题。输入2次#，并按下space后，将生成2级标题。以此类推，我们支持6级标题。有助于使用TOC语法后生成一个完美的目录。 如何改变文本的样式、12345678910111213*强调文本* _强调文本_**加粗文本** __加粗文本__==标记文本==~~删除文本~~&gt; 引用文本H~2~O is是液体。2^10^ 运算结果是 1024. 强调文本 强调文本 加粗文本 加粗文本 &#x3D;&#x3D;标记文本&#x3D;&#x3D; 删除文本 引用文本 H2O is是液体。 2^10^ 运算结果是 1024. 插入链接与图片1链接: [link](https://www.csdn.net/). 链接: link. 生成列表12345678910- 项目 - 项目 - 项目1. 项目12. 项目23. 项目3- [ ] 计划任务- [x] 完成任务 项目 项目 项目 项目1 项目2 项目3 计划任务 完成任务 创建表格12345项目 | Value-------- | -----电脑 | $1600手机 | $12导管 | $1 项目 Value 电脑 $1600 手机 $12 导管 $1 设定内容居中，居左，居右123456使用`:---------:`居中使用`:----------`居左使用`----------:`居右| 第一列 | 第二列 | 第三列 ||:-----------:| :-------------:|:-------------|| 第一列文本居中 | 第二列文本居右 | 第三列文本居左 | 使用:---------:居中使用:----------居左使用----------:居右 第一列 第二列 第三列 第一列文本居中 第二列文本居右 第三列文本居左 创建一个注脚123一个具有注脚的文本。[^2][^2]: 注脚的解释 一个具有注脚的文本。^2 流程图123456789这将产生一个流程图。:​```mermaidgraph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D​``` 这将产生一个流程图。: 12345graph LRA[长方形] -- 链接 --&gt; B((圆))A --&gt; C(圆角长方形)B --&gt; D&#123;菱形&#125;C --&gt; D","categories":[],"tags":[{"name":"md","slug":"md","permalink":"http://example.com/tags/md/"}]}],"categories":[{"name":"hexo","slug":"hexo","permalink":"http://example.com/categories/hexo/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"hexo","slug":"hexo","permalink":"http://example.com/tags/hexo/"},{"name":"C语言","slug":"C语言","permalink":"http://example.com/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"md","slug":"md","permalink":"http://example.com/tags/md/"}]}