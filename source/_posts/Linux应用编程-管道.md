---
title: Linux应用编程-管道
date: 2022-10-26 23:39:05
tags: Linux应用编程
---

##	Linux应用编程-管道

#### 管道分类

##### 匿名管道（父子之间进行通信）

匿名管道：特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后 fork 产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的. 匿名管道没有名字，一般进程无法使用 open() 来获取他的描述符  ，所以匿名管道只能用于亲缘关系进程间通信  。

匿名管道有以下特征：

```
• 没有名字，因此不能使用 open() 函数打开，但可以使用 close() 函数关闭。
• 只提供单向通信（半双工），也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。
• 只能用于具有血缘关系的进程间通信，通常用于父子进程建通信。
• 管道是基于字节流来通信的。
• 依赖于文件系统，它的生命周期随进程的结束而结束。
• 写入操作不具有原子性，因此只能用于一对一的简单通信情形。
• 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read() 和 write() 等函数。但是它又不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中，因此不能使用 lseek() 来定位。
```

##### pipe函数（所有进程间通信）

pipe() 函数用于创建一个匿名管道，一个可用于进程间通信的单向数据通道。  

```
int pipe(int pipefd[2]);
pipefd[0] 指管道的读取端， pipefd[1]指向管道的写端
pipe函数返回 0 表示创建匿名管道成功 返回 -1 创建失败
```

创建匿名管道需要一下步骤：

```
• 父进程调用 pipe() 函数创建匿名管道，得到两个文件描述符 pipefd[0]、 pipefd[1]，分别指向管道的读取端和写入端。
• 父进程调用 fork() 函数启动（创建）一个子进程，那么子进程将从父进程中继承这两个文件描述符 pipefd[0]、 pipefd[1]，它们指向同一匿名管道的读取端与写入端。
• 由于匿名管道是利用环形队列实现的，数据将从写入端流入管道，从读取端流出，这样子就实现了进程间通信，但是这个匿名管道此时有两个读取端与两个写入端，因此需要进行接下来的操作。
• 如果想要从父进程将数据传递给子进程，则父进程需要关闭读取端，子进程关闭写入端，如图数据从父进程流向子进程 所示。
• 如果想要从子进程将数据传递给父进程，则父进程需要关闭写入端，子进程关闭读取端，如图数据从子进程流向父进程 所示。
• 当不需要管道的时候，就在进程中将未关闭的一端关闭即可。
```



##### 命名管道

命名管道：

命名管道可以在多个无关的进程中交换数据（通信） .

命名管道一下特征：

```
• 有名字，存储于普通文件系统之中。
• 任何具有相应权限的进程都可以使用 open() 来获取命名管道的文件描述符。
• 跟普通文件一样：使用统一的 read()/write() 来读写。
• 跟普通文件不同：不能使用 lseek() 来定位，原因是数据存储于内存中。
• 具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。
• 遵循先进先出（First In First Out）原则，最先被写入 FIFO 的数据，最先被读出来。
```

mkfifo函数：

```
int mkfifo(const char * pathname,mode_t mode);
- pathname 需要创建的FIFO文件名
- mode mode模式及权限参数说明
	• O_RDONLY：读管道。
    • O_WRONLY：写管道。
    • O_RDWR：读写管道。
    • O_NONBLOCK：非阻塞。
    • O_CREAT：如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。
    • O_EXCL：如果使用 O_CREAT 时文件存在，那么可返回错误消息。这一参数可测试文件是否存在。
返回值说明如下：
    • 0：成功
    • EACCESS：参数 filename 所指定的目录路径无可执行的权限。
    • EEXIST：参数 filename 所指定的文件已存在。
    • ENAMETOOLONG：参数 filename 的路径名称太长。
    • ENOENT：参数 filename 包含的目录不存在。
    • ENOSPC：文件系统的剩余空间不足。
    • ENOTDIR：参数 filename 路径中的目录存在但却非真正的目录。
    • EROFS：参数 filename 指定的文件存在于只读文件系统内。
mkfifo() 会根据参数 pathname 建立特殊的 FIFO 文件，而参数 mode 为该文件的模式与权限。
对FIFO进行读操作：
-阻塞类型的管道 管道内有数据就读取，没有数据就阻塞在那里
-非阻塞类型的管道 不论 FIFO 内是否有数据，读进程都会立即执行读操作，管道内没有数据返回0
对FIFO进行写操作：
-阻塞类型的管道 写操作将一直阻塞到数据可以被写入。
-非阻塞类型的管道 不能写入全部数据，则写操作进行部分写入或者调用失败。

```

access函数

```
检查调用进程是否可以对指定的文件执行某种操作。
int access(const char* pathname, int mode);
- pathname 是文件的路径名+文件名
- mode：指定access的作用，取值如下
    • F_OK 值为0，判断文件是否存在 
    • X_OK 值为1，判断对文件是可执行权限 
    • W_OK 值为2，判断对文件是否有写权限 
    • R_OK 值为4，判断对文件是否有读权限
```

