<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>xZhaoquan</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-25T14:50:52.105Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>xZhaoquan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux应用编程-进程</title>
    <link href="http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-10-25T14:48:47.000Z</published>
    <updated>2022-10-25T14:50:52.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-进程"><a href="#Linux应用编程-进程" class="headerlink" title="Linux应用编程-进程"></a>Linux应用编程-进程</h2><h5 id="fork-进程函数："><a href="#fork-进程函数：" class="headerlink" title="fork()进程函数："></a>fork()进程函数：</h5><p>fork()进程函数用于从一个已存在的进程中去启动一个新进程，新进程成为子进程，原来的进程称为父进程。fork()函数的本质是直接将父进程的内容复制一份，但是子进程与父进程也有不一样的地方。</p><p>子进程与父进程相同的内容：</p><ul><li>进程的地址空间</li><li>进程上下文，代码段</li><li>进程的堆栈空间，和内存信息</li><li>进程的环境变量，标准的IO缓冲区</li><li>打开的文件描述符，信号响应函数，当前的工作路劲</li></ul><p>子进程独有的内容：</p><ul><li>子进程的进程号PID，PID是进程的唯一的标识符</li><li>记录锁，父进程对某文件加锁，子进程不会继承这把锁</li><li>挂起信号，父进程的响应但未处理的信号，子进程不会继承</li></ul><p><img src="/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20221025225022643.png" alt="image-20221025225022643"></p><p>fork函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line"></span><br><span class="line">fork函数启动成功：父进程会返回子进程的pid,子进程返回0，</span><br><span class="line">启动失败：返回-1</span><br><span class="line"></span><br><span class="line">pid_t getpid(void);函数会返回当前进程pid</span><br><span class="line">pid_t getppid(void);函数会返回当前进程的父进程pid</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="exec系列进程替换函数"><a href="#exec系列进程替换函数" class="headerlink" title="exec系列进程替换函数"></a>exec系列进程替换函数</h5><p>exec系列函数用于替换进程的执行程序，它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换  </p><p>exec系列函数介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ...)</span><br><span class="line">int execlp(const char *file, const char *arg, ...)</span><br><span class="line">int execle(const char *path, const char *arg, ..., char *const envp[])</span><br><span class="line">int execv(const char *path, char *const argv[])</span><br><span class="line">int execvp(const char *file, char *const argv[])</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">这些函数可以分为两大类execl、execlp和execle传递给子程序的参数个数是可变的。 execv、 execvp 和 execve 通过数组去装载子程序的参数，无论那种形式，参数都以一个空指针 NULL 结束.</span><br><span class="line">l----list 列表</span><br><span class="line">v----vector 数组</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">const char *path:该参数需要输入文件路径，例如：&quot;/bin/ls&quot; &quot;/bin/pwd&quot;</span><br><span class="line">const char *file:该参数需要输入需要执行的应用程序名字，例如：&quot;ls&quot; &quot;pwd&quot;</span><br><span class="line">const char *arg:该参数需要输入对应字符，例如：&quot;ls&quot;,&quot;-al&quot;,NULL &quot;pwd&quot;,NULL</span><br><span class="line">const char *agrv[]:该参数需要输入对应数组指针：例如：char *argv[]=&#123;&quot;pwd&quot;,NULL&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">！！注意：exec 系列函数是直接将当前进程给替换掉的，当调用 exec 系列函数后，当前进程将不会</span><br><span class="line">再继续执行，</span><br></pre></td></tr></table></figure><p>execl函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ... )</span><br><span class="line">path:指定文件路径</span><br><span class="line">arg：执行文件所传递的参数 arg[0],arg[1]...arg[n],最后一个参数必须是NULL做结束标志</span><br><span class="line"></span><br><span class="line">该函数一般不会返回，除非遇到错误会返回-1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>execv函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int execv(const char *path, char *const argv[])</span><br><span class="line">path:指定文件路径</span><br><span class="line">argv：执行文件所传递的参数是一个数组指针,最后一个参数必须是NULL做结束标志</span><br><span class="line"></span><br><span class="line">该函数一般不会返回，除非遇到错误会返回-1</span><br></pre></td></tr></table></figure><h5 id="进程的生老病死"><a href="#进程的生老病死" class="headerlink" title="进程的生老病死"></a>进程的生老病死</h5><p><img src="/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20221025225044367.png" alt="image-20221025225044367"></p><h5 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h5><ul><li><p>正常终止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-main 函数返回</span><br><span class="line">-调用_exit()函数终止</span><br><span class="line">-调用exit()函数终止</span><br></pre></td></tr></table></figure></li><li><p>异常终止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-调用abort()函数异常终止</span><br><span class="line">-又系统信号终止 </span><br></pre></td></tr></table></figure></li></ul><p>exit函数和_exit()函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void _exit(int status);</span><br><span class="line">void exit(int status);</span><br><span class="line">传入一个status保存进程终止时的状态码</span><br></pre></td></tr></table></figure><p>exit()函数和_exit()函数的异同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit() 和 _exit() 函数都是用来终止进程的，当程序执行到 exit() 或 _exit() 函数时，进程会无条件地停止剩下的所有操作，清除包括 PCB 在内的各种数据结构，并终止当前进程的运行。</span><br><span class="line"></span><br><span class="line">_exit() 函数:直接通过系统调用使进程终止运行,清除这个进程使用的内存空间，并销毁它在内核中的各种数据结构.</span><br><span class="line">exit() 函数是_exit()函数包装来的。在执行_exit()函数之前，需要清除&quot;IO缓冲区&quot;，有效的保存数据的完整性。</span><br><span class="line">清清除&quot;IO缓冲区&quot;是检查文件的打开情况，把文件缓冲区中的内容写回文件</span><br></pre></td></tr></table></figure><h5 id="等待进程"><a href="#等待进程" class="headerlink" title="等待进程"></a>等待进程</h5><p>当一个进程调用了exit()函数之后，该进程并不会直接消失，而是会变成僵尸进程。需要等待其父进程去回收僵尸进程，需要调用waitpid()或者wait()函数去回收僵尸进程并且，释放僵尸进程占有的内存空间，和了解进程终止的状态信息。调用wait函数会阻塞父进程。</p><p>wait函数和waitpid函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//wait函数</span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">调用wait函数之后 调用成功：返回子进程pid，和进程退出状态</span><br><span class="line">失败:返回-1</span><br><span class="line"></span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">pid:欲等待的子进程的识别码。</span><br><span class="line">• pid&lt;-1等待进程组号为pid绝对值的任何子进程。</span><br><span class="line">• pid&gt;0等待进程号为pid的子进程。</span><br><span class="line">• pid=-1等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。</span><br><span class="line">• pid=0等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。</span><br><span class="line">wstatus：返回的状态值</span><br><span class="line">options：控制waitpid()函数的行为，如果不想使用这些选项，则可以把这个参数设为0。</span><br><span class="line">• WNOHANG如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这个函数上等待；如果结束了，则返回该子进程的进程号。</span><br><span class="line">• WUNTRACED如果子进程进入暂停状态，则马上返回。</span><br><span class="line"></span><br><span class="line">调用wait函数之后 调用成功：返回子进程pid，和进程退出状态</span><br><span class="line">失败:返回-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//waitpid函数</span><br><span class="line">如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；</span><br><span class="line">但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</span><br><span class="line"></span><br><span class="line">waitpid(-1,&amp;status,0) = wait(&amp;status)</span><br><span class="line"></span><br><span class="line">//wait和waitpid函数调用之后返回 wstatus 的值</span><br><span class="line">• WIFEXITED(status) ：如果子进程正常结束，返回一个非零值</span><br><span class="line">• WEXITSTATUS(status)：如果 WIFEXITED 非零，返回子进程退出码</span><br><span class="line">• WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值</span><br><span class="line">• WTERMSIG(status) ：如果 WIFSIGNALED 非零，返回信号代码</span><br><span class="line">• WIFSTOPPED(status)：如果子进程被暂停，返回一个非零值</span><br><span class="line">• WSTOPSIG(status)：如果 WIFSTOPPED 非零，返回一个信号代码</span><br></pre></td></tr></table></figure><h5 id="进程组，会话，终端"><a href="#进程组，会话，终端" class="headerlink" title="进程组，会话，终端"></a>进程组，会话，终端</h5><ul><li>进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程组：</span><br><span class="line">• 对相同的类型的进程进行管理</span><br><span class="line">进程组的诞生：</span><br><span class="line">• 在shell里面直接执行一个应用程序，对于大部分应用程序，自己就是进程组的首进程。进程组只有一个进程</span><br><span class="line">• 如果进程调用了fork函数，那么父子进程同属一个进程组，父进程为首进程</span><br><span class="line">• shell中通过管道执行连接起来的应用程序，两个程序同属一个进程组，第一个程序为进程组的首进程</span><br><span class="line"></span><br><span class="line">进程组id:pgid,由首进程pid决定 </span><br><span class="line">pgid：进程组所在的id号</span><br></pre></td></tr></table></figure><ul><li>会话（一般关联着一个终端）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">会话：管理前后台进程组</span><br><span class="line">会话的诞生：</span><br><span class="line">• 调用调用setsid函数，新建一个会话，应用程序作为会话的第一个进程，称为会话首进程</span><br><span class="line">• 用户在终端正确登录之后，启动shell时linux系统会创建一个新的会话，shell进程作为会话首进程。</span><br><span class="line">会话id:sid</span><br><span class="line">sid:会话首进程id</span><br></pre></td></tr></table></figure><ul><li>前台进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前台进程组：</span><br><span class="line">shell进程启动时，默认是前台进程组的首进程</span><br><span class="line">前台进程组的首进程会占用绘画所关联的终端来运行，shell启动其他应用程序时，其他程序成为首进程</span><br></pre></td></tr></table></figure><ul><li>后台进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">后台进程组的程序是不会占用终端的。</span><br><span class="line">在shell终端运行程序时，在后面加上&amp;的符号，可以指定程序运行在后台进程组里面。</span><br><span class="line">例：sleep 10 &amp;</span><br><span class="line"></span><br><span class="line">ctrl+z：会使进程进入后台，同时停止执行。返回终端</span><br><span class="line">jobs:查看有哪些后台进程组，和jobs id</span><br><span class="line">fg +job id可以把后台进程组切换为前台进程组</span><br></pre></td></tr></table></figure><ul><li>终端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">物理终端</span><br><span class="line">• 串口终端</span><br><span class="line">• lcd终端</span><br><span class="line">伪终端（不依赖物理设备）</span><br><span class="line">• SSH远程连接产生的终端</span><br><span class="line">• 桌面系统产生的终端</span><br><span class="line">虚拟终端</span><br><span class="line">• linux内核自带的 ctrl+alt+f0~f6来打开不同的终端</span><br><span class="line"></span><br><span class="line">终端被关闭之后，会话中的所有进程都会被关掉</span><br></pre></td></tr></table></figure><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>守护进程不受终端影响的，终端退出，而也可以继续在后台运行，</p><p>写守护进程步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• 创建一个子进程，父进程直接退出，</span><br><span class="line">- 使用fork()函数创建,</span><br><span class="line">• 创建一个新的会话</span><br><span class="line">- 父进程使用setsid()函数创建一个新的会话，没有关联任何终端</span><br><span class="line">• 改变守护进程的当前工作目录，改为&quot;/&quot;。因为子进程会继承父进程的工作目录的。所以需要改变工作目录。</span><br><span class="line">- 父进程使用chdir()函数实现</span><br><span class="line">• 重设文件权限的掩码（umask可以查看文件权限掩码 0022 -- 只写）</span><br><span class="line">新建文件的权限默认使0666,需要与掩码进行与非(&amp;~)的运算才是实际的文件权限</span><br><span class="line">-父进程使用umask()函数实现 umask直接设置为0</span><br><span class="line">• 关闭不需要的文件描述符</span><br><span class="line">- 父进程使用close()函数实现</span><br><span class="line">    - 0，1，2文件描述符，分别对应终端的标准输入，输出，出错。不需要与终端相关联所以需要关闭这些文件描述符。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-进程&quot;&gt;&lt;a href=&quot;#Linux应用编程-进程&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-进程&quot;&gt;&lt;/a&gt;Linux应用编程-进程&lt;/h2&gt;&lt;h5 id=&quot;fork-进程函数：&quot;&gt;&lt;a href=&quot;#for</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>函数返回二维数组地址</title>
    <link href="http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/"/>
    <id>http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/</id>
    <published>2022-10-22T13:37:41.000Z</published>
    <updated>2022-10-22T13:38:51.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回二维数组地址"><a href="#返回二维数组地址" class="headerlink" title="返回二维数组地址"></a>返回二维数组地址</h2><h5 id="int-p-int-3-说明："><a href="#int-p-int-3-说明：" class="headerlink" title="int *(*p(int))[3]说明："></a><em>int</em> *(*p(<em>int</em>))[3]说明：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,</span><br><span class="line">//说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,</span><br><span class="line">//说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.</span><br><span class="line">//所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址方法1"><a href="#返回二维数组地址方法1" class="headerlink" title="返回二维数组地址方法1"></a>返回二维数组地址方法1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;</span><br><span class="line">int (*ptraar)[4];</span><br><span class="line"></span><br><span class="line">int (*vfunc(void))[4]</span><br><span class="line">&#123;</span><br><span class="line">  return parr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ptraar = vfunc();</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,(*(*ptraar ) + 1)); //ptrarr[0][1]</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,ptrarr[0][1]); //ptrarr[0][1]</span><br><span class="line">&#125;</span><br><span class="line">//解析</span><br><span class="line">ptraar = 二维数组首地址</span><br><span class="line">(*ptraar ) = 二维数组元素首地址</span><br><span class="line">(*(*ptraar ) = 一维数组元素首地址</span><br><span class="line">(*(*ptraar ) + 1) = ptrarr[0][1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址方法2"><a href="#返回二维数组地址方法2" class="headerlink" title="返回二维数组地址方法2"></a>返回二维数组地址方法2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int prrs[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void * func(void)</span><br><span class="line">&#123;</span><br><span class="line">  return prrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *ins;</span><br><span class="line">ins = func();</span><br><span class="line">ptraar = (int (*)[4])ins;</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,*(*(ptraar + 1) + 2 ));</span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址指针"><a href="#返回二维数组地址指针" class="headerlink" title="返回二维数组地址指针"></a>返回二维数组地址指针</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;</span><br><span class="line">int *ptesarr[3][4]=&#123;&#123;&amp;arrss[0],&amp;arrss[1],&amp;arrss[2],&amp;arrss[3]&#125;,</span><br><span class="line">                    &#123;&amp;arrss[4],&amp;arrss[5],&amp;arrss[6],&amp;arrss[7]&#125;,</span><br><span class="line">                    &#123;&amp;arrss[8],&amp;arrss[9],&amp;arrss[10],&amp;arrss[11]&#125;&#125;;</span><br><span class="line">                    </span><br><span class="line">int *(*psst)[4];</span><br><span class="line">int *(*functions(void))[4]</span><br><span class="line">&#123;</span><br><span class="line">  return ptesarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">psst = functions();</span><br><span class="line">printf(&quot;psst ptr = %d\r\n&quot;,*(*(*(psst+0)) + 3));//*psst[0][3]</span><br><span class="line">printf(&quot;psst ptr arr= %d\r\n&quot;,*(psst[1][3]));//*psst[1][3]</span><br><span class="line">&#125;</span><br><span class="line">//解析</span><br><span class="line">*psst[2][3] = *(psst[2][3])  </span><br><span class="line">*(pstt[2][3]) = *((*(pstt+2)+3))</span><br><span class="line">pstt二维数组首地址</span><br><span class="line">*(pstt) = [二维数组元素首地址]</span><br><span class="line">*(*(pstt)) = [一维数组元素首地址]</span><br><span class="line">*(*(*(pstt + 2)) + 3) = [二维数组首地址 + 2][一维数组元素首地址 + 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;返回二维数组地址&quot;&gt;&lt;a href=&quot;#返回二维数组地址&quot; class=&quot;headerlink&quot; title=&quot;返回二维数组地址&quot;&gt;&lt;/a&gt;返回二维数组地址&lt;/h2&gt;&lt;h5 id=&quot;int-p-int-3-说明：&quot;&gt;&lt;a href=&quot;#int-p-int-3-说明</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>单链表头插法</title>
    <link href="http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/"/>
    <id>http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/</id>
    <published>2022-10-22T13:31:29.000Z</published>
    <updated>2022-10-22T13:34:58.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表头插法"><a href="#单链表头插法" class="headerlink" title="单链表头插法"></a>单链表头插法</h2><h5 id="单链表数据结构定义"><a href="#单链表数据结构定义" class="headerlink" title="单链表数据结构定义"></a>单链表数据结构定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct timer</span><br><span class="line">&#123;</span><br><span class="line">  int value; //数据</span><br><span class="line">  struct timer *next;//节点</span><br><span class="line">&#125;timer;</span><br><span class="line"></span><br><span class="line">//定义头指针head_handle</span><br><span class="line">static struct timer *head_handle;</span><br></pre></td></tr></table></figure><h5 id="链表初始化"><a href="#链表初始化" class="headerlink" title="链表初始化"></a>链表初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void timer_init(struct timer *handle,int value)</span><br><span class="line">&#123;</span><br><span class="line">  memset(handle,0,sizeof(struct timer));</span><br><span class="line">  handle-&gt;buff = NULL;</span><br><span class="line">  handle-&gt;value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建链表（头插法）"><a href="#创建链表（头插法）" class="headerlink" title="创建链表（头插法）"></a>创建链表（头插法）</h5><p><img src="/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/image-20221022213426409.png" alt="image-20221022213426409"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int start_timer(struct timer *handle)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer *target = head_handle;</span><br><span class="line">  while(target)</span><br><span class="line">  &#123;</span><br><span class="line">    if(target == handle) //判断新创建的节点是否和以前创建的是否相同</span><br><span class="line">    &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    target = target-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  handle-&gt;next = head_handle;</span><br><span class="line">  head_handle = handle;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//new_node1节点创建之前头节点 head_handle == NULL</span><br><span class="line">//new_node1节点创建之后头节点 head_handle == new_node1</span><br><span class="line">//当前链表链接顺序：new_node1-&gt;head_handle</span><br><span class="line">//new_node2节点创建之后头节点 head_handle == new_node2</span><br><span class="line">//当前链表链接顺序：new_node2-&gt;new_node1-&gt;head_handle</span><br></pre></td></tr></table></figure><h5 id="删除链表"><a href="#删除链表" class="headerlink" title="删除链表"></a>删除链表</h5><p><img src="/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/image-20221022213453323.png" alt="image-20221022213453323"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void timer_stop(struct timer *handle)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer **curr;</span><br><span class="line">  for(curr = &amp;head_handle;*curr;)</span><br><span class="line">  &#123;</span><br><span class="line">    struct timer *entry = *curr;</span><br><span class="line">    if(entry == handle)</span><br><span class="line">    &#123;</span><br><span class="line">      *curr = entry-&gt;next;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      curr = &amp;entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void timer_traverse(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer *target;</span><br><span class="line">  //根据链表头节点遍历整个链表</span><br><span class="line">  for(target = head_handle;target;target = target-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;timer value : %d\r\n&quot;,target-&gt;value);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;\r\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单链表头插法&quot;&gt;&lt;a href=&quot;#单链表头插法&quot; class=&quot;headerlink&quot; title=&quot;单链表头插法&quot;&gt;&lt;/a&gt;单链表头插法&lt;/h2&gt;&lt;h5 id=&quot;单链表数据结构定义&quot;&gt;&lt;a href=&quot;#单链表数据结构定义&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>gitbash安装使用gcc和make</title>
    <link href="http://example.com/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/"/>
    <id>http://example.com/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/</id>
    <published>2022-09-24T11:50:14.000Z</published>
    <updated>2022-09-24T12:03:46.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git安装gcc编译器和make工具"><a href="#Git安装gcc编译器和make工具" class="headerlink" title="Git安装gcc编译器和make工具"></a>Git安装gcc编译器和make工具</h2><h5 id="1、gcc编译器和make工具下载"><a href="#1、gcc编译器和make工具下载" class="headerlink" title="1、gcc编译器和make工具下载"></a>1、gcc编译器和make工具下载</h5><p><a href="https://link.zhihu.com/?target=http://www.equation.com/servlet/equation.cmd?fa=fortran">http://www.equation.com/servlet/equation.cmd?fa=fortra</a> </p><h5 id="2、gcc和make的安装"><a href="#2、gcc和make的安装" class="headerlink" title="2、gcc和make的安装"></a>2、gcc和make的安装</h5><p>双击下载好的exe,一直点击继续，知道安装结束。</p><h5 id="3、配置gcc的环境"><a href="#3、配置gcc的环境" class="headerlink" title="3、配置gcc的环境"></a>3、配置gcc的环境</h5><ul><li><p>找到Git的安装目录，在Git的安装目录下面找到Git\etc\profile.d\env.sh配置文件</p><p><img src="/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/image-20220924200051244.png" alt="image-20220924200051244"></p></li><li><p>打开env.sh文件，添加export PATH&#x3D;”$HOME&#x2F;gcc&#x2F;bin:$PATH”</p><p><img src="/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/image-20220924200222615.png" alt="image-20220924200222615"></p></li><li><p>保存之后，双击env.sh就配置完成</p></li><li><p>如果添加之后不能保存env.sh文件，就设置权限</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git安装gcc编译器和make工具&quot;&gt;&lt;a href=&quot;#Git安装gcc编译器和make工具&quot; class=&quot;headerlink&quot; title=&quot;Git安装gcc编译器和make工具&quot;&gt;&lt;/a&gt;Git安装gcc编译器和make工具&lt;/h2&gt;&lt;h5 id=&quot;1</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LED字符设备</title>
    <link href="http://example.com/2022/09/14/LED%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2022/09/14/LED%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/</id>
    <published>2022-09-14T14:01:58.000Z</published>
    <updated>2022-09-14T15:54:50.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LED字符设备"><a href="#LED字符设备" class="headerlink" title="LED字符设备"></a>LED字符设备</h2><h5 id="1、实现虚拟IO映射和读写"><a href="#1、实现虚拟IO映射和读写" class="headerlink" title="1、实现虚拟IO映射和读写"></a>1、实现虚拟IO映射和读写</h5><ul><li><p>虚拟地址映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用ioremap函数进行虚拟地址映射</span><br><span class="line">函数原型：void __iomem *ioremap(resource_size_t res_cookie, size_t size);</span><br><span class="line">参数：</span><br><span class="line">res_cookie：实际的物理地址</span><br><span class="line">size：映射长度(一般4个字节)</span><br><span class="line">返回值： void __iomem*类型的指针，指向被映射的虚拟地址</span><br><span class="line"></span><br><span class="line">__iomem:主要是用于编译器的检查地址在内核空间的有效性</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">#define CCM_CCGR1_BASE     (0x020C406C)</span><br><span class="line">static void __iomem *IMX6ULL_CCM_CCGR1;</span><br><span class="line">IMX6ULL_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE,4);</span><br></pre></td></tr></table></figure></li><li><p>虚拟地址映射的取消</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用iounmap函数取消虚拟地址映射</span><br><span class="line">函数原型：void iounmap(volatile void __iomem *iomem_cookie);</span><br><span class="line">参数：</span><br><span class="line">iomem_cookie：指向虚拟地址的指针</span><br><span class="line"></span><br><span class="line">example：</span><br><span class="line">iounmap(IMX6ULL_CCM_CCGR1);</span><br></pre></td></tr></table></figure></li><li><p>虚拟地址的读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//虚拟地址的读取 8 16 32</span><br><span class="line">static inline u8 ioread8(const volatile void __iomem *addr) //8位的读取</span><br><span class="line">static inline u16 ioread16(const volatile void __iomem *addr) //16位的读取</span><br><span class="line">static inline u32 ioread32(const volatile void __iomem *addr) //32位的读取</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">addr：void __iomem *类型的虚拟地址</span><br><span class="line">返回值：u32/u16/u8类型的数据</span><br><span class="line"></span><br><span class="line">//虚拟地址的写 8 16 32</span><br><span class="line">static inline void iowrite8(u8 value, volatile void __iomem *addr)//写入8位数据</span><br><span class="line">static inline void iowrite16(u8 value, volatile void __iomem *addr)//写入16位数据</span><br><span class="line">static inline void iowrite32(u32 value, volatile void __iomem *addr)//写入32位数据</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">value：写入一个u32/u16/u8类型的数据</span><br><span class="line">addr：void __iomem *类型的虚拟地址</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、实现驱动接口"><a href="#2、实现驱动接口" class="headerlink" title="2、实现驱动接口"></a>2、实现驱动接口</h5><ul><li><p>file_operations 结构体的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//实现file_operation结构体</span><br><span class="line">static struct file_operations led_chrdev_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = led_open,</span><br><span class="line">    .write = led_write,</span><br><span class="line">    .release = led_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>操作接口函数的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//write release open函数的实现</span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,size_t count, loff_t *ppos)</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、数据的拷贝"><a href="#3、数据的拷贝" class="headerlink" title="3、数据的拷贝"></a>3、数据的拷贝</h5><ul><li><p>copy_from_user拷贝用户空间的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(void *to, const void __user *from, unsigned long n);</span><br><span class="line">参数：</span><br><span class="line">to：将数据拷贝到内核地址</span><br><span class="line">from：需要拷贝的用户空间的地址</span><br><span class="line">n：需要拷贝数据的长度</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、添加、删除LED字符设备"><a href="#4、添加、删除LED字符设备" class="headerlink" title="4、添加、删除LED字符设备"></a>4、添加、删除LED字符设备</h5><ul><li><p>使用register_chrdev函数添加LED字符设备（用mknod 创建字符设备文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//字符设备注册添加</span><br><span class="line">static inline int register_chrdev(unsigned int major, const char *name,</span><br><span class="line">  const struct file_operations *fops)</span><br><span class="line">参数：</span><br><span class="line">major：主设备号</span><br><span class="line">name：设备名字</span><br><span class="line">fops：file_operations的指针指向操作接口</span><br><span class="line"></span><br><span class="line">使用mknod /dev/led c 200 0 //创建一个字符设备/dev/led 主设备号为200 次设备号为0</span><br><span class="line"></span><br><span class="line">//字符设备注销</span><br><span class="line">static inline void unregister_chrdev(unsigned int major, const char *name)</span><br><span class="line">参数：</span><br><span class="line">major：主设备号</span><br><span class="line">name：设备名字</span><br><span class="line"></span><br><span class="line">//使用register_chrdev函数注册添加字符设备 注册成功会占用1个主设备号和256多个次设备号</span><br></pre></td></tr></table></figure></li><li><p>使用其他方式添加字符设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//动态申请主设备号</span><br><span class="line">alloc_chrdev_region();</span><br><span class="line">//创建class类</span><br><span class="line">class_create(); </span><br><span class="line">//cdev设备结构体与file_operations相关联</span><br><span class="line">cdev_init();</span><br><span class="line">//设备注册-添加设备到cdev_map哈希表中</span><br><span class="line">ret = cdev_add();</span><br><span class="line">//创建字符设备文件</span><br><span class="line">device_create();</span><br></pre></td></tr></table></figure></li><li><p>使用其他方式删除字符设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//删除字符设备文件</span><br><span class="line">device_destroy();</span><br><span class="line">//删除注册的字符设备（注销设备）</span><br><span class="line">cdev_del();</span><br><span class="line">//注销设备号</span><br><span class="line">unregister_chrdev_region();</span><br><span class="line">//删除设备逻辑类</span><br><span class="line">class_destroy();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LED字符设备&quot;&gt;&lt;a href=&quot;#LED字符设备&quot; class=&quot;headerlink&quot; title=&quot;LED字符设备&quot;&gt;&lt;/a&gt;LED字符设备&lt;/h2&gt;&lt;h5 id=&quot;1、实现虚拟IO映射和读写&quot;&gt;&lt;a href=&quot;#1、实现虚拟IO映射和读写&quot; class</summary>
      
    
    
    
    
    <category term="linux驱动开发" scheme="http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>字符设备</title>
    <link href="http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/</id>
    <published>2022-09-14T10:36:18.000Z</published>
    <updated>2022-09-21T13:18:41.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h4 id="设备驱动框架"><a href="#设备驱动框架" class="headerlink" title="设备驱动框架"></a>设备驱动框架</h4><p><img src="/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/image-20220914145604037.png" alt="image-20220914145604037"></p><h5 id="1、设备号的申请和注销"><a href="#1、设备号的申请和注销" class="headerlink" title="1、设备号的申请和注销"></a>1、设备号的申请和注销</h5><ul><li><p>设备号的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static struct cdev chrdev;</span><br></pre></td></tr></table></figure></li><li><p>使用register_chrdev_region函数静态申请设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev_region函数用于静态地为一个字符设备申请一个或多个设备编号。一般用于指定手动分配主设备号。</span><br><span class="line">函数原型：int register_chrdev_region(dev_t from, unsigned count, const char *name)</span><br><span class="line">参数：</span><br><span class="line">from：需要注册的设备号，不能与被注册的设备号相同</span><br><span class="line">count：需要申请的设备号个数</span><br><span class="line">name：申请的设备号名称 在 &quot;cat /proc/devices&quot;下可查看到设备名称和设备号</span><br><span class="line">返回值：0成功 其他失败</span><br></pre></td></tr></table></figure></li><li><p>调用alloc_chrdev_region函数动态的申请设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用alloc_chrdev_region函数，内核会自动分配给我们一个尚未使用的主设备号。</span><br><span class="line">函数原型：int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</span><br><span class="line">参数：</span><br><span class="line">dev：指向dev_t类型数据的指针变量，用于存放分配到的设备编号的起始值；</span><br><span class="line">baseminor：次设备号的起始值，通常为0</span><br><span class="line">count：指定需要分配的设备编号个数</span><br><span class="line">name：设备名称</span><br><span class="line">返回值：返回0成功</span><br></pre></td></tr></table></figure></li><li><p>注销申请的字符设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用xxx_chrdev_region()函数申请的设备号可以使用unregister_chrdev_region()注销</span><br><span class="line">函数原型：void unregister_chrdev_region(dev_t from, unsigned count)</span><br><span class="line">参数：</span><br><span class="line">from：指定需要注销的字符设备的设备编号起始值</span><br><span class="line">count：指定需要注销的字符设备编号的个数，该值应与申请函数的count值相等</span><br></pre></td></tr></table></figure></li><li><p>register_chrdev函数申请设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev函数用于分配设备号</span><br><span class="line">函数原型：static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">   return __register_chrdev(major, 0, 256, name, fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">major：用于指定要申请的字符设备的主设备号，major = 0 时，内核会自动分配一个未使用的主设备号。</span><br><span class="line">name：设备名称</span><br><span class="line">fops：用于操作该设备的函数接口指针</span><br><span class="line">返回值：主设备号</span><br></pre></td></tr></table></figure></li><li><p>unregister_chrdev注销申请的字符设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用register函数申请的设备号，则应该使用unregister_chrdev函数进行注销。</span><br><span class="line">函数原型：static inline void unregister_chrdev(unsigned int major, const char *name)</span><br><span class="line">&#123;</span><br><span class="line">__unregister_chrdev(major, 0, 256, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">major：指定需要释放的字符设备的主设备号</span><br><span class="line">name：执行需要释放的字符设备的名称</span><br></pre></td></tr></table></figure></li><li><p>设备号宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MAJOR(dev)((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><br><span class="line">#define MINOR(dev)((unsigned int) ((dev) &amp; MINORMASK))</span><br><span class="line">#define MKDEV(ma,mi)(((ma) &lt;&lt; MINORBITS) | (mi))</span><br><span class="line"></span><br><span class="line">MINOR(dev)：用来获取该设备文件的次设备号</span><br><span class="line">MINOR(dev)：用来获取该设备文件的主设备号</span><br><span class="line">MKDEV(ma,mi)：将主设备号和次设备号一起转成dev_t类型的设备号</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、实现file-operations结构体和初始化cdev"><a href="#2、实现file-operations结构体和初始化cdev" class="headerlink" title="2、实现file_operations结构体和初始化cdev"></a>2、实现file_operations结构体和初始化cdev</h5><ul><li><p>实现file_operations结构体里面的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct file_operations led_chrdev_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_chrdev_open,</span><br><span class="line">.release = led_chrdev_release,</span><br><span class="line">.write = led_chrdev_write,</span><br><span class="line">&#125;;</span><br><span class="line">实现我们需要用的函数：</span><br><span class="line">static int led_chrdev_open(struct inode *inode, struct file *filp)；</span><br><span class="line">static int led_chrdev_release(struct inode *inode, struct file *filp)；</span><br><span class="line">static ssize_t led_chrdev_write(struct file *filp, const char __user * buf,</span><br><span class="line">size_t count, loff_t * ppos)；</span><br></pre></td></tr></table></figure></li><li><p>初始化cdev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用cdev_init函数将cdev和file_operations 相关联起来</span><br><span class="line">函数原型：void cdev_init(struct cdev *cdev, const struct file_operations *fops)</span><br><span class="line">参数：</span><br><span class="line">cdev：struct cdev类型的指针变量，指向需要关联的字符设备结构体；</span><br><span class="line">fops：file_operations类型的结构体指针变量，一般将实现操作该设备的结构体file_operations结构体作为实参。</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、设备注册和注销"><a href="#3、设备注册和注销" class="headerlink" title="3、设备注册和注销"></a>3、设备注册和注销</h5><ul><li><p>设备注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cdev_add函数用于向内核的cdev_map散列表添加一个新的字符设备</span><br><span class="line">函数原型：int cdev_add(struct cdev *p, dev_t dev, unsigned count)</span><br><span class="line">参数：</span><br><span class="line">p：struct cdev类型的指针，用于指定需要添加的字符设备</span><br><span class="line">dev：dev_t类型变量，用于指定设备的起始编号</span><br><span class="line">count：指定注册多少个设备</span><br><span class="line">返回值：返回为0 添加成功</span><br></pre></td></tr></table></figure></li><li><p>设备注销</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cdev_del函数用于向内核的cdev_map散列表删除注册的字符设备</span><br><span class="line">函数原型：void cdev_del(struct cdev *p)</span><br><span class="line">参数：</span><br><span class="line">p：struct cdev类型的指针，用于指定需要删除的字符设备；</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、设备的逻辑类的创建和删除"><a href="#4、设备的逻辑类的创建和删除" class="headerlink" title="4、设备的逻辑类的创建和删除"></a>4、设备的逻辑类的创建和删除</h5><ul><li><p>动态创建设备的逻辑类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class_create()用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。</span><br><span class="line">此函数的执行效果就是在/sys/class/目录下创建一个新的文件夹。</span><br><span class="line">宏原型：#define class_create(owner, name)\</span><br><span class="line">(&#123;\</span><br><span class="line">static struct lock_class_key __key;\</span><br><span class="line">__class_create(owner, name, &amp;__key);\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">owner：一个struct module结构体类型的指针，一般赋值为THIS_MODULE</span><br><span class="line">name：代表即将创建的struct class变量的名字，用于给struct class的name字段赋值</span><br><span class="line"></span><br><span class="line">class_create(THISMODULE,&quot;chrdev&quot;); //在 /sys/class/目录下面创建一个chrdev文件</span><br></pre></td></tr></table></figure></li><li><p>删除设备的逻辑类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数class_destroy()用于删除设备的逻辑类即从Linux内核系统中删除设备的逻辑类。</span><br><span class="line">此函数执行的效果是删除函数__class_create()或宏class_create()在/sys/class/目录下创建的逻辑类对应的文件夹。</span><br><span class="line">函数原型：void class_destroy(struct class *cls);</span><br><span class="line">参数：</span><br><span class="line">cls：创建成功的class设备的逻辑类</span><br></pre></td></tr></table></figure></li></ul><h5 id="5、设备节点的创建和销毁"><a href="#5、设备节点的创建和销毁" class="headerlink" title="5、设备节点的创建和销毁"></a>5、设备节点的创建和销毁</h5><ul><li><p>代码设备节点的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">device_create函数创建一个设备并将其注册到文件系统</span><br><span class="line">函数原型：struct device *device_create(struct class *class, struct device *parent,</span><br><span class="line">            dev_t devt, void *drvdata, const char *fmt, ...)</span><br><span class="line">参数：</span><br><span class="line">class：指向这个设备应该注册到的struct类的指针</span><br><span class="line">parent：指向此新设备的父结构设备（如果有）的指针</span><br><span class="line">devt：要添加的char设备的开发</span><br><span class="line">drvdata：要添加到设备进行回调的数据</span><br><span class="line">fmt：输入设备名称</span><br><span class="line"></span><br><span class="line">返回值：成功返回 struct device 结构体指针, 错误时返回ERR_PTR().</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">struct class *led_chrdev_class;</span><br><span class="line">led_chrdev_class = class_create(THIS_MODULE, &quot;led_chrdev&quot;); //在 /dev/目录下面创建led_chrdev的设备节点文件</span><br><span class="line">device_create(led_chrdev_class, NULL, cur_dev, NULL,DEV_NAME &quot;%d&quot;, i);</span><br></pre></td></tr></table></figure></li><li><p>代码设备节点的销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用device_destroy删除使用device_create函数创建的设备</span><br><span class="line">函数原型：void device_destroy(struct class *class, dev_t devt)</span><br><span class="line">参数：</span><br><span class="line">class：指向注册此设备的struct类的指针；</span><br><span class="line">devt：以前注册的设备的开发</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">static dev_t devno;//已分配的主设备号</span><br><span class="line">dev_t cur_dev;</span><br><span class="line">cur_dev = MKDEV(MAJOR(devno), MINOR(devno) + i); //将主设备和次设备转化成dev_t类型的设备号</span><br><span class="line">device_destroy(led_chrdev_class, cur_dev);//销毁设备节点</span><br><span class="line">class_destroy(led_chrdev_class);</span><br></pre></td></tr></table></figure><p>注意：class_create 和 class_destroy是成对出现的不可只单独使用其中一个。</p></li><li><p>使用mknod命令创建节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以使用mknod命令创建设备节点。</span><br><span class="line">用法：mknod 设备名 设备类型 主设备号 次设备号</span><br><span class="line">设备类型：</span><br><span class="line">- b 创建（有缓冲的）区块特殊文件</span><br><span class="line">- c,u 创建(没有缓冲的)字符特殊文件</span><br><span class="line">- p 创建先进先出(FIFO)特殊文件</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">//创建一个字符设备/dev/led 主设备号为200 次设备号为0</span><br><span class="line">mknod /dev/led c 200 0</span><br></pre></td></tr></table></figure></li></ul><h5 id="6、字符设备驱动流程"><a href="#6、字符设备驱动流程" class="headerlink" title="6、字符设备驱动流程"></a>6、字符设备驱动流程</h5><ul><li><p>设备驱动流程</p><p><img src="/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/image-20220914184025132.png" alt="image-20220914184025132"></p></li><li><p>设备卸载流程</p><p><img src="/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/image-20220914184103046.png" alt="image-20220914184103046"></p></li></ul><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod 显示已载入系统的模块</span><br><span class="line">modinfo+模块名字 查看模块详细信息</span><br><span class="line">ls /dev/ 查看设备节点</span><br><span class="line">cat /proc/devices 查看设备和设备号</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符设备驱动&quot;&gt;&lt;a href=&quot;#字符设备驱动&quot; class=&quot;headerlink&quot; title=&quot;字符设备驱动&quot;&gt;&lt;/a&gt;字符设备驱动&lt;/h2&gt;&lt;h4 id=&quot;设备驱动框架&quot;&gt;&lt;a href=&quot;#设备驱动框架&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="linux驱动开发" scheme="http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>内核模块</title>
    <link href="http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</id>
    <published>2022-09-10T14:04:20.000Z</published>
    <updated>2022-09-14T14:18:26.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><h4 id="内核模块概念-现代内核派系"><a href="#内核模块概念-现代内核派系" class="headerlink" title="内核模块概念-现代内核派系"></a>内核模块概念-现代内核派系</h4><h5 id="1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）"><a href="#1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）" class="headerlink" title="1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）"></a>1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）</h5><ul><li>运行效率高</li><li>扩展性差</li></ul><h5 id="2、微内核-内核空间提供关键功能，服务功能在用户空间提供"><a href="#2、微内核-内核空间提供关键功能，服务功能在用户空间提供" class="headerlink" title="2、微内核-内核空间提供关键功能，服务功能在用户空间提供"></a>2、微内核-内核空间提供关键功能，服务功能在用户空间提供</h5><ul><li>运行效率低</li><li>扩展性较高</li></ul><p>两者区别如下图：</p><p><img src="/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/image-20220909130421444.png" alt="image-20220909130421444"></p><h4 id="内核模块实验环境搭建"><a href="#内核模块实验环境搭建" class="headerlink" title="内核模块实验环境搭建"></a>内核模块实验环境搭建</h4><h5 id="1、搭建开发板环境"><a href="#1、搭建开发板环境" class="headerlink" title="1、搭建开发板环境"></a>1、搭建开发板环境</h5><ul><li>开发板烧录Debain镜像-当前开发板内核版本：4.19.35-imx6</li><li>启动开发板，搭建nfs客户端，挂载共享文件夹</li><li>获取debain镜像内核源码-编译</li></ul><h5 id="2、获取内核源码-编译（4-19-35-imx6）"><a href="#2、获取内核源码-编译（4-19-35-imx6）" class="headerlink" title="2、获取内核源码-编译（4.19.35-imx6）"></a>2、获取内核源码-编译（4.19.35-imx6）</h5><ul><li><p>获取linux内核源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://gitee.com/Embedfire/ebf_linux_kernel_6ull_depth1</span><br></pre></td></tr></table></figure></li><li><p>安装工具配置环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop</span><br></pre></td></tr></table></figure></li><li><p>开始编译，构建内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./make_deb.sh (如果权限不足加上sudo)</span><br><span class="line">修改build_opts=&quot;$&#123;build_opts&#125; O=X&quot;,可以改变安装的路径，X=你想要存放的路径</span><br></pre></td></tr></table></figure></li><li><p>获取编译的出来的内核文件的相关文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将路径下存放的当前的内核相关文件 拷贝到你的工程路径下面</span><br><span class="line">/home/kernel/bulid</span><br></pre></td></tr></table></figure></li></ul><h4 id="内核模块所需头文件"><a href="#内核模块所需头文件" class="headerlink" title="内核模块所需头文件"></a>内核模块所需头文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;  //包含内核模块信声明的相关函数</span><br><span class="line">#include &lt;linux/init.h&gt; // 包含module_init module_exit 函数声明</span><br><span class="line">#include &lt;linux/kernel.h&gt;//包含内核提供的各种函数，例如printk内核模块打印函数</span><br></pre></td></tr></table></figure><h4 id="内核模块函数-x2F-命令"><a href="#内核模块函数-x2F-命令" class="headerlink" title="内核模块函数&#x2F;命令"></a>内核模块函数&#x2F;命令</h4><h5 id="1、内核模块加载、卸载"><a href="#1、内核模块加载、卸载" class="headerlink" title="1、内核模块加载、卸载"></a>1、内核模块加载、卸载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内核加载命令：insmod</span><br><span class="line">内核卸载命令：rmmod</span><br></pre></td></tr></table></figure><h5 id="2、内核函数入口，出口"><a href="#2、内核函数入口，出口" class="headerlink" title="2、内核函数入口，出口"></a>2、内核函数入口，出口</h5><ul><li><p>内核函数模块入口-加载模块式函数自动执行，进行初始化操作</p></li><li><p>内核函数模块出口-卸载模块是函数自动执行，进行清理工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内核模块入口函数：module_init();</span><br><span class="line">内核模块出口函数：module_exit();</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、内核模块信息声明"><a href="#3、内核模块信息声明" class="headerlink" title="3、内核模块信息声明"></a>3、内核模块信息声明</h5><ul><li><p>MODULE_LICENSE：内核模块版权声明，模块接受软件许可协议</p></li><li><p>MODULE_AUTHOR：描述模块作者信息</p></li><li><p>MODULE_DESCRIPTION：对模块的简单介绍</p></li><li><p>MODULE_ALIAS：给模块设置一个别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内核模块版权声明，模块接受软件许可协议  MODULE_LICENSE();</span><br><span class="line">描述模块作者信息MODULE_AUTHOR();</span><br><span class="line">对模块的简单介绍MODULE_DESCRIPTION();</span><br><span class="line">给模块设置一个别名MODULE_ALIAS();</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、内核模块打印函数"><a href="#4、内核模块打印函数" class="headerlink" title="4、内核模块打印函数"></a>4、内核模块打印函数</h5><ul><li><p>printk内核模块打印函数-需要指定打印等级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//打印等级0-7</span><br><span class="line">#define KERN_EMERG&quot;&lt;0&gt;&quot; 通常是系统崩溃前的信息</span><br><span class="line">#define KERN_ALERT&quot;&lt;1&gt;&quot; 需要立即处理的消息</span><br><span class="line">#define KERN_CRIT&quot;&lt;2&gt;&quot; 严重情况</span><br><span class="line">#define KERN_ERR&quot;&lt;3&gt;&quot; 错误情况</span><br><span class="line">#define KERN_WARNING&quot;&lt;4&gt;&quot; 有问题的情况</span><br><span class="line">#define KERN_NOTICE&quot;&lt;5&gt;&quot; 注意信息</span><br><span class="line">#define KERN_INFO&quot;&lt;6&gt;&quot; 普通消息</span><br><span class="line">#define KERN_DEBUG&quot;&lt;7&gt;&quot; 调试信息</span><br><span class="line"></span><br><span class="line">打印内核所有打印信息：dmesg</span><br><span class="line">查看当前系统的printk打印等级：cat /proc/sys/kernel/printk</span><br><span class="line"></span><br><span class="line">下图的4417对应</span><br><span class="line">4当前控制台日志级别</span><br><span class="line">4 默认消息日志级别</span><br><span class="line">1最小的控制台级别</span><br><span class="line">7默认控制台日志级别</span><br></pre></td></tr></table></figure><p><img src="/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/image-20220910225536855.png" alt="image-20220910225536855"></p></li></ul><h5 id="5、模块参数"><a href="#5、模块参数" class="headerlink" title="5、模块参数"></a>5、模块参数</h5><ul><li><p>模块参数：根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性</p></li><li><p>模块参数函数：module_param</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module_param(name,type,perm);</span><br><span class="line">- name 参数名</span><br><span class="line">- type 参数类型</span><br><span class="line">- perm 读写权限</span><br><span class="line"></span><br><span class="line">数据类型对应type类型：</span><br><span class="line">int类型：int&lt;------------&gt; int</span><br><span class="line">char类型:char&lt;-----------&gt; byte</span><br><span class="line">bool类型：bool&lt;-----------&gt; bool</span><br><span class="line">字符串类型:char*&lt;----------&gt; charp</span><br><span class="line"></span><br><span class="line">perm读写权限：</span><br><span class="line">- 不可以设置执行权限 如0777</span><br><span class="line">- 在sys/modules/模块名/paramters 目录下生成该参数对应的文件名</span><br></pre></td></tr></table></figure></li></ul><h5 id="6、符号共享"><a href="#6、符号共享" class="headerlink" title="6、符号共享"></a>6、符号共享</h5><ul><li><p>内核模块可以共享导出的符号表</p></li><li><p>可以变量共享和函数共享</p></li><li><p>符号共享函数：EXPORT_SYMBOL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(sym);</span><br><span class="line">sym:变量名或者是函数名</span><br></pre></td></tr></table></figure></li><li><p>查看符号表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep xxx</span><br><span class="line">xxx:需要查看的模块名</span><br></pre></td></tr></table></figure></li></ul><h5 id="7、模块加载"><a href="#7、模块加载" class="headerlink" title="7、模块加载"></a>7、模块加载</h5><ul><li><p>模块手动加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、模块加载时必须先加载相关依赖模块</span><br><span class="line">2、模块卸载时必须先卸载模块，在卸载依赖模块</span><br></pre></td></tr></table></figure></li><li><p>模块自动加载</p><ul><li><p>将所有内核模块统一放在 “&#x2F;lib&#x2F;modules&#x2F;内核版本”目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp *.ko /lib/modules/4.19.35-imx6 </span><br></pre></td></tr></table></figure></li><li><p>建立模块依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depmod -a</span><br></pre></td></tr></table></figure></li><li><p>查看模块依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /lib/modules/4.19.35-imx6/modlue.dep</span><br></pre></td></tr></table></figure></li><li><p>加载、卸载模块及其依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加载模块及依赖：modprobe xxx</span><br><span class="line">下载模块及依赖：modprobe -r xxx</span><br><span class="line">xxx：需要操作的模块</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内核模块&quot;&gt;&lt;a href=&quot;#内核模块&quot; class=&quot;headerlink&quot; title=&quot;内核模块&quot;&gt;&lt;/a&gt;内核模块&lt;/h2&gt;&lt;h4 id=&quot;内核模块概念-现代内核派系&quot;&gt;&lt;a href=&quot;#内核模块概念-现代内核派系&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="linux驱动开发" scheme="http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-09-08T16:21:19.000Z</published>
    <updated>2022-09-08T16:21:56.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用hexo搭建个人博客"><a href="#使用hexo搭建个人博客" class="headerlink" title="使用hexo搭建个人博客"></a>使用hexo搭建个人博客</h2><h3 id="1、安装环境依赖"><a href="#1、安装环境依赖" class="headerlink" title="1、安装环境依赖"></a>1、安装环境依赖</h3><ul><li><p>安装git（按照默认操作即可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果点击鼠标右键 能够打开git bash 说明git 安装成功</span><br></pre></td></tr></table></figure></li><li><p>安装node.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">鼠标右键打开git bash</span><br><span class="line">查看node 是否安装成功</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure></li><li><p>安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装hexo</span><br><span class="line">1、桌面新建一个文件夹 blog，git bash 进入文件夹</span><br><span class="line">2、设置淘宝镜像原（npm config set registry http://registry.npm.taobao.org）//可要可不要</span><br><span class="line">3、安装hexo npm install hexo-cli -g</span><br><span class="line">4、检测hexo是否安装完成 hexo -v </span><br></pre></td></tr></table></figure></li></ul><h3 id="生成博客文件"><a href="#生成博客文件" class="headerlink" title="生成博客文件"></a>生成博客文件</h3><ul><li><p>生成博客文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开git</span><br><span class="line">hexo init blog(如果没有进入到blog文件夹)</span><br><span class="line">hexo init (如果进入到blog文件夹)</span><br></pre></td></tr></table></figure></li><li><p>预览博客文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line">将生成的网址复制到网页执行，可以看到博客文件</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署博客到gitee平台"><a href="#部署博客到gitee平台" class="headerlink" title="部署博客到gitee平台"></a>部署博客到gitee平台</h3><ul><li><p>在gitee创建一个仓库，创建仓库名称使用gitee用户名。（如果不适用用户名，需要再仓库名后面加.gitee.io）</p></li><li><p>仓库创建成功后，复制HTTP 链接网址。</p></li><li><p>配置博客配置文件 _config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27; //选择git</span><br><span class="line">  repo: https://gitee.com/yys_cn_ccs/zhaoqaun.git //gitee http 链接地址</span><br><span class="line">  branch: master//git 分支的配置</span><br></pre></td></tr></table></figure></li><li><p>安装hexo部署工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>生成静态链接文件（public）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>部署（需要输入gitee用户名字加密码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启gitee服务"><a href="#开启gitee服务" class="headerlink" title="开启gitee服务"></a>开启gitee服务</h3><ul><li>打开gitee 点击右上角“服务”—-选择Gitee Pages 点击部署。</li></ul><h3 id="设置hexo主题"><a href="#设置hexo主题" class="headerlink" title="设置hexo主题"></a>设置hexo主题</h3><p>1、去找到自己希望的 hexi主题，搜索主题名字。</p><p>2、将下载好的主题下载后放在 themes 文件下面 ，然后配置博客配置文件 _config.yml，将langscape修改成需要配置的主题名字。如果主题需要一些依赖，根据作者下面提示安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><p>3、安装pure</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br></pre></td></tr></table></figure><p>4、pure的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><h3 id="使用hexo开始写博客"><a href="#使用hexo开始写博客" class="headerlink" title="使用hexo开始写博客"></a>使用hexo开始写博客</h3><ul><li><p>开始写博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new newpapername</span><br></pre></td></tr></table></figure></li><li><p>博客写完之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h3 id="hexo基本配置"><a href="#hexo基本配置" class="headerlink" title="hexo基本配置"></a>hexo基本配置</h3><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table><h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用hexo搭建个人博客&quot;&gt;&lt;a href=&quot;#使用hexo搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;使用hexo搭建个人博客&quot;&gt;&lt;/a&gt;使用hexo搭建个人博客&lt;/h2&gt;&lt;h3 id=&quot;1、安装环境依赖&quot;&gt;&lt;a href=&quot;#1、安装环</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/30/hello-world/"/>
    <id>http://example.com/2022/08/30/hello-world/</id>
    <published>2022-08-30T12:16:49.877Z</published>
    <updated>2022-08-30T12:27:49.047Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo如何在网页上面显示图片</title>
    <link href="http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/</id>
    <published>2022-08-29T09:24:28.000Z</published>
    <updated>2022-08-30T12:16:49.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo如何在网页上面显示图片"><a href="#hexo如何在网页上面显示图片" class="headerlink" title="hexo如何在网页上面显示图片"></a>hexo如何在网页上面显示图片</h2><h5 id="1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径"><a href="#1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径" class="headerlink" title="1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径"></a>1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径</h5><p><img src="/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/image-20220829172657020.png" alt="image-20220829172657020"></p><h5 id="2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。"><a href="#2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。" class="headerlink" title="2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。"></a>2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><h5 id="3、配置-config-yml文件"><a href="#3、配置-config-yml文件" class="headerlink" title="3、配置_config_yml文件"></a>3、配置_config_yml文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置 post_asset_folder 为true</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo如何在网页上面显示图片&quot;&gt;&lt;a href=&quot;#hexo如何在网页上面显示图片&quot; class=&quot;headerlink&quot; title=&quot;hexo如何在网页上面显示图片&quot;&gt;&lt;/a&gt;hexo如何在网页上面显示图片&lt;/h2&gt;&lt;h5 id=&quot;1、将typora的图像设</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>数组指针和指针数组</title>
    <link href="http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</id>
    <published>2022-08-29T06:25:05.000Z</published>
    <updated>2022-08-30T12:16:49.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h2><h5 id="1、数组指针"><a href="#1、数组指针" class="headerlink" title="1、数组指针"></a>1、数组指针</h5><ul><li><p>数组指针：指向数组的指针，优先级顺序是：（）&gt; [] &gt; *</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针</span><br><span class="line">int （*p1）[5];</span><br></pre></td></tr></table></figure></li><li><p>对于语句“int ( * p1)[5]”，“()”的优先级比“[]”高，“*”号和 p1 构成一个指针的定义，指针变量名为 p1，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p1 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如下所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> -------------------------------------------</span><br><span class="line">p1 ----&gt; | int * | init * | int * | init * | int * |</span><br><span class="line"> -------------------------------------------</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int (*p)[5]; //定义一个数组指针</span><br><span class="line">        int arr[5] = &#123;1,2,3,4,5&#125;; //定义一个数组</span><br><span class="line">        p = &amp;arr;//p指向数组首地址</span><br><span class="line">        printf(&quot;p0 value = %d\r\n&quot;,*(*p + 0)); //arr[0]</span><br><span class="line">        printf(&quot;p1 value = %d\r\n&quot;,*(*p + 1));//arr[1]</span><br><span class="line">        printf(&quot;p2 value = %d\r\n&quot;,*(*p + 2));//arr[2]</span><br><span class="line">        printf(&quot;p3 value = %d\r\n&quot;,*(*p + 3));//arr[3]</span><br><span class="line">        printf(&quot;p4 value = %d\r\n&quot;,*(*p + 4));  //arr[4]</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//p 代表的是数组首地址</span><br><span class="line">//arr 代表的是整个数组首元素首地址</span><br><span class="line">//&amp;arr 代表整个数组首地址(对数组首元素首地址取地址得到数组首地址)</span><br><span class="line">//*p 代表数组首元素首地址</span><br><span class="line">//*p+1 代表数组首元素地址 + 1</span><br><span class="line">//**p //表示数组首元素首地址对应的值</span><br><span class="line"></span><br><span class="line">//将二维数组赋给指针</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b[3][4];</span><br><span class="line">int (*pp)[4];//定义一个数组指针，指向含四个元素的一维数组</span><br><span class="line">pp = b;//将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的</span><br><span class="line">pp++;//该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1]</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//根据上面二维数组可以得出，数组指针也称指向一维数组的指针，所以数组指针也称行指针。</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、指针数组"><a href="#2、指针数组" class="headerlink" title="2、指针数组"></a>2、指针数组</h5><ul><li><p>指针数组：装着指针的数组，优先级顺序：[] &gt;*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p2[5];</span><br><span class="line">//根据优先级，先看[]，则p是一个数组，再结合*，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。</span><br></pre></td></tr></table></figure></li><li><p>对于int *p2[5] 来说，因为“ [] ”的优先级要比 “ * ”的优先级要高，所以p2先和“ [] ”结合，构成一个数组的定义，数组名为p2,而“ int ”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如下所示。因此他是一个指针数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p2</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">|               |                   |                  |                   |</span><br><span class="line">int *           int *               int *              int *               int *</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">// ptr 里面存放的是 5个字符串的首元素地址</span><br><span class="line">        char *ptr[5]=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;blos&quot;,&quot;456&quot;,&quot;hhels&quot;&#125;;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int *p[2];</span><br><span class="line">        p[0] = &amp;a;</span><br><span class="line">        p[1] = &amp;b;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\r\n&quot;,*p[0]);</span><br><span class="line">        printf(&quot;%d\r\n&quot;,*p[1]);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%s\r\n&quot;,ptr[0]);</span><br><span class="line">printf(&quot;%s\r\n&quot;,ptr[1]);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针"><a href="#对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针" class="headerlink" title="对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针."></a>对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针.</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组指针和指针数组&quot;&gt;&lt;a href=&quot;#数组指针和指针数组&quot; class=&quot;headerlink&quot; title=&quot;数组指针和指针数组&quot;&gt;&lt;/a&gt;数组指针和指针数组&lt;/h2&gt;&lt;h5 id=&quot;1、数组指针&quot;&gt;&lt;a href=&quot;#1、数组指针&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git初始化连接远程仓库</title>
    <link href="http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</id>
    <published>2022-08-26T14:47:35.000Z</published>
    <updated>2022-08-30T12:16:49.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何使用git"><a href="#如何使用git" class="headerlink" title="如何使用git"></a>如何使用git</h2><h4 id="1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）"><a href="#1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）" class="headerlink" title="1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）"></a>1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//配置用户名</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">//配置邮箱</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br><span class="line">//查看是否配置成功</span><br><span class="line">git config --list --global</span><br></pre></td></tr></table></figure><h4 id="2、初始化git仓库"><a href="#2、初始化git仓库" class="headerlink" title="2、初始化git仓库"></a>2、初始化git仓库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="3、配置ssh公钥"><a href="#3、配置ssh公钥" class="headerlink" title="3、配置ssh公钥"></a>3、配置ssh公钥</h4><ul><li><p>生成公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot; //youremail是前面global配置的email</span><br></pre></td></tr></table></figure></li><li><p>查看获取公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>将获取到的公钥添加到gitee上面</p></li><li><p>查看公钥是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure></li><li><p>远程仓库的添加和查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//远程仓库添加</span><br><span class="line">git remote add origin +(远程仓库地址)</span><br><span class="line">//git remote add origin git@gitee.com:linux_4/drivers-imx6ull.git</span><br><span class="line">//查看远程仓库</span><br><span class="line">git remote</span><br></pre></td></tr></table></figure></li><li><p>拉取远程分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何使用git&quot;&gt;&lt;a href=&quot;#如何使用git&quot; class=&quot;headerlink&quot; title=&quot;如何使用git&quot;&gt;&lt;/a&gt;如何使用git&lt;/h2&gt;&lt;h4 id=&quot;1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git的一些常用操作</title>
    <link href="http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2022-08-26T13:42:20.000Z</published>
    <updated>2022-08-30T12:16:49.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h5 id="1、单个文件加入缓存区"><a href="#1、单个文件加入缓存区" class="headerlink" title="1、单个文件加入缓存区"></a>1、单个文件加入缓存区</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add +需要加入缓存的文件</span><br><span class="line">git add . //将所有文件加入跟踪</span><br></pre></td></tr></table></figure><h5 id="2、撤销add添加缓存命令"><a href="#2、撤销add添加缓存命令" class="headerlink" title="2、撤销add添加缓存命令"></a>2、撤销add添加缓存命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset + 想要撤销的文件</span><br><span class="line">git reset . //撤销add 的所有文件</span><br></pre></td></tr></table></figure><h5 id="3、将缓存区里面的内容提交-x2F-修改"><a href="#3、将缓存区里面的内容提交-x2F-修改" class="headerlink" title="3、将缓存区里面的内容提交&#x2F;修改"></a>3、将缓存区里面的内容提交&#x2F;修改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//提交</span><br><span class="line">git commit -m &quot;需要添加的注释&quot;</span><br><span class="line">//修改commit提交的信息</span><br><span class="line">git commit --amend + 修改commit提交的信息</span><br></pre></td></tr></table></figure><h5 id="4、创建分支-x2F-查看分支-x2F-切换分支-x2F-合并分支"><a href="#4、创建分支-x2F-查看分支-x2F-切换分支-x2F-合并分支" class="headerlink" title="4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支"></a>4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建分支</span><br><span class="line">git branch + 创建分支名</span><br><span class="line">//查看分支</span><br><span class="line">git branch</span><br><span class="line">//切换分支</span><br><span class="line">git checkout + 切换分支名</span><br><span class="line"></span><br><span class="line">//切换分支 如果没有分支就创建分支 </span><br><span class="line">git checkout -b +分支名</span><br><span class="line"></span><br><span class="line">//分支合并</span><br><span class="line">git merge + 分支名称</span><br></pre></td></tr></table></figure><h5 id="5、删除分支"><a href="#5、删除分支" class="headerlink" title="5、删除分支"></a>5、删除分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//删除时需要做检查</span><br><span class="line">git branch -d +分支名称 （要做检查的删除分支）</span><br><span class="line">//删除时不需要做任何检查</span><br><span class="line">git branch -D +分支名称 （不做任何检查的强制删除）</span><br></pre></td></tr></table></figure><h5 id="6、查看提交的历史信息"><a href="#6、查看提交的历史信息" class="headerlink" title="6、查看提交的历史信息"></a>6、查看提交的历史信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看提交的详细历史信息</span><br><span class="line">git log git log --graph --oneline (以图形化界面查看)</span><br><span class="line">//获取每条日志的简要信息</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">//查看本地的操作历史</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h5 id="7、配置SSH公钥"><a href="#7、配置SSH公钥" class="headerlink" title="7、配置SSH公钥"></a>7、配置SSH公钥</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//生成公钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">//获取公钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">//查看公钥是否添加成功</span><br><span class="line"> ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><h5 id="8、远程仓库的添加-x2F-推送-x2F-查看-x2F-删除-x2F-拉取"><a href="#8、远程仓库的添加-x2F-推送-x2F-查看-x2F-删除-x2F-拉取" class="headerlink" title="8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取"></a>8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//远程仓库的添加</span><br><span class="line">git remote add origin +(远程仓库地址)</span><br><span class="line">//远程仓库的查看</span><br><span class="line"> git remote</span><br><span class="line">//远程仓库的推送</span><br><span class="line"> git push origin master</span><br><span class="line"> git pull --rebase origin master（如果推送不成功使用这个）（保持远端和本地数据同步）</span><br><span class="line"> //与远端分支关系绑定</span><br><span class="line">  git push --set-upstream origin master:master （与远端关系绑定） （本地master） (远端master)</span><br><span class="line"> //删除指定远程分支</span><br><span class="line">  git push origin --delete master git push origin :master</span><br><span class="line"> //指定拉取分支</span><br><span class="line"> git pull origin master（如果pull出现冲突，可以版本回退和 封存修改，pull之后在还原）</span><br></pre></td></tr></table></figure><h5 id="9、查看本地分支与远程分支的对应关系"><a href="#9、查看本地分支与远程分支的对应关系" class="headerlink" title="9、查看本地分支与远程分支的对应关系"></a>9、查看本地分支与远程分支的对应关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h5 id="10、git克隆"><a href="#10、git克隆" class="headerlink" title="10、git克隆"></a>10、git克隆</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone + 克隆地址</span><br></pre></td></tr></table></figure><h5 id="11、git版本回退"><a href="#11、git版本回退" class="headerlink" title="11、git版本回退"></a>11、git版本回退</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//git 回退到你想要回退的版本号</span><br><span class="line">git reset --hard + 版本对应的id</span><br></pre></td></tr></table></figure><h5 id="12、强制拉取合并分支"><a href="#12、强制拉取合并分支" class="headerlink" title="12、强制拉取合并分支"></a>12、强制拉取合并分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h5 id="13、删除远程仓库"><a href="#13、删除远程仓库" class="headerlink" title="13、删除远程仓库"></a>13、删除远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin </span><br></pre></td></tr></table></figure><h5 id="14、创建远端仓库分支"><a href="#14、创建远端仓库分支" class="headerlink" title="14、创建远端仓库分支"></a>14、创建远端仓库分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin + 本地分支</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; class=&quot;headerlink&quot; title=&quot;git常用命令&quot;&gt;&lt;/a&gt;git常用命令&lt;/h2&gt;&lt;h5 id=&quot;1、单个文件加入缓存区&quot;&gt;&lt;a href=&quot;#1、单个文件加入缓存区&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>markdown使用说明</title>
    <link href="http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2022-08-25T15:17:46.000Z</published>
    <updated>2022-08-30T12:16:49.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="markdown-使用说明"><a href="#markdown-使用说明" class="headerlink" title="markdown 使用说明"></a>markdown 使用说明</h2><h4 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h4><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h4 id="标题的创建"><a href="#标题的创建" class="headerlink" title="标题的创建"></a>标题的创建</h4><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h4 id="如何改变文本的样式、"><a href="#如何改变文本的样式、" class="headerlink" title="如何改变文本的样式、"></a>如何改变文本的样式、</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*强调文本* _强调文本_</span><br><span class="line"></span><br><span class="line">**加粗文本** __加粗文本__</span><br><span class="line"></span><br><span class="line">==标记文本==</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br><span class="line"></span><br><span class="line">&gt; 引用文本</span><br><span class="line"></span><br><span class="line">H~2~O is是液体。</span><br><span class="line"></span><br><span class="line">2^10^ 运算结果是 1024.</span><br></pre></td></tr></table></figure><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h4 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: [link](https://www.csdn.net/).</span><br></pre></td></tr></table></figure><p>链接: <a href="https://www.csdn.net/">link</a>.</p><h4 id="生成列表"><a href="#生成列表" class="headerlink" title="生成列表"></a>生成列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 项目</span><br><span class="line">  - 项目</span><br><span class="line">    - 项目</span><br><span class="line"></span><br><span class="line">1. 项目1</span><br><span class="line">2. 项目2</span><br><span class="line">3. 项目3</span><br><span class="line"></span><br><span class="line">- [ ] 计划任务</span><br><span class="line">- [x] 完成任务</span><br></pre></td></tr></table></figure><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled type="checkbox"> 计划任务</li><li><input checked disabled type="checkbox"> 完成任务</li></ul><h4 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目     | Value</span><br><span class="line">-------- | -----</span><br><span class="line">电脑  | $1600</span><br><span class="line">手机  | $12</span><br><span class="line">导管  | $1</span><br></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h4 id="设定内容居中，居左，居右"><a href="#设定内容居中，居左，居右" class="headerlink" title="设定内容居中，居左，居右"></a>设定内容居中，居左，居右</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用`:---------:`居中</span><br><span class="line">使用`:----------`居左</span><br><span class="line">使用`----------:`居右</span><br><span class="line">| 第一列       | 第二列         | 第三列        |</span><br><span class="line">|:-----------:| :-------------:|:-------------|</span><br><span class="line">| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</span><br></pre></td></tr></table></figure><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="center">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="center">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h4 id="创建一个注脚"><a href="#创建一个注脚" class="headerlink" title="创建一个注脚"></a>创建一个注脚</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个具有注脚的文本。[^2]</span><br><span class="line"></span><br><span class="line">[^2]: 注脚的解释</span><br></pre></td></tr></table></figure><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^2</a></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这将产生一个流程图。:</span><br><span class="line"></span><br><span class="line">​```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;markdown-使用说明&quot;&gt;&lt;a href=&quot;#markdown-使用说明&quot; class=&quot;headerlink&quot; title=&quot;markdown 使用说明&quot;&gt;&lt;/a&gt;markdown 使用说明&lt;/h2&gt;&lt;h4 id=&quot;功能快捷键&quot;&gt;&lt;a href=&quot;#功能快捷</summary>
      
    
    
    
    
    <category term="md" scheme="http://example.com/tags/md/"/>
    
  </entry>
  
</feed>
