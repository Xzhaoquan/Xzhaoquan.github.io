<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>Siwat</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-28T14:25:14.636Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Napat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux应用编程-共享内存</title>
    <link href="http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</id>
    <published>2022-10-28T13:34:34.000Z</published>
    <updated>2022-10-28T14:25:14.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用开发-共享内存"><a href="#Linux应用开发-共享内存" class="headerlink" title="Linux应用开发-共享内存"></a>Linux应用开发-共享内存</h2><h4 id="共享内存的概念"><a href="#共享内存的概念" class="headerlink" title="共享内存的概念"></a>共享内存的概念</h4><h5 id="共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。"><a href="#共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。" class="headerlink" title="共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。"></a>共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。</h5><p><img src="/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/image-20221028214119485.png" alt="image-20221028214119485"></p><p>1、共享内存由以下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 共享内存是进程间通信中效率最高的方式之一。</span><br><span class="line">- 共享内存是系统出于多个进程之间通讯的考虑，而预留的的一块内存区，因此共享内存是以传输数据为目的的。</span><br><span class="line">- 共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</span><br><span class="line">- 共享内存无同步无互斥。</span><br></pre></td></tr></table></figure><p>2、共享内存的优缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 优点：使用共享内存进行进程间的通信非常方便，而且函数的接口也简单，数据的共享使</span><br><span class="line">进程间的数据不用传送，而是直接访问内存，加快了程序的效率。任意进程之间都可以对共享内存做读写操作。</span><br><span class="line">- 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往</span><br><span class="line">往要借助其他的手段（如信号量、互斥量等）来进行进程间的同步工作。</span><br></pre></td></tr></table></figure><h4 id="共享内存API函数"><a href="#共享内存API函数" class="headerlink" title="共享内存API函数"></a>共享内存API函数</h4><h5 id="创建共享内存函数"><a href="#创建共享内存函数" class="headerlink" title="创建共享内存函数"></a>创建共享内存函数</h5><p>shmget() 函数的创建或获取一个共享内存对象，并返回共享内存标识符。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">- key：标识共享内存的键值</span><br><span class="line">- size：共享内存大小，所有的内存分配操作都是以页为单位的，所以即使只申请只有一个字节的内存，内存也会分配整整一页。</span><br><span class="line">- shmflg：创建的共享内存的模式标志参数</span><br><span class="line">* IPC_CREAT：如果内核中不存在关键字与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符。</span><br><span class="line">* IPC_EXCL：如果内核中不存在键值与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存则报错。</span><br><span class="line">* SHM_HUGETLB：使用“大页面”来分配共享内存，所谓的“大页面”指的是内核为了提高程序性能，对内存实行分页管理时，采用比默认尺寸（4KB）更大的分页，以减少缺页中断。</span><br><span class="line">* SHM_NORESERVE：不在交换分区中为这块共享内存保留空间。</span><br><span class="line">返回值： shmget() 函数的返回值是共享内存的 ID。创建失败返回-1。</span><br><span class="line">错误代码：</span><br><span class="line">- EACCES：指定的消息队列已存在，但调用进程没有权限访问它</span><br><span class="line">- EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL 标志</span><br><span class="line">- EINVAL：创建共享内存时参数 size 小于 SHMMIN 或大于 SHMMAX。</span><br><span class="line">- ENFILE：已达到系统范围内打开文件总数的限制。</span><br><span class="line">- ENOENT：给定的 key 不存在任何共享内存，并且未指定 IPC_CREAT。</span><br><span class="line">- ENOMEM：内存不足，无法为共享内存分配内存。</span><br><span class="line">- EACCES：没有权限。</span><br></pre></td></tr></table></figure><h5 id="内存映射函数"><a href="#内存映射函数" class="headerlink" title="内存映射函数"></a>内存映射函数</h5><p>shmat() 映射函数  ，共享内存区对象映射到调用进程的地址空间  。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">- shmid：共享内存 ID，通常是由 shmget() 函数返回的。</span><br><span class="line">- shmaddr：如果不为 NULL，则系统会根据 shmaddr 来选择一个合适的内存区域，如果为NULL，则系统会自动选择一个合适的虚拟内存空间地址去映射共享内存。</span><br><span class="line">- shmflg：操作共享内存的方式：</span><br><span class="line">    * SHM_RDONLY：以只读方式映射共享内存。</span><br><span class="line">    * SHM_REMAP：重新映射，此时 shmaddr 不能为 NULL。</span><br><span class="line">    * NULLSHM：自动选择比 shmaddr 小的最大页对齐地址。</span><br><span class="line">shmat() 函数调用成功后返回共享内存的起始地址。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 共享内存只能以只读或者可读写方式映射，无法以只写方式映射。</span><br><span class="line">- shmat() 第二个参数 shmaddr 一般都设为 NULL，让系统自动找寻合适的地址。但当其确实</span><br><span class="line">不为空时，那么要求 SHM_RND 在 shmflg 必须被设置，这样的话系统将会选择比 shmaddr</span><br><span class="line">小而又最大的页对齐地址（即为 SHMLBA 的整数倍）作为共享内存区域的起始地址。如果</span><br><span class="line">没有设置 SHM_RND，那么 shmaddr 必须是严格的页对齐地址。</span><br></pre></td></tr></table></figure><h5 id="解除内存映射函数"><a href="#解除内存映射函数" class="headerlink" title="解除内存映射函数"></a>解除内存映射函数</h5><p>shmdt() 函数是用来解除进程与共享内存之间的映射的，在解除映射后，该进程不能再访问这个共享内存  。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">- shmaddr：映射的共享内存的起始地址。</span><br><span class="line"></span><br><span class="line">注意：该函数并不删除所指定的共享内存区，而只是将先前用 shmat() 函数映射好的共享内存脱离当前进程，共享内存还是存在于物理内存中。</span><br></pre></td></tr></table></figure><h5 id="获取或设置属性函数"><a href="#获取或设置属性函数" class="headerlink" title="获取或设置属性函数"></a>获取或设置属性函数</h5><p>shmctl() 用于获取或者设置共享内存的相关属性。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">- shmid：共享内存标识符。</span><br><span class="line">- cmd：函数功能的控制命令，其取值如下：</span><br><span class="line">    * IPC_STAT：获取属性信息，放置到 buf 中。</span><br><span class="line">    * IPC_SET：设置属性信息为 buf 指向的内容。</span><br><span class="line">    * IPC_RMID：删除这该共享内存。</span><br><span class="line">    * IPC_INFO：获得关于共享内存的系统限制值信息。</span><br><span class="line">    * SHM_INFO：获得系统为共享内存消耗的资源信息。</span><br><span class="line">    * SHM_STAT：与 IPC_STAT 具有相同的功能，但 shmid 为该 SHM 在内核中记录所有SHM 信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有 SHM 的相关信息。</span><br><span class="line">    * SHM_LOCK：禁止系统将该 SHM 交换至 swap 分区。</span><br><span class="line">    * SHM_UNLOCK：允许系统将该 SHM 交换至 swap 分。</span><br><span class="line">- 共享内存属性信息结构体指针（属性缓冲区）一般设为NULL</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用开发-共享内存&quot;&gt;&lt;a href=&quot;#Linux应用开发-共享内存&quot; class=&quot;headerlink&quot; title=&quot;Linux应用开发-共享内存&quot;&gt;&lt;/a&gt;Linux应用开发-共享内存&lt;/h2&gt;&lt;h4 id=&quot;共享内存的概念&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-IPC信号量</title>
    <link href="http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-IPC%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-IPC%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2022-10-28T12:30:16.000Z</published>
    <updated>2022-10-28T13:01:54.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-信号量"><a href="#Linux应用编程-信号量" class="headerlink" title="Linux应用编程-信号量"></a>Linux应用编程-信号量</h2><h4 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h4><h5 id="信号量的PV操作"><a href="#信号量的PV操作" class="headerlink" title="信号量的PV操作"></a>信号量的PV操作</h5><p>信号量只能进行两种操作：等待和发送信号，即 P 操作和 V 操作，锁行为就是 P 操作，解锁就是 V 操作，可以直接理解为 P 操作是申请资源， V 操作是释放资源。   </p><p>ipcs -l  查看ipc信息</p><p>信号量的P操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P 操作：如果有可用的资源（信号量值大于 0），则占用一个资源（给信号量值减去一，进</span><br><span class="line">入临界区代码） ; 如果没有可用的资源（信号量值等于 0），则阻塞，直到系统将资源分配</span><br><span class="line">给该进程（进入等待队列，一直等到资源轮到该进程）。</span><br></pre></td></tr></table></figure><p>信号量的V操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞的进程。如果</span><br><span class="line">没有进程等待它，则释放一个资源（给信号量值加一）。</span><br></pre></td></tr></table></figure><p>在信号量进行 PV 操作时都为原子操作（因为它需要保护临界资源）。  </p><p>原子操作：单指令的操作称为原子的，单条指令的执行是不会被打断的  </p><h4 id="IPC信号量函数"><a href="#IPC信号量函数" class="headerlink" title="IPC信号量函数"></a>IPC信号量函数</h4><h5 id="创建或获取一个信号量"><a href="#创建或获取一个信号量" class="headerlink" title="创建或获取一个信号量"></a>创建或获取一个信号量</h5><p>semget 函数的功能是创建或者获取一个已经创建的信号量，如果成功则返回对应的信号量标识符，失败则返回-1。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int semget(key_t key, int nsems, int semflg);</span><br><span class="line">- key：参数 key 用来标识系统内的信号量可以使用ftok函数创建或者是类似（key_t）123</span><br><span class="line">- nsems：参数用于在创建信号量的时候，表示可用的信号量数目。</span><br><span class="line">- semflg：参数用来指定标志位</span><br><span class="line">* PC_CREAT：IPC_CREAT 标志创建新的信号量，即使该信号量已经存在（具有同一个键值的信号量已在系统中存在），也不会出错。</span><br><span class="line">* IPC_EXCL：同时使用 IPC_EXCL 标志可以创建一个新的唯一的信号量，此时如果该信号量已经存在，该函数会返回出错。</span><br><span class="line">* mode：创建文件模式 0666</span><br><span class="line"></span><br><span class="line">创建信号量时，还受到以下系统信息的影响:</span><br><span class="line">• SEMMNI：系统中信号量总数的最大值。</span><br><span class="line">• SEMMSL：每个信号量中信号量元素个数的最大值。</span><br><span class="line">• SEMMNS：系统中所有信号量中的信号量元素总数的最大值。</span><br></pre></td></tr></table></figure><h4 id="信号量PV操作"><a href="#信号量PV操作" class="headerlink" title="信号量PV操作"></a>信号量PV操作</h4><h5 id="信号量的PV操作-1"><a href="#信号量的PV操作-1" class="headerlink" title="信号量的PV操作"></a>信号量的PV操作</h5><p>semop() 函数对信号量进行 PV 操作 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int semop(int semid, struct sembuf *sops, size_t nsops);</span><br><span class="line">- semid： System V 信号量的标识符，用来标识一个信号量</span><br><span class="line">- sops：指向一个 struct sembuf 结构体数组的指针，该数组是一个信号量操作数组</span><br><span class="line">struct sembuf</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short int sem_num; /* 信号量的序号从 0 ~ nsems-1 */</span><br><span class="line">        short int sem_op; /* 对信号量的操作， &gt;0, 0, &lt;0 */</span><br><span class="line">        short int sem_flg; /* 操作标识： 0， IPC_WAIT, SEM_UNDO */</span><br><span class="line">    &#125;;</span><br><span class="line">    * set_num：用于标识信号量中的第几个信号量， 0 表示第 1 个， 1 表示第 2 个， nsems -1表示最后一个。</span><br><span class="line">    * sem_op：sem_op 标识对信号量的所进行的操作类型</span><br><span class="line">    ~ sem_op &gt; 0 表示进程未使用或者使用完毕交回资源，表示信号量V(释放操作)，sem_op 的值加到该信号量的信号量当前值 semval</span><br><span class="line">    ~ sem_op &lt; 0 表示进程需要使用资源，表示信号量P操作（获取资源），当信号量当前值 semval 大于或者等于 -sem_op 时， semval 减掉 sem_op 的绝对值，为该进程分配对应数目的资源。</span><br><span class="line">    ~ sem_op = 0 表示进程要阻塞等待，直至信号量当前值 semval 变为 0</span><br><span class="line">    * sem_flg，信号量操作的属性标志</span><br><span class="line">        ~ IPC_NOWAIT 使对信号量的操作是非阻塞的，即指定了该标志，调用进程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将 errno 设置为 EAGAIN。</span><br><span class="line">        ~ SEM_UNDO 维护进程对信号量的调整值，进程退出的时候会自动还原它对信号量的操作</span><br><span class="line">        ~ 0 表示正常操作</span><br><span class="line">- nsops：表示上面 sops 数组的数量，如只有一个 sops 数组， nsops 就设置为 1</span><br></pre></td></tr></table></figure><h5 id="semctl属性函数"><a href="#semctl属性函数" class="headerlink" title="semctl属性函数"></a>semctl属性函数</h5><p>semctl 函数主要是对信号量集的一系列控制操作，根据操作命令 cmd 的不同，执行不同的操作，<br>第四个参数是可选的。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int semctl(int semid, int semnum, int cmd, ...);</span><br><span class="line">- semid： System V 信号量的标识符；</span><br><span class="line">- semnum：表示信号量集中的第 semnum 个信号量。它的取值范围： 0 ~ nsems-1 。</span><br><span class="line">- cmd：操作命令，主要有以下命令：</span><br><span class="line">    * IPC_STAT：获取此信号量集合的 semid_ds 结构，存放在第四个参数的 buf 中。</span><br><span class="line">    * IPC_SET：通过第四个参数的 buf 来设定信号量集相关联的 semid_ds 中信号量集合权限为 sem_perm 中的 uid， gid， mode。</span><br><span class="line">    * IPC_RMID：从系统中删除该信号量集合。</span><br><span class="line">    * GETVAL：返回第 semnum 个信号量的值。</span><br><span class="line">    * SETVAL：设置第 semnum 个信号量的值，该值由第四个参数中的 val 指定。</span><br><span class="line">    * GETPID：返回第 semnum 个信号量的 sempid，最后一个操作的 pid。</span><br><span class="line">    * GETNCNT：返回第 semnum 个信号量的 semncnt。等待 semval 变为大于当前值的线程数。</span><br><span class="line">    * GETZCNT：返回第 semnum 个信号量的 semzcnt。等待 semval 变为 0 的线程数。</span><br><span class="line">    * GETALL：去信号量集合中所有信号量的值，将结果存放到的 array 所指向的数组。</span><br><span class="line">    * SETALL：按 arg.array 所指向的数组中的值，设置集合中所有信号量的值。</span><br><span class="line">- 第四个参数是可选的：如果使用该参数，该参数的类型为 union semun，它是多个特定命令的联合体</span><br><span class="line">union semun &#123;</span><br><span class="line">        int val; /* Value for SETVAL */</span><br><span class="line">        struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */</span><br><span class="line">        unsigned short *array; /* Array for GETALL, SETALL */</span><br><span class="line">        struct seminfo *__buf; /* Buffer for IPC_INFO</span><br><span class="line">        (Linux-specific) */</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-信号量&quot;&gt;&lt;a href=&quot;#Linux应用编程-信号量&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-信号量&quot;&gt;&lt;/a&gt;Linux应用编程-信号量&lt;/h2&gt;&lt;h4 id=&quot;信号量的工作原理&quot;&gt;&lt;a href=&quot;#信</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-消息队列</title>
    <link href="http://example.com/2022/10/27/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/10/27/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2022-10-27T13:54:25.000Z</published>
    <updated>2022-10-27T14:45:44.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-消息队列"><a href="#Linux应用编程-消息队列" class="headerlink" title="Linux应用编程-消息队列"></a>Linux应用编程-消息队列</h2><h5 id="消息队列的基本概念"><a href="#消息队列的基本概念" class="headerlink" title="消息队列的基本概念"></a>消息队列的基本概念</h5><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。  </p><p>消息队列特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 在消息队列中，发送数据用 msgsnd()，接收数据用msgrcv()，消息队列对每个数据都有一个最大长度的限制。</span><br><span class="line">- 消息队列也可以独立于发送和接收进程而存在，在进程终止时，消息队列及其内容并不会被删除。</span><br><span class="line">- 消息队列提供有格式的字节流。</span><br><span class="line">- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级，接收程序可以通过消息类型有选择地接收数据</span><br><span class="line">- 消息队列可以实现消息的随机查询，消息不一定要以先进先出的顺序接收，也可以按消息的类型接收。</span><br></pre></td></tr></table></figure><h5 id="消息队列API函数"><a href="#消息队列API函数" class="headerlink" title="消息队列API函数"></a>消息队列API函数</h5><ul><li><p>创建或打开消息队列API函数msgget()  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msgget() 函数创建的消息队列的数量会受到系统可支持的消息队列数量的限制；</span><br><span class="line">msgget() 函数的作用是创建或获取一个消息队列对象，并返回消息队列标识符。</span><br><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">- key：消息队列的关键字值，多个进程可以通过它访问同一个消息队列。可通过ftok函数创建</span><br><span class="line">• key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">* path：合法路径</span><br><span class="line">* proj_id：一个整数</span><br><span class="line">- msgflg：表示创建的消息队列的标志参数</span><br><span class="line">•  IPC_CREAT</span><br><span class="line">•  IPC_EXCL</span><br><span class="line">•  mode</span><br><span class="line">这些参数是可以通过“｜”运算符联合起来的，因为它始终是 int 类型的参数。如 msgflag使用参数 IPC_CREAT | 0666 时表示，创建或返回已经存在的消息队列的标识符，且该消息队列的存取权限为0666。</span><br><span class="line">如果是 IPC_CREAT 为真表示：如果内核中不存在关键字与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符。</span><br><span class="line">而如果为 IPC_CREAT | IPC_EXCL 表示如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错。</span><br><span class="line">mode 指 IPC 对象存取权限，它使用 Linux 文件的数字权限表示方式，如 0600， 0666等。</span><br><span class="line"></span><br><span class="line">返回值： 成功返回队列表示符，失败返回 -1</span><br><span class="line">记录在error中的错误代码：</span><br><span class="line">– EACCES：指定的消息队列已存在，但调用进程没有权限访问它</span><br><span class="line">– EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL标志</span><br><span class="line">– ENOENT： key 指定的消息队列不存在同时 msgflg 中没有指定 IPC_CREAT 标志</span><br><span class="line">– ENOMEM：需要建立消息队列，但内存不足</span><br><span class="line">– ENOSPC：需要建立消息队列，但已达到系统的限制</span><br><span class="line"></span><br><span class="line">注意：当 key 被指定为 IPC_PRIVATE 时，系统会自动产生一个未用的 key 来对应一个新的消息队列对象，这个消息队列一般用于进程内部间的通信。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>发送消息使用的API函数是 msgsnd() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msgsnd() 函数把消息发送到已打开的消息队列末尾;  </span><br><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span><br><span class="line">- msqid：消息队列标识符。</span><br><span class="line">- msgp：消息队列结构体，msgp 可以是任何类型的结构体，但第一个字段必须为 long 类型。</span><br><span class="line">• struct s_msg&#123;</span><br><span class="line">        long type; /* 必须大于 0, 消息类型 */</span><br><span class="line">        char mtext[１ ]; /* 消息正文，可以是其他任何类型 */</span><br><span class="line">      &#125; msgp;</span><br><span class="line">– msgsz：要发送消息的大小，不包含消息类型占用的 4 个字节，即 mtext 的长度。</span><br><span class="line">- msgflg：消息队列标志位参数</span><br><span class="line">• 0：当消息队列满时， msgsnd() 函数将会阻塞，直到消息能写进消息队列；</span><br><span class="line">• IPC_NOWAIT：当消息队列已满的时候， msgsnd() 函数不等待立即返回；</span><br><span class="line">• IPC_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。</span><br><span class="line">返回值：成功返回0，失败返回-1</span><br><span class="line">记录在error中的错误代码：</span><br><span class="line">– EAGAIN：参数 msgflg 设为 IPC_NOWAIT，而消息队列已满。</span><br><span class="line">– EIDRM：标识符为 msqid 的消息队列已被删除。</span><br><span class="line">– EACCESS：无权限写入消息队列。</span><br><span class="line">– EFAULT：参数 msgp 指向无效的内存地址。</span><br><span class="line">– EINTR：队列已满而处于等待情况下被信号中断。</span><br><span class="line">– EINVAL：无效的参数 msqid、 msgsz 或参数消息类型 type 小于 0。</span><br><span class="line"></span><br><span class="line">msgsnd() 解除阻塞的条件有以下三个条件：</span><br><span class="line">- 消息队列中有容纳该消息的空间。</span><br><span class="line">- msqid 代表的消息队列被删除。</span><br><span class="line">- 调用 msgsnd 函数的进程被信号中断。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接收消息使用的API函数是 msgrcv()  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">msgrcv() 函数是从标识符为 msqid 的消息队列读取消息并将消息存储到 msgp 中，读取后把此消息从消息队列中删除.</span><br><span class="line">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int␣,msgflg);</span><br><span class="line">msqid：消息队列标识符。</span><br><span class="line">- msgp：存放消息的结构体，结构体类型要与 msgsnd() 函数发送的类型相同。</span><br><span class="line">- msgsz：要接收消息的大小，不包含消息类型占用的 4 个字节。</span><br><span class="line">- msgtyp 有多个可选的值：如果为 0 则表示接收第一个消息，如果大于 0 则表示接收类型等于 msgtyp 的第一个消息，而如果小于 0 则表示接收类型等于或者小于 msgtyp 绝对值的第一个消息。</span><br><span class="line">- msgflg 用于设置接收的处理方式，取值情况如下：</span><br><span class="line">    • IPC_EXCEPT：与 msgtype 配合使用返回队列中第一个类型不为 msgtype 的消息</span><br><span class="line">    • IPC_NOWAIT：若在消息队列中并没有相应类型的消息可以接收，则函数立即返回，此时错误码为 ENOMSG</span><br><span class="line">    • 0: 阻塞式接收消息，没有该类型的消息 msgrcv 函数一直阻塞等待</span><br><span class="line">    • IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃</span><br><span class="line">返回值： msgrcv() 函数如果接收消息成功则返回实际读取到的消息数据长度，否则返回-1</span><br><span class="line">错误代码：存放在error中</span><br><span class="line">– E2BIG：消息数据长度大于 msgsz 而 msgflag 没有设置 IPC_NOERROR</span><br><span class="line">– EIDRM：标识符为 msqid 的消息队列已被删除</span><br><span class="line">– EACCESS：无权限读取该消息队列</span><br><span class="line">– EFAULT：参数 msgp 指向无效的内存地址</span><br><span class="line">– ENOMSG：参数 msgflg 设为 IPC_NOWAIT，而消息队列中无消息可读</span><br><span class="line">– EINTR：等待读取队列内的消息情况下被信号中断</span><br><span class="line"></span><br><span class="line">msgrcv() 函数解除阻塞的条件也有三个：</span><br><span class="line">- 消息队列中有了满足条件的消息。</span><br><span class="line">- msqid 代表的消息队列被删除。</span><br><span class="line">- 调用 msgrcv() 函数的进程被信号中断。</span><br></pre></td></tr></table></figure></li><li><p>控制消息队列使用的APIs函数是 msgctl()  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">消息队列是可以被用户操作的，比如设置或者获取消息队列的相关属性，那么可以通过 msgctl()函数去处理它。</span><br><span class="line">int msgctl(int msqid, int cmd, struct msqid_ds *buf);</span><br><span class="line">- msqid：消息队列标识符。</span><br><span class="line">- cmd 用于设置使用什么操作命令</span><br><span class="line">    • IPC_SET 设置消息队列的属性，要设置的属性需先存储在结构体 msqid_ds 类型的 buf中，可设置的属性包括： msg_perm.uid、 msg_perm.gid、 msg_perm.mode 以及 msg_qbytes，储存在结构msqid_ds 中。</span><br><span class="line">    • IPC_RMID 立即删除该 MSG，并且唤醒所有阻塞在该 MSG 上的进程，同时忽略第三个参数。</span><br><span class="line">    • IPC_STAT 获取该 MSG 的信息，获取到的信息会储存在结构体 msqid_ds 类型的 buf 中。</span><br><span class="line">    • IPC_INFO 获得关于当前系统中 MSG 的限制值信息。</span><br><span class="line">    • MSG_INFO 获得关于当前系统中 MSG 的相关资源消耗信息。</span><br><span class="line">    • MSG_STAT 同 IPC_STAT，但 msgid 为该消息队列在内核中记录所有消息队列信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有消息队列的相关信息。</span><br><span class="line">- buf：相关信息结构体缓冲区。</span><br><span class="line">    • 返回值：</span><br><span class="line">    • 成功： 0</span><br><span class="line">    • 出错： -1</span><br><span class="line">错误代码：</span><br><span class="line">- EACCESS：参数 cmd 为 IPC_STAT，确无权限读取该消息队列。</span><br><span class="line">- EFAULT：参数 buf 指向无效的内存地址。</span><br><span class="line">- EIDRM：标识符为 msqid 的消息队列已被删除。</span><br><span class="line">- EINVAL：无效的参数 cmd 或 msqid。</span><br><span class="line">- EPERM：参数 cmd 为 IPC_SET 或 IPC_RMID，却无足够的权限执行。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-消息队列&quot;&gt;&lt;a href=&quot;#Linux应用编程-消息队列&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-消息队列&quot;&gt;&lt;/a&gt;Linux应用编程-消息队列&lt;/h2&gt;&lt;h5 id=&quot;消息队列的基本概念&quot;&gt;&lt;a hre</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-管道</title>
    <link href="http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E7%AE%A1%E9%81%93/"/>
    <id>http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E7%AE%A1%E9%81%93/</id>
    <published>2022-10-26T15:39:05.000Z</published>
    <updated>2022-10-27T13:53:01.917Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-管道"><a href="#Linux应用编程-管道" class="headerlink" title="Linux应用编程-管道"></a>Linux应用编程-管道</h2><h4 id="管道分类"><a href="#管道分类" class="headerlink" title="管道分类"></a>管道分类</h4><h5 id="匿名管道（父子之间进行通信）"><a href="#匿名管道（父子之间进行通信）" class="headerlink" title="匿名管道（父子之间进行通信）"></a>匿名管道（父子之间进行通信）</h5><p>匿名管道：特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后 fork 产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的. 匿名管道没有名字，一般进程无法使用 open() 来获取他的描述符  ，所以匿名管道只能用于亲缘关系进程间通信  。</p><p>匿名管道有以下特征：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• 没有名字，因此不能使用 open() 函数打开，但可以使用 close() 函数关闭。</span><br><span class="line">• 只提供单向通信（半双工），也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。</span><br><span class="line">• 只能用于具有血缘关系的进程间通信，通常用于父子进程建通信。</span><br><span class="line">• 管道是基于字节流来通信的。</span><br><span class="line">• 依赖于文件系统，它的生命周期随进程的结束而结束。</span><br><span class="line">• 写入操作不具有原子性，因此只能用于一对一的简单通信情形。</span><br><span class="line">• 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read() 和 write() 等函数。但是它又不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中，因此不能使用 lseek() 来定位。</span><br></pre></td></tr></table></figure><h5 id="pipe函数（所有进程间通信）"><a href="#pipe函数（所有进程间通信）" class="headerlink" title="pipe函数（所有进程间通信）"></a>pipe函数（所有进程间通信）</h5><p>pipe() 函数用于创建一个匿名管道，一个可用于进程间通信的单向数据通道。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">pipefd[0] 指管道的读取端， pipefd[1]指向管道的写端</span><br><span class="line">pipe函数返回 0 表示创建匿名管道成功 返回 -1 创建失败</span><br></pre></td></tr></table></figure><p>创建匿名管道需要一下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• 父进程调用 pipe() 函数创建匿名管道，得到两个文件描述符 pipefd[0]、 pipefd[1]，分别指向管道的读取端和写入端。</span><br><span class="line">• 父进程调用 fork() 函数启动（创建）一个子进程，那么子进程将从父进程中继承这两个文件描述符 pipefd[0]、 pipefd[1]，它们指向同一匿名管道的读取端与写入端。</span><br><span class="line">• 由于匿名管道是利用环形队列实现的，数据将从写入端流入管道，从读取端流出，这样子就实现了进程间通信，但是这个匿名管道此时有两个读取端与两个写入端，因此需要进行接下来的操作。</span><br><span class="line">• 如果想要从父进程将数据传递给子进程，则父进程需要关闭读取端，子进程关闭写入端，如图数据从父进程流向子进程 所示。</span><br><span class="line">• 如果想要从子进程将数据传递给父进程，则父进程需要关闭写入端，子进程关闭读取端，如图数据从子进程流向父进程 所示。</span><br><span class="line">• 当不需要管道的时候，就在进程中将未关闭的一端关闭即可。</span><br></pre></td></tr></table></figure><h5 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5><p>命名管道：</p><p>命名管道可以在多个无关的进程中交换数据（通信） .</p><p>命名管道一下特征：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• 有名字，存储于普通文件系统之中。</span><br><span class="line">• 任何具有相应权限的进程都可以使用 open() 来获取命名管道的文件描述符。</span><br><span class="line">• 跟普通文件一样：使用统一的 read()/write() 来读写。</span><br><span class="line">• 跟普通文件不同：不能使用 lseek() 来定位，原因是数据存储于内存中。</span><br><span class="line">• 具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。</span><br><span class="line">• 遵循先进先出（First In First Out）原则，最先被写入 FIFO 的数据，最先被读出来。</span><br></pre></td></tr></table></figure><p>mkfifo函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char * pathname,mode_t mode);</span><br><span class="line">- pathname 需要创建的FIFO文件名</span><br><span class="line">- mode mode模式及权限参数说明</span><br><span class="line">    • O_WRONLY：写管道。</span><br><span class="line">    • O_RDONLY：读管道。</span><br><span class="line">    • O_RDWR：读写管道。</span><br><span class="line">    • O_NONBLOCK：非阻塞。</span><br><span class="line">    • O_CREAT：如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。</span><br><span class="line">    • O_EXCL：如果使用 O_CREAT 时文件存在，那么可返回错误消息。这一参数可测试文件是否存在。</span><br><span class="line">返回值说明如下：</span><br><span class="line">    • 0：成功</span><br><span class="line">    • EACCESS：参数 filename 所指定的目录路径无可执行的权限。</span><br><span class="line">    • EEXIST：参数 filename 所指定的文件已存在。</span><br><span class="line">    • ENAMETOOLONG：参数 filename 的路径名称太长。</span><br><span class="line">    • ENOENT：参数 filename 包含的目录不存在。</span><br><span class="line">    • ENOSPC：文件系统的剩余空间不足。</span><br><span class="line">    • ENOTDIR：参数 filename 路径中的目录存在但却非真正的目录。</span><br><span class="line">    • EROFS：参数 filename 指定的文件存在于只读文件系统内。</span><br><span class="line">mkfifo() 会根据参数 pathname 建立特殊的 FIFO 文件，而参数 mode 为该文件的模式与权限。</span><br><span class="line">对FIFO进行读操作：</span><br><span class="line">-阻塞类型的管道 管道内有数据就读取，没有数据就阻塞在那里</span><br><span class="line">-非阻塞类型的管道 不论 FIFO 内是否有数据，读进程都会立即执行读操作，管道内没有数据返回0</span><br><span class="line">对FIFO进行写操作：</span><br><span class="line">-阻塞类型的管道 写操作将一直阻塞到数据可以被写入。</span><br><span class="line">-非阻塞类型的管道 不能写入全部数据，则写操作进行部分写入或者调用失败。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>access函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">检查调用进程是否可以对指定的文件执行某种操作。</span><br><span class="line">int access(const char* pathname, int mode);</span><br><span class="line">- pathname 是文件的路径名+文件名</span><br><span class="line">- mode：指定access的作用，取值如下</span><br><span class="line">    • F_OK 值为0，判断文件是否存在 </span><br><span class="line">    • X_OK 值为1，判断对文件是可执行权限 </span><br><span class="line">    • W_OK 值为2，判断对文件是否有写权限 </span><br><span class="line">    • R_OK 值为4，判断对文件是否有读权限</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-管道&quot;&gt;&lt;a href=&quot;#Linux应用编程-管道&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-管道&quot;&gt;&lt;/a&gt;Linux应用编程-管道&lt;/h2&gt;&lt;h4 id=&quot;管道分类&quot;&gt;&lt;a href=&quot;#管道分类&quot; cla</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-信号</title>
    <link href="http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/"/>
    <id>http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/</id>
    <published>2022-10-26T12:54:06.000Z</published>
    <updated>2022-10-27T13:51:45.081Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-信号"><a href="#Linux应用编程-信号" class="headerlink" title="Linux应用编程-信号"></a>Linux应用编程-信号</h2><h5 id="Linux系统支持的信号"><a href="#Linux系统支持的信号" class="headerlink" title="Linux系统支持的信号"></a>Linux系统支持的信号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用kill -l查看信号</span><br><span class="line">信号分类：</span><br><span class="line">- 信号值为1-31的信号属于非实时信号（不可靠信号）（不支持排队处理）</span><br><span class="line">- 信号值为34-64的信号为实时信号 （可靠信号）（支持排队处理）</span><br><span class="line"></span><br><span class="line">以下是常用的一些信号：</span><br><span class="line">SIGHUP 1 关闭终端 终止 </span><br><span class="line">SIGINT 2 ctrl+c 终止 </span><br><span class="line">SIGQUIT 3 ctrl+\ 终止+转储 </span><br><span class="line">SIGABRT 6 abort() 停止+转储 </span><br><span class="line">SIGPE 8 算术错误 终止 </span><br><span class="line">SIGKILL 9 kill -9 pid 终止，不可捕获/忽略 </span><br><span class="line">SIGUSR1 10 自定义 忽略 </span><br><span class="line">SIGSEGV 11 段错误 终止+转储 </span><br><span class="line">SIGUSR2 12 自定义 忽略 </span><br><span class="line">SIGALRM 14 alarm() 终止 </span><br><span class="line">SIGTERM 15 kill pid 终止 </span><br><span class="line">SIGCHLD 17 (子)状态变化 忽略 </span><br><span class="line">SIGTOP 19 ctrl+z 暂停，不可忽略/捕获</span><br><span class="line"></span><br><span class="line">使用kill或者是pkill可以杀死进程</span><br><span class="line">• kill + pid 或者 kill + -9 + pid</span><br><span class="line">• pkill + 需要杀死的进程名称</span><br></pre></td></tr></table></figure><h5 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h5><p>信号的处理方式（实时信号 非实时信号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 忽略信号</span><br><span class="line">- 捕捉信号</span><br><span class="line">- 让信号默认动作起作用</span><br></pre></td></tr></table></figure><h5 id="信号API函数"><a href="#信号API函数" class="headerlink" title="信号API函数"></a>信号API函数</h5><p>捕获信号API函数：</p><ul><li>signal函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//signal函数</span><br><span class="line">typedef void (*sighandler_t)(int); //信号处理函数</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler); //signal 捕获函数</span><br><span class="line">- signum 指定捕获的信号</span><br><span class="line">- handler 用户处理信号的方式</span><br><span class="line">• SIG_IGN 忽略该信号</span><br><span class="line">• SIG_DFL 采用系统默认方式处理信号</span><br><span class="line">• 使用信号处理函数void sighandler_t(int);</span><br><span class="line">返回值：成功 上一次设置的handler 失败SIG_ERR</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>sigaction函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//sigaction函数</span><br><span class="line">struct sigaction &#123;</span><br><span class="line">    void (*sa_handler)(int); 是捕获信号后的处理函数</span><br><span class="line">    void (*sa_sigaction)(int, siginfo_t *, void *); 是扩展信号处理函数</span><br><span class="line">    sigset_t sa_mask; 是信号掩码 它指定了在执行信号处理函数期间阻塞的信号的掩码，被设置</span><br><span class="line">                      在该掩码中的信号，在进程响应信号期间被临时阻塞。除非使用 SA_NODEFER 标志</span><br><span class="line">                      否则即使是当前正在处理的响应的信号再次到来的时候也会被阻塞。</span><br><span class="line">    int sa_flags; 系列用于修改信号处理过程行为的标志</span><br><span class="line">    void (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br><span class="line">sa_flags：</span><br><span class="line">- SA_NOCLDSTOP 如果 signum 是 SIGCHLD，则在子进程停止或恢复时，不会传信号给调用 sigaction() 函数的进程。</span><br><span class="line">- SA_NOCLDWAIT 它表示父进程在它的子进程终止时不会收到 SIGCHLD 信号，这时子进程终止则不会成为僵尸进程。</span><br><span class="line">- SA_NODEFER 不要阻止从其自身的信号处理程序中接收信号，使进程对信号的屏蔽无效，即在信号处理函数执行期间仍能接收这个信号</span><br><span class="line">- SA_RESETHAND 信号处理之后重新设置为默认的处理方式。</span><br><span class="line">- SA_SIGINFO 指示使用 sa_sigaction 成员而不是使用 sa_handler 成员作为信号处理函数</span><br><span class="line"></span><br><span class="line">int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span><br><span class="line">- signum :指定捕获的信号</span><br><span class="line">- act :struct sigaction类型的结构体</span><br><span class="line">- oldact :返回原有的信号处理参数，一般设置为 NULL 即可。</span><br></pre></td></tr></table></figure><p>发送信号API函数：</p><ul><li>kill函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kill函数向包括它本身在内的其他进程发送一个信号</span><br><span class="line">int kill(pid_t pid,int sig);</span><br><span class="line">- pid :pid取值</span><br><span class="line">    • pid &gt; 1：将信号 sig 发送到进程 ID 值为 pid 指定的进程。</span><br><span class="line">    • pid = 0：信号被发送到所有和当前进程在同一个进程组的进程。</span><br><span class="line">    • pid = -1：将 sig 发送到系统中所有的进程，但进程 1（init）除外。</span><br><span class="line">    • pid &lt; -1：将信号 sig 发送给进程组号为-pid （pid 绝对值）的每一个进程。</span><br><span class="line">- sig :发送的信号值</span><br><span class="line">-函数返回值：0 成功 1失败</span><br></pre></td></tr></table></figure><ul><li>raise函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">raise() 函数只是进程向自身发送信号的，而没有向其他进程发送信号.给当前进程发送指定信号（自己给自己发信号）</span><br><span class="line">kill(getpid(),sig) 等同于 raise(sig)</span><br><span class="line">int raise(int sig);</span><br><span class="line">函数只有一个参数 sig，它代表着发送的信号值，如果发送成功则返回 0，发送失败则返回-1</span><br></pre></td></tr></table></figure><ul><li>alarm函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alarm() 也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间 seconds 到时，它就向进程发送 SIGALRM 信号。</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">如果在 seconds 秒内再次调用了 alarm() 函数设置了新的闹钟，则新的设置将覆盖前面的设置，即之前设置的秒数被新的闹钟时间取代。它的返回值是之前闹钟的剩余秒数，如果之前未设闹钟则返回 0。</span><br></pre></td></tr></table></figure><h5 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h5><ul><li><p>屏蔽信号集：屏蔽某些信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手动去调用信号集函数</span><br><span class="line">- 某些场景系统自动取设置信号集</span><br></pre></td></tr></table></figure></li><li><p>未处理信号集：如果信号集被屏蔽，则记录在未处理信号集中，直到屏蔽信号集解除对信号的屏蔽才会去处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 非实时信号（1-31）：不排队，只留一个（不管来多少信号，只保留最近的一个信号，其他信号全部丢掉）</span><br><span class="line">- 实时信号（34-64）：排队，保留全部信号</span><br></pre></td></tr></table></figure></li><li><p>信号集相关API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sigemptyset(sigset_t *set); //将信号集合初始化为0函数 不屏蔽信号</span><br><span class="line">int sigfillset(sigset_t *set); //将信号集合初始化为1函数 屏蔽信号</span><br><span class="line">int sigaddset(sigset_t *set); //将信号集合某一位设置为1</span><br><span class="line">int sigdelset(sigset_t *set); //将信号集合某一位设置为0</span><br><span class="line">int sigismember(const sigset_t *set, int signum); //判断某信号是否在屏蔽信号集里面</span><br><span class="line">//该函数可以根据参数指定的方法修改进程的信号屏蔽字</span><br><span class="line">//将屏蔽信号赋值给屏蔽信号集</span><br><span class="line">int sigprocmask(int how, const old_kernel_sigset_t *set,old_kernel_sigset_t *oldset);</span><br><span class="line">- how：</span><br><span class="line">    •  SIG_BLOCK:屏蔽某个信号，添加的信号屏蔽字不覆盖之前的，这是一个并集的关系（屏蔽集 |set ）</span><br><span class="line">    •  SIG_UNBLOCK:希望解除BLOCK的信号集合。解除信号集的屏蔽（屏蔽集 &amp;~ set）</span><br><span class="line">    •  SIG_SETMASK:该进程的信号屏蔽是set指向的值。（直接等于我们设置的信号集合）</span><br><span class="line">- set：需要传入的屏蔽信号集</span><br><span class="line">- oldset：保存旧的屏蔽集的值，NULL表示不保存</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-信号&quot;&gt;&lt;a href=&quot;#Linux应用编程-信号&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-信号&quot;&gt;&lt;/a&gt;Linux应用编程-信号&lt;/h2&gt;&lt;h5 id=&quot;Linux系统支持的信号&quot;&gt;&lt;a href=&quot;#L</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-进程</title>
    <link href="http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-10-25T14:48:47.000Z</published>
    <updated>2022-10-26T12:52:00.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-进程"><a href="#Linux应用编程-进程" class="headerlink" title="Linux应用编程-进程"></a>Linux应用编程-进程</h2><h5 id="fork-进程函数："><a href="#fork-进程函数：" class="headerlink" title="fork()进程函数："></a>fork()进程函数：</h5><p>fork()进程函数用于从一个已存在的进程中去启动一个新进程，新进程成为子进程，原来的进程称为父进程。fork()函数的本质是直接将父进程的内容复制一份，但是子进程与父进程也有不一样的地方。</p><p>子进程与父进程相同的内容：</p><ul><li>进程的地址空间</li><li>进程上下文，代码段</li><li>进程的堆栈空间，和内存信息</li><li>进程的环境变量，标准的IO缓冲区</li><li>打开的文件描述符，信号响应函数，当前的工作路劲</li></ul><p>子进程独有的内容：</p><ul><li>子进程的进程号PID，PID是进程的唯一的标识符</li><li>记录锁，父进程对某文件加锁，子进程不会继承这把锁</li><li>挂起信号，父进程的响应但未处理的信号，子进程不会继承</li></ul><p><img src="/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20221025225022643.png" alt="image-20221025225022643"></p><p>fork函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line"></span><br><span class="line">fork函数启动成功：父进程会返回子进程的pid,子进程返回0，</span><br><span class="line">启动失败：返回-1</span><br><span class="line"></span><br><span class="line">pid_t getpid(void);函数会返回当前进程pid</span><br><span class="line">pid_t getppid(void);函数会返回当前进程的父进程pid</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="exec系列进程替换函数"><a href="#exec系列进程替换函数" class="headerlink" title="exec系列进程替换函数"></a>exec系列进程替换函数</h5><p>exec系列函数用于替换进程的执行程序，它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换  </p><p>exec系列函数介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ...)</span><br><span class="line">int execlp(const char *file, const char *arg, ...)</span><br><span class="line">int execle(const char *path, const char *arg, ..., char *const envp[])</span><br><span class="line">int execv(const char *path, char *const argv[])</span><br><span class="line">int execvp(const char *file, char *const argv[])</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">这些函数可以分为两大类execl、execlp和execle传递给子程序的参数个数是可变的。 execv、 execvp 和 execve 通过数组去装载子程序的参数，无论那种形式，参数都以一个空指针 NULL 结束.</span><br><span class="line">l----list 列表</span><br><span class="line">v----vector 数组</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">const char *path:该参数需要输入文件路径，例如：&quot;/bin/ls&quot; &quot;/bin/pwd&quot;</span><br><span class="line">const char *file:该参数需要输入需要执行的应用程序名字，例如：&quot;ls&quot; &quot;pwd&quot;</span><br><span class="line">const char *arg:该参数需要输入对应字符，例如：&quot;ls&quot;,&quot;-al&quot;,NULL &quot;pwd&quot;,NULL</span><br><span class="line">const char *agrv[]:该参数需要输入对应数组指针：例如：char *argv[]=&#123;&quot;pwd&quot;,NULL&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">！！注意：exec 系列函数是直接将当前进程给替换掉的，当调用 exec 系列函数后，当前进程将不会</span><br><span class="line">再继续执行，</span><br></pre></td></tr></table></figure><p>execl函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ... )</span><br><span class="line">path:指定文件路径</span><br><span class="line">arg：执行文件所传递的参数 arg[0],arg[1]...arg[n],最后一个参数必须是NULL做结束标志</span><br><span class="line"></span><br><span class="line">该函数一般不会返回，除非遇到错误会返回-1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>execv函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int execv(const char *path, char *const argv[])</span><br><span class="line">path:指定文件路径</span><br><span class="line">argv：执行文件所传递的参数是一个数组指针,最后一个参数必须是NULL做结束标志</span><br><span class="line"></span><br><span class="line">该函数一般不会返回，除非遇到错误会返回-1</span><br></pre></td></tr></table></figure><h5 id="进程的生老病死"><a href="#进程的生老病死" class="headerlink" title="进程的生老病死"></a>进程的生老病死</h5><p><img src="/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20221025230037584.png" alt="image-20221025230037584"></p><h5 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h5><ul><li><p>正常终止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-main 函数返回</span><br><span class="line">-调用_exit()函数终止</span><br><span class="line">-调用exit()函数终止</span><br></pre></td></tr></table></figure></li><li><p>异常终止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-调用abort()函数异常终止</span><br><span class="line">-又系统信号终止 </span><br></pre></td></tr></table></figure></li></ul><p>exit函数和_exit()函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void _exit(int status);</span><br><span class="line">void exit(int status);</span><br><span class="line">传入一个status保存进程终止时的状态码</span><br></pre></td></tr></table></figure><p>exit()函数和_exit()函数的异同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit() 和 _exit() 函数都是用来终止进程的，当程序执行到 exit() 或 _exit() 函数时，进程会无条件地停止剩下的所有操作，清除包括 PCB 在内的各种数据结构，并终止当前进程的运行。</span><br><span class="line"></span><br><span class="line">_exit() 函数:直接通过系统调用使进程终止运行,清除这个进程使用的内存空间，并销毁它在内核中的各种数据结构.</span><br><span class="line">exit() 函数是_exit()函数包装来的。在执行_exit()函数之前，需要清除&quot;IO缓冲区&quot;，有效的保存数据的完整性。</span><br><span class="line">清清除&quot;IO缓冲区&quot;是检查文件的打开情况，把文件缓冲区中的内容写回文件</span><br></pre></td></tr></table></figure><h5 id="等待进程"><a href="#等待进程" class="headerlink" title="等待进程"></a>等待进程</h5><p>当一个进程调用了exit()函数之后，该进程并不会直接消失，而是会变成僵尸进程。需要等待其父进程去回收僵尸进程，需要调用waitpid()或者wait()函数去回收僵尸进程并且，释放僵尸进程占有的内存空间，和了解进程终止的状态信息。调用wait函数会阻塞父进程。</p><p>wait函数和waitpid函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//wait函数</span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">调用wait函数之后 调用成功：返回子进程pid，和进程退出状态</span><br><span class="line">失败:返回-1</span><br><span class="line"></span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">pid: 欲等待的子进程的识别码。</span><br><span class="line">• pid&lt;-1等待进程组号为pid绝对值的任何子进程。</span><br><span class="line">• pid&gt;0等待进程号为pid的子进程。</span><br><span class="line">• pid=-1等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。</span><br><span class="line">• pid=0等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。</span><br><span class="line">wstatus：返回的状态值</span><br><span class="line">options：控制waitpid()函数的行为，如果不想使用这些选项，则可以把这个参数设为0。</span><br><span class="line">• WNOHANG如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这个函数上等待；如果结束了，则返回该子进程的进程号。</span><br><span class="line">• WUNTRACED如果子进程进入暂停状态，则马上返回。</span><br><span class="line"></span><br><span class="line">调用wait函数之后 调用成功：返回子进程pid，和进程退出状态</span><br><span class="line">失败:返回-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//waitpid函数</span><br><span class="line">如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；</span><br><span class="line">但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</span><br><span class="line"></span><br><span class="line">waitpid(-1,&amp;status,0) = wait(&amp;status)</span><br><span class="line"></span><br><span class="line">//wait和waitpid函数调用之后返回 wstatus 的值</span><br><span class="line">• WIFEXITED(status) ：如果子进程正常结束，返回一个非零值</span><br><span class="line">• WEXITSTATUS(status)：如果 WIFEXITED 非零，返回子进程退出码</span><br><span class="line">• WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值</span><br><span class="line">• WTERMSIG(status) ：如果 WIFSIGNALED 非零，返回信号代码</span><br><span class="line">• WIFSTOPPED(status)：如果子进程被暂停，返回一个非零值</span><br><span class="line">• WSTOPSIG(status)：如果 WIFSTOPPED 非零，返回一个信号代码</span><br></pre></td></tr></table></figure><h5 id="进程组，会话，终端"><a href="#进程组，会话，终端" class="headerlink" title="进程组，会话，终端"></a>进程组，会话，终端</h5><ul><li>进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程组：</span><br><span class="line">• 对相同的类型的进程进行管理</span><br><span class="line">进程组的诞生：</span><br><span class="line">• 在shell里面直接执行一个应用程序，对于大部分应用程序，自己就是进程组的首进程。进程组只有一个进程</span><br><span class="line">• 如果进程调用了fork函数，那么父子进程同属一个进程组，父进程为首进程</span><br><span class="line">• shell中通过管道执行连接起来的应用程序，两个程序同属一个进程组，第一个程序为进程组的首进程</span><br><span class="line"></span><br><span class="line">进程组id:pgid,由首进程pid决定 </span><br><span class="line">pgid：进程组所在的id号</span><br></pre></td></tr></table></figure><ul><li>会话（一般关联着一个终端）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">会话：管理前后台进程组</span><br><span class="line">会话的诞生：</span><br><span class="line">• 调用调用setsid函数，新建一个会话，应用程序作为会话的第一个进程，称为会话首进程</span><br><span class="line">• 用户在终端正确登录之后，启动shell时linux系统会创建一个新的会话，shell进程作为会话首进程。</span><br><span class="line">会话id:sid</span><br><span class="line">sid:会话首进程id</span><br></pre></td></tr></table></figure><ul><li>前台进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前台进程组：</span><br><span class="line">shell进程启动时，默认是前台进程组的首进程</span><br><span class="line">前台进程组的首进程会占用绘画所关联的终端来运行，shell启动其他应用程序时，其他程序成为首进程</span><br></pre></td></tr></table></figure><ul><li>后台进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">后台进程组的程序是不会占用终端的。</span><br><span class="line">在shell终端运行程序时，在后面加上&amp;的符号，可以指定程序运行在后台进程组里面。</span><br><span class="line">例：sleep 10 &amp;</span><br><span class="line"></span><br><span class="line">ctrl+z：会使进程进入后台，同时停止执行。返回终端</span><br><span class="line">jobs:查看有哪些后台进程组，和jobs id</span><br><span class="line">fg +job id可以把后台进程组切换为前台进程组</span><br></pre></td></tr></table></figure><ul><li>终端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">物理终端</span><br><span class="line">• 串口终端</span><br><span class="line">• lcd终端</span><br><span class="line">伪终端（不依赖物理设备）</span><br><span class="line">• SSH远程连接产生的终端</span><br><span class="line">• 桌面系统产生的终端</span><br><span class="line">虚拟终端</span><br><span class="line">• linux内核自带的 ctrl+alt+f0~f6来打开不同的终端</span><br><span class="line"></span><br><span class="line">终端被关闭之后，会话中的所有进程都会被关掉</span><br></pre></td></tr></table></figure><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>守护进程不受终端影响的，终端退出，而也可以继续在后台运行，</p><p>写守护进程步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• 创建一个子进程，父进程直接退出，</span><br><span class="line">- 使用fork()函数创建,</span><br><span class="line">• 创建一个新的会话</span><br><span class="line">- 子进程使用setsid()函数创建一个新的会话，没有关联任何终端</span><br><span class="line">• 改变守护进程的当前工作目录，改为&quot;/&quot;。因为子进程会继承父进程的工作目录的。所以需要改变工作目录。</span><br><span class="line">- 子进程使用chdir()函数实现</span><br><span class="line">• 重设文件权限的掩码（umask可以查看文件权限掩码 0022 -- 只写）</span><br><span class="line">新建文件的权限默认使0666,需要与掩码进行与非(&amp;~)的运算才是实际的文件权限</span><br><span class="line">-子进程使用umask()函数实现 umask直接设置为0</span><br><span class="line">• 关闭不需要的文件描述符</span><br><span class="line">- 子进程使用close()函数实现</span><br><span class="line">    - 0，1，2文件描述符，分别对应终端的标准输入，输出，出错。不需要与终端相关联所以需要关闭这些文件描述符。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-进程&quot;&gt;&lt;a href=&quot;#Linux应用编程-进程&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-进程&quot;&gt;&lt;/a&gt;Linux应用编程-进程&lt;/h2&gt;&lt;h5 id=&quot;fork-进程函数：&quot;&gt;&lt;a href=&quot;#for</summary>
      
    
    
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>函数返回二维数组地址</title>
    <link href="http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/"/>
    <id>http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/</id>
    <published>2022-10-22T13:37:41.000Z</published>
    <updated>2022-10-22T13:38:51.309Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回二维数组地址"><a href="#返回二维数组地址" class="headerlink" title="返回二维数组地址"></a>返回二维数组地址</h2><h5 id="int-p-int-3-说明："><a href="#int-p-int-3-说明：" class="headerlink" title="int *(*p(int))[3]说明："></a><em>int</em> *(*p(<em>int</em>))[3]说明：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,</span><br><span class="line">//说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,</span><br><span class="line">//说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.</span><br><span class="line">//所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址方法1"><a href="#返回二维数组地址方法1" class="headerlink" title="返回二维数组地址方法1"></a>返回二维数组地址方法1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;</span><br><span class="line">int (*ptraar)[4];</span><br><span class="line"></span><br><span class="line">int (*vfunc(void))[4]</span><br><span class="line">&#123;</span><br><span class="line">  return parr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ptraar = vfunc();</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,(*(*ptraar ) + 1)); //ptrarr[0][1]</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,ptrarr[0][1]); //ptrarr[0][1]</span><br><span class="line">&#125;</span><br><span class="line">//解析</span><br><span class="line">ptraar = 二维数组首地址</span><br><span class="line">(*ptraar ) = 二维数组元素首地址</span><br><span class="line">(*(*ptraar ) = 一维数组元素首地址</span><br><span class="line">(*(*ptraar ) + 1) = ptrarr[0][1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址方法2"><a href="#返回二维数组地址方法2" class="headerlink" title="返回二维数组地址方法2"></a>返回二维数组地址方法2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int prrs[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void * func(void)</span><br><span class="line">&#123;</span><br><span class="line">  return prrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *ins;</span><br><span class="line">ins = func();</span><br><span class="line">ptraar = (int (*)[4])ins;</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,*(*(ptraar + 1) + 2 ));</span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址指针"><a href="#返回二维数组地址指针" class="headerlink" title="返回二维数组地址指针"></a>返回二维数组地址指针</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;</span><br><span class="line">int *ptesarr[3][4]=&#123;&#123;&amp;arrss[0],&amp;arrss[1],&amp;arrss[2],&amp;arrss[3]&#125;,</span><br><span class="line">                    &#123;&amp;arrss[4],&amp;arrss[5],&amp;arrss[6],&amp;arrss[7]&#125;,</span><br><span class="line">                    &#123;&amp;arrss[8],&amp;arrss[9],&amp;arrss[10],&amp;arrss[11]&#125;&#125;;</span><br><span class="line">                    </span><br><span class="line">int *(*psst)[4];</span><br><span class="line">int *(*functions(void))[4]</span><br><span class="line">&#123;</span><br><span class="line">  return ptesarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">psst = functions();</span><br><span class="line">printf(&quot;psst ptr = %d\r\n&quot;,*(*(*(psst+0)) + 3));//*psst[0][3]</span><br><span class="line">printf(&quot;psst ptr arr= %d\r\n&quot;,*(psst[1][3]));//*psst[1][3]</span><br><span class="line">&#125;</span><br><span class="line">//解析</span><br><span class="line">*psst[2][3] = *(psst[2][3])  </span><br><span class="line">*(pstt[2][3]) = *((*(pstt+2)+3))</span><br><span class="line">pstt二维数组首地址</span><br><span class="line">*(pstt) = [二维数组元素首地址]</span><br><span class="line">*(*(pstt)) = [一维数组元素首地址]</span><br><span class="line">*(*(*(pstt + 2)) + 3) = [二维数组首地址 + 2][一维数组元素首地址 + 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;返回二维数组地址&quot;&gt;&lt;a href=&quot;#返回二维数组地址&quot; class=&quot;headerlink&quot; title=&quot;返回二维数组地址&quot;&gt;&lt;/a&gt;返回二维数组地址&lt;/h2&gt;&lt;h5 id=&quot;int-p-int-3-说明：&quot;&gt;&lt;a href=&quot;#int-p-int-3-说明</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>单链表头插法</title>
    <link href="http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/"/>
    <id>http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/</id>
    <published>2022-10-22T13:31:29.000Z</published>
    <updated>2022-10-22T13:34:58.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表头插法"><a href="#单链表头插法" class="headerlink" title="单链表头插法"></a>单链表头插法</h2><h5 id="单链表数据结构定义"><a href="#单链表数据结构定义" class="headerlink" title="单链表数据结构定义"></a>单链表数据结构定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct timer</span><br><span class="line">&#123;</span><br><span class="line">  int value; //数据</span><br><span class="line">  struct timer *next;//节点</span><br><span class="line">&#125;timer;</span><br><span class="line"></span><br><span class="line">//定义头指针head_handle</span><br><span class="line">static struct timer *head_handle;</span><br></pre></td></tr></table></figure><h5 id="链表初始化"><a href="#链表初始化" class="headerlink" title="链表初始化"></a>链表初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void timer_init(struct timer *handle,int value)</span><br><span class="line">&#123;</span><br><span class="line">  memset(handle,0,sizeof(struct timer));</span><br><span class="line">  handle-&gt;buff = NULL;</span><br><span class="line">  handle-&gt;value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建链表（头插法）"><a href="#创建链表（头插法）" class="headerlink" title="创建链表（头插法）"></a>创建链表（头插法）</h5><p><img src="/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/image-20221022213426409.png" alt="image-20221022213426409"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int start_timer(struct timer *handle)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer *target = head_handle;</span><br><span class="line">  while(target)</span><br><span class="line">  &#123;</span><br><span class="line">    if(target == handle) //判断新创建的节点是否和以前创建的是否相同</span><br><span class="line">    &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    target = target-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  handle-&gt;next = head_handle;</span><br><span class="line">  head_handle = handle;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//new_node1节点创建之前头节点 head_handle == NULL</span><br><span class="line">//new_node1节点创建之后头节点 head_handle == new_node1</span><br><span class="line">//当前链表链接顺序：new_node1-&gt;head_handle</span><br><span class="line">//new_node2节点创建之后头节点 head_handle == new_node2</span><br><span class="line">//当前链表链接顺序：new_node2-&gt;new_node1-&gt;head_handle</span><br></pre></td></tr></table></figure><h5 id="删除链表"><a href="#删除链表" class="headerlink" title="删除链表"></a>删除链表</h5><p><img src="/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/image-20221022213453323.png" alt="image-20221022213453323"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void timer_stop(struct timer *handle)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer **curr;</span><br><span class="line">  for(curr = &amp;head_handle;*curr;)</span><br><span class="line">  &#123;</span><br><span class="line">    struct timer *entry = *curr;</span><br><span class="line">    if(entry == handle)</span><br><span class="line">    &#123;</span><br><span class="line">      *curr = entry-&gt;next;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      curr = &amp;entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void timer_traverse(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer *target;</span><br><span class="line">  //根据链表头节点遍历整个链表</span><br><span class="line">  for(target = head_handle;target;target = target-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;timer value : %d\r\n&quot;,target-&gt;value);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;\r\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单链表头插法&quot;&gt;&lt;a href=&quot;#单链表头插法&quot; class=&quot;headerlink&quot; title=&quot;单链表头插法&quot;&gt;&lt;/a&gt;单链表头插法&lt;/h2&gt;&lt;h5 id=&quot;单链表数据结构定义&quot;&gt;&lt;a href=&quot;#单链表数据结构定义&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>gitbash安装使用gcc和make</title>
    <link href="http://example.com/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/"/>
    <id>http://example.com/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/</id>
    <published>2022-09-24T11:50:14.000Z</published>
    <updated>2022-09-24T12:03:46.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git安装gcc编译器和make工具"><a href="#Git安装gcc编译器和make工具" class="headerlink" title="Git安装gcc编译器和make工具"></a>Git安装gcc编译器和make工具</h2><h5 id="1、gcc编译器和make工具下载"><a href="#1、gcc编译器和make工具下载" class="headerlink" title="1、gcc编译器和make工具下载"></a>1、gcc编译器和make工具下载</h5><p><a href="https://link.zhihu.com/?target=http://www.equation.com/servlet/equation.cmd?fa=fortran">http://www.equation.com/servlet/equation.cmd?fa=fortra</a> </p><h5 id="2、gcc和make的安装"><a href="#2、gcc和make的安装" class="headerlink" title="2、gcc和make的安装"></a>2、gcc和make的安装</h5><p>双击下载好的exe,一直点击继续，知道安装结束。</p><h5 id="3、配置gcc的环境"><a href="#3、配置gcc的环境" class="headerlink" title="3、配置gcc的环境"></a>3、配置gcc的环境</h5><ul><li><p>找到Git的安装目录，在Git的安装目录下面找到Git\etc\profile.d\env.sh配置文件</p><p><img src="/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/image-20220924200051244.png" alt="image-20220924200051244"></p></li><li><p>打开env.sh文件，添加export PATH&#x3D;”$HOME&#x2F;gcc&#x2F;bin:$PATH”</p><p><img src="/2022/09/24/gitbash%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8gcc%E5%92%8Cmake/image-20220924200222615.png" alt="image-20220924200222615"></p></li><li><p>保存之后，双击env.sh就配置完成</p></li><li><p>如果添加之后不能保存env.sh文件，就设置权限</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git安装gcc编译器和make工具&quot;&gt;&lt;a href=&quot;#Git安装gcc编译器和make工具&quot; class=&quot;headerlink&quot; title=&quot;Git安装gcc编译器和make工具&quot;&gt;&lt;/a&gt;Git安装gcc编译器和make工具&lt;/h2&gt;&lt;h5 id=&quot;1</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>LED字符设备</title>
    <link href="http://example.com/2022/09/14/LED%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2022/09/14/LED%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/</id>
    <published>2022-09-14T14:01:58.000Z</published>
    <updated>2022-09-14T15:54:50.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LED字符设备"><a href="#LED字符设备" class="headerlink" title="LED字符设备"></a>LED字符设备</h2><h5 id="1、实现虚拟IO映射和读写"><a href="#1、实现虚拟IO映射和读写" class="headerlink" title="1、实现虚拟IO映射和读写"></a>1、实现虚拟IO映射和读写</h5><ul><li><p>虚拟地址映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">使用ioremap函数进行虚拟地址映射</span><br><span class="line">函数原型：void __iomem *ioremap(resource_size_t res_cookie, size_t size);</span><br><span class="line">参数：</span><br><span class="line">res_cookie：实际的物理地址</span><br><span class="line">size：映射长度(一般4个字节)</span><br><span class="line">返回值： void __iomem*类型的指针，指向被映射的虚拟地址</span><br><span class="line"></span><br><span class="line">__iomem:主要是用于编译器的检查地址在内核空间的有效性</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">#define CCM_CCGR1_BASE     (0x020C406C)</span><br><span class="line">static void __iomem *IMX6ULL_CCM_CCGR1;</span><br><span class="line">IMX6ULL_CCM_CCGR1 = ioremap(CCM_CCGR1_BASE,4);</span><br></pre></td></tr></table></figure></li><li><p>虚拟地址映射的取消</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用iounmap函数取消虚拟地址映射</span><br><span class="line">函数原型：void iounmap(volatile void __iomem *iomem_cookie);</span><br><span class="line">参数：</span><br><span class="line">iomem_cookie：指向虚拟地址的指针</span><br><span class="line"></span><br><span class="line">example：</span><br><span class="line">iounmap(IMX6ULL_CCM_CCGR1);</span><br></pre></td></tr></table></figure></li><li><p>虚拟地址的读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//虚拟地址的读取 8 16 32</span><br><span class="line">static inline u8 ioread8(const volatile void __iomem *addr) //8位的读取</span><br><span class="line">static inline u16 ioread16(const volatile void __iomem *addr) //16位的读取</span><br><span class="line">static inline u32 ioread32(const volatile void __iomem *addr) //32位的读取</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">addr：void __iomem *类型的虚拟地址</span><br><span class="line">返回值：u32/u16/u8类型的数据</span><br><span class="line"></span><br><span class="line">//虚拟地址的写 8 16 32</span><br><span class="line">static inline void iowrite8(u8 value, volatile void __iomem *addr)//写入8位数据</span><br><span class="line">static inline void iowrite16(u8 value, volatile void __iomem *addr)//写入16位数据</span><br><span class="line">static inline void iowrite32(u32 value, volatile void __iomem *addr)//写入32位数据</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">value：写入一个u32/u16/u8类型的数据</span><br><span class="line">addr：void __iomem *类型的虚拟地址</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、实现驱动接口"><a href="#2、实现驱动接口" class="headerlink" title="2、实现驱动接口"></a>2、实现驱动接口</h5><ul><li><p>file_operations 结构体的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//实现file_operation结构体</span><br><span class="line">static struct file_operations led_chrdev_fops = &#123;</span><br><span class="line">    .owner = THIS_MODULE,</span><br><span class="line">    .open = led_open,</span><br><span class="line">    .write = led_write,</span><br><span class="line">    .release = led_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>操作接口函数的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//write release open函数的实现</span><br><span class="line">static int led_open(struct inode *inode, struct file *filp)</span><br><span class="line">static int led_release(struct inode *inode, struct file *filp)</span><br><span class="line">static ssize_t led_write(struct file *filp, const char __user *buf,size_t count, loff_t *ppos)</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、数据的拷贝"><a href="#3、数据的拷贝" class="headerlink" title="3、数据的拷贝"></a>3、数据的拷贝</h5><ul><li><p>copy_from_user拷贝用户空间的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">copy_from_user(void *to, const void __user *from, unsigned long n);</span><br><span class="line">参数：</span><br><span class="line">to：将数据拷贝到内核地址</span><br><span class="line">from：需要拷贝的用户空间的地址</span><br><span class="line">n：需要拷贝数据的长度</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、添加、删除LED字符设备"><a href="#4、添加、删除LED字符设备" class="headerlink" title="4、添加、删除LED字符设备"></a>4、添加、删除LED字符设备</h5><ul><li><p>使用register_chrdev函数添加LED字符设备（用mknod 创建字符设备文件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//字符设备注册添加</span><br><span class="line">static inline int register_chrdev(unsigned int major, const char *name,</span><br><span class="line">  const struct file_operations *fops)</span><br><span class="line">参数：</span><br><span class="line">major：主设备号</span><br><span class="line">name：设备名字</span><br><span class="line">fops：file_operations的指针指向操作接口</span><br><span class="line"></span><br><span class="line">使用mknod /dev/led c 200 0 //创建一个字符设备/dev/led 主设备号为200 次设备号为0</span><br><span class="line"></span><br><span class="line">//字符设备注销</span><br><span class="line">static inline void unregister_chrdev(unsigned int major, const char *name)</span><br><span class="line">参数：</span><br><span class="line">major：主设备号</span><br><span class="line">name：设备名字</span><br><span class="line"></span><br><span class="line">//使用register_chrdev函数注册添加字符设备 注册成功会占用1个主设备号和256多个次设备号</span><br></pre></td></tr></table></figure></li><li><p>使用其他方式添加字符设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//动态申请主设备号</span><br><span class="line">alloc_chrdev_region();</span><br><span class="line">//创建class类</span><br><span class="line">class_create(); </span><br><span class="line">//cdev设备结构体与file_operations相关联</span><br><span class="line">cdev_init();</span><br><span class="line">//设备注册-添加设备到cdev_map哈希表中</span><br><span class="line">ret = cdev_add();</span><br><span class="line">//创建字符设备文件</span><br><span class="line">device_create();</span><br></pre></td></tr></table></figure></li><li><p>使用其他方式删除字符设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//删除字符设备文件</span><br><span class="line">device_destroy();</span><br><span class="line">//删除注册的字符设备（注销设备）</span><br><span class="line">cdev_del();</span><br><span class="line">//注销设备号</span><br><span class="line">unregister_chrdev_region();</span><br><span class="line">//删除设备逻辑类</span><br><span class="line">class_destroy();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;LED字符设备&quot;&gt;&lt;a href=&quot;#LED字符设备&quot; class=&quot;headerlink&quot; title=&quot;LED字符设备&quot;&gt;&lt;/a&gt;LED字符设备&lt;/h2&gt;&lt;h5 id=&quot;1、实现虚拟IO映射和读写&quot;&gt;&lt;a href=&quot;#1、实现虚拟IO映射和读写&quot; class</summary>
      
    
    
    
    
    <category term="linux驱动开发" scheme="http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>字符设备</title>
    <link href="http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/</id>
    <published>2022-09-14T10:36:18.000Z</published>
    <updated>2022-09-21T13:18:41.416Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符设备驱动"><a href="#字符设备驱动" class="headerlink" title="字符设备驱动"></a>字符设备驱动</h2><h4 id="设备驱动框架"><a href="#设备驱动框架" class="headerlink" title="设备驱动框架"></a>设备驱动框架</h4><p><img src="/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/image-20220914145604037.png" alt="image-20220914145604037"></p><h5 id="1、设备号的申请和注销"><a href="#1、设备号的申请和注销" class="headerlink" title="1、设备号的申请和注销"></a>1、设备号的申请和注销</h5><ul><li><p>设备号的定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static struct cdev chrdev;</span><br></pre></td></tr></table></figure></li><li><p>使用register_chrdev_region函数静态申请设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev_region函数用于静态地为一个字符设备申请一个或多个设备编号。一般用于指定手动分配主设备号。</span><br><span class="line">函数原型：int register_chrdev_region(dev_t from, unsigned count, const char *name)</span><br><span class="line">参数：</span><br><span class="line">from：需要注册的设备号，不能与被注册的设备号相同</span><br><span class="line">count：需要申请的设备号个数</span><br><span class="line">name：申请的设备号名称 在 &quot;cat /proc/devices&quot;下可查看到设备名称和设备号</span><br><span class="line">返回值：0成功 其他失败</span><br></pre></td></tr></table></figure></li><li><p>调用alloc_chrdev_region函数动态的申请设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">调用alloc_chrdev_region函数，内核会自动分配给我们一个尚未使用的主设备号。</span><br><span class="line">函数原型：int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name)</span><br><span class="line">参数：</span><br><span class="line">dev：指向dev_t类型数据的指针变量，用于存放分配到的设备编号的起始值；</span><br><span class="line">baseminor：次设备号的起始值，通常为0</span><br><span class="line">count：指定需要分配的设备编号个数</span><br><span class="line">name：设备名称</span><br><span class="line">返回值：返回0成功</span><br></pre></td></tr></table></figure></li><li><p>注销申请的字符设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用xxx_chrdev_region()函数申请的设备号可以使用unregister_chrdev_region()注销</span><br><span class="line">函数原型：void unregister_chrdev_region(dev_t from, unsigned count)</span><br><span class="line">参数：</span><br><span class="line">from：指定需要注销的字符设备的设备编号起始值</span><br><span class="line">count：指定需要注销的字符设备编号的个数，该值应与申请函数的count值相等</span><br></pre></td></tr></table></figure></li><li><p>register_chrdev函数申请设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">register_chrdev函数用于分配设备号</span><br><span class="line">函数原型：static inline int register_chrdev(unsigned int major, const char *name,const struct file_operations *fops)</span><br><span class="line">&#123;</span><br><span class="line">   return __register_chrdev(major, 0, 256, name, fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">major：用于指定要申请的字符设备的主设备号，major = 0 时，内核会自动分配一个未使用的主设备号。</span><br><span class="line">name：设备名称</span><br><span class="line">fops：用于操作该设备的函数接口指针</span><br><span class="line">返回值：主设备号</span><br></pre></td></tr></table></figure></li><li><p>unregister_chrdev注销申请的字符设备号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">使用register函数申请的设备号，则应该使用unregister_chrdev函数进行注销。</span><br><span class="line">函数原型：static inline void unregister_chrdev(unsigned int major, const char *name)</span><br><span class="line">&#123;</span><br><span class="line">__unregister_chrdev(major, 0, 256, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">major：指定需要释放的字符设备的主设备号</span><br><span class="line">name：执行需要释放的字符设备的名称</span><br></pre></td></tr></table></figure></li><li><p>设备号宏</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define MAJOR(dev)((unsigned int) ((dev) &gt;&gt; MINORBITS))</span><br><span class="line">#define MINOR(dev)((unsigned int) ((dev) &amp; MINORMASK))</span><br><span class="line">#define MKDEV(ma,mi)(((ma) &lt;&lt; MINORBITS) | (mi))</span><br><span class="line"></span><br><span class="line">MINOR(dev)：用来获取该设备文件的次设备号</span><br><span class="line">MINOR(dev)：用来获取该设备文件的主设备号</span><br><span class="line">MKDEV(ma,mi)：将主设备号和次设备号一起转成dev_t类型的设备号</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、实现file-operations结构体和初始化cdev"><a href="#2、实现file-operations结构体和初始化cdev" class="headerlink" title="2、实现file_operations结构体和初始化cdev"></a>2、实现file_operations结构体和初始化cdev</h5><ul><li><p>实现file_operations结构体里面的函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static struct file_operations led_chrdev_fops = &#123;</span><br><span class="line">.owner = THIS_MODULE,</span><br><span class="line">.open = led_chrdev_open,</span><br><span class="line">.release = led_chrdev_release,</span><br><span class="line">.write = led_chrdev_write,</span><br><span class="line">&#125;;</span><br><span class="line">实现我们需要用的函数：</span><br><span class="line">static int led_chrdev_open(struct inode *inode, struct file *filp)；</span><br><span class="line">static int led_chrdev_release(struct inode *inode, struct file *filp)；</span><br><span class="line">static ssize_t led_chrdev_write(struct file *filp, const char __user * buf,</span><br><span class="line">size_t count, loff_t * ppos)；</span><br></pre></td></tr></table></figure></li><li><p>初始化cdev</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用cdev_init函数将cdev和file_operations 相关联起来</span><br><span class="line">函数原型：void cdev_init(struct cdev *cdev, const struct file_operations *fops)</span><br><span class="line">参数：</span><br><span class="line">cdev：struct cdev类型的指针变量，指向需要关联的字符设备结构体；</span><br><span class="line">fops：file_operations类型的结构体指针变量，一般将实现操作该设备的结构体file_operations结构体作为实参。</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、设备注册和注销"><a href="#3、设备注册和注销" class="headerlink" title="3、设备注册和注销"></a>3、设备注册和注销</h5><ul><li><p>设备注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cdev_add函数用于向内核的cdev_map散列表添加一个新的字符设备</span><br><span class="line">函数原型：int cdev_add(struct cdev *p, dev_t dev, unsigned count)</span><br><span class="line">参数：</span><br><span class="line">p：struct cdev类型的指针，用于指定需要添加的字符设备</span><br><span class="line">dev：dev_t类型变量，用于指定设备的起始编号</span><br><span class="line">count：指定注册多少个设备</span><br><span class="line">返回值：返回为0 添加成功</span><br></pre></td></tr></table></figure></li><li><p>设备注销</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cdev_del函数用于向内核的cdev_map散列表删除注册的字符设备</span><br><span class="line">函数原型：void cdev_del(struct cdev *p)</span><br><span class="line">参数：</span><br><span class="line">p：struct cdev类型的指针，用于指定需要删除的字符设备；</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、设备的逻辑类的创建和删除"><a href="#4、设备的逻辑类的创建和删除" class="headerlink" title="4、设备的逻辑类的创建和删除"></a>4、设备的逻辑类的创建和删除</h5><ul><li><p>动态创建设备的逻辑类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class_create()用于动态创建设备的逻辑类，并完成部分字段的初始化，然后将其添加进Linux内核系统中。</span><br><span class="line">此函数的执行效果就是在/sys/class/目录下创建一个新的文件夹。</span><br><span class="line">宏原型：#define class_create(owner, name)\</span><br><span class="line">(&#123;\</span><br><span class="line">static struct lock_class_key __key;\</span><br><span class="line">__class_create(owner, name, &amp;__key);\</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">owner：一个struct module结构体类型的指针，一般赋值为THIS_MODULE</span><br><span class="line">name：代表即将创建的struct class变量的名字，用于给struct class的name字段赋值</span><br><span class="line"></span><br><span class="line">class_create(THISMODULE,&quot;chrdev&quot;); //在 /sys/class/目录下面创建一个chrdev文件</span><br></pre></td></tr></table></figure></li><li><p>删除设备的逻辑类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">函数class_destroy()用于删除设备的逻辑类即从Linux内核系统中删除设备的逻辑类。</span><br><span class="line">此函数执行的效果是删除函数__class_create()或宏class_create()在/sys/class/目录下创建的逻辑类对应的文件夹。</span><br><span class="line">函数原型：void class_destroy(struct class *cls);</span><br><span class="line">参数：</span><br><span class="line">cls：创建成功的class设备的逻辑类</span><br></pre></td></tr></table></figure></li></ul><h5 id="5、设备节点的创建和销毁"><a href="#5、设备节点的创建和销毁" class="headerlink" title="5、设备节点的创建和销毁"></a>5、设备节点的创建和销毁</h5><ul><li><p>代码设备节点的创建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">device_create函数创建一个设备并将其注册到文件系统</span><br><span class="line">函数原型：struct device *device_create(struct class *class, struct device *parent,</span><br><span class="line">            dev_t devt, void *drvdata, const char *fmt, ...)</span><br><span class="line">参数：</span><br><span class="line">class：指向这个设备应该注册到的struct类的指针</span><br><span class="line">parent：指向此新设备的父结构设备（如果有）的指针</span><br><span class="line">devt：要添加的char设备的开发</span><br><span class="line">drvdata：要添加到设备进行回调的数据</span><br><span class="line">fmt：输入设备名称</span><br><span class="line"></span><br><span class="line">返回值：成功返回 struct device 结构体指针, 错误时返回ERR_PTR().</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">struct class *led_chrdev_class;</span><br><span class="line">led_chrdev_class = class_create(THIS_MODULE, &quot;led_chrdev&quot;); //在 /dev/目录下面创建led_chrdev的设备节点文件</span><br><span class="line">device_create(led_chrdev_class, NULL, cur_dev, NULL,DEV_NAME &quot;%d&quot;, i);</span><br></pre></td></tr></table></figure></li><li><p>代码设备节点的销毁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">使用device_destroy删除使用device_create函数创建的设备</span><br><span class="line">函数原型：void device_destroy(struct class *class, dev_t devt)</span><br><span class="line">参数：</span><br><span class="line">class：指向注册此设备的struct类的指针；</span><br><span class="line">devt：以前注册的设备的开发</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">static dev_t devno;//已分配的主设备号</span><br><span class="line">dev_t cur_dev;</span><br><span class="line">cur_dev = MKDEV(MAJOR(devno), MINOR(devno) + i); //将主设备和次设备转化成dev_t类型的设备号</span><br><span class="line">device_destroy(led_chrdev_class, cur_dev);//销毁设备节点</span><br><span class="line">class_destroy(led_chrdev_class);</span><br></pre></td></tr></table></figure><p>注意：class_create 和 class_destroy是成对出现的不可只单独使用其中一个。</p></li><li><p>使用mknod命令创建节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可以使用mknod命令创建设备节点。</span><br><span class="line">用法：mknod 设备名 设备类型 主设备号 次设备号</span><br><span class="line">设备类型：</span><br><span class="line">- b 创建（有缓冲的）区块特殊文件</span><br><span class="line">- c,u 创建(没有缓冲的)字符特殊文件</span><br><span class="line">- p 创建先进先出(FIFO)特殊文件</span><br><span class="line"></span><br><span class="line">example:</span><br><span class="line">//创建一个字符设备/dev/led 主设备号为200 次设备号为0</span><br><span class="line">mknod /dev/led c 200 0</span><br></pre></td></tr></table></figure></li></ul><h5 id="6、字符设备驱动流程"><a href="#6、字符设备驱动流程" class="headerlink" title="6、字符设备驱动流程"></a>6、字符设备驱动流程</h5><ul><li><p>设备驱动流程</p><p><img src="/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/image-20220914184025132.png" alt="image-20220914184025132"></p></li><li><p>设备卸载流程</p><p><img src="/2022/09/14/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87/image-20220914184103046.png" alt="image-20220914184103046"></p></li></ul><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod 显示已载入系统的模块</span><br><span class="line">modinfo+模块名字 查看模块详细信息</span><br><span class="line">ls /dev/ 查看设备节点</span><br><span class="line">cat /proc/devices 查看设备和设备号</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;字符设备驱动&quot;&gt;&lt;a href=&quot;#字符设备驱动&quot; class=&quot;headerlink&quot; title=&quot;字符设备驱动&quot;&gt;&lt;/a&gt;字符设备驱动&lt;/h2&gt;&lt;h4 id=&quot;设备驱动框架&quot;&gt;&lt;a href=&quot;#设备驱动框架&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    
    <category term="linux驱动开发" scheme="http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>内核模块</title>
    <link href="http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/"/>
    <id>http://example.com/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/</id>
    <published>2022-09-10T14:04:20.000Z</published>
    <updated>2022-09-14T14:18:26.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核模块"><a href="#内核模块" class="headerlink" title="内核模块"></a>内核模块</h2><h4 id="内核模块概念-现代内核派系"><a href="#内核模块概念-现代内核派系" class="headerlink" title="内核模块概念-现代内核派系"></a>内核模块概念-现代内核派系</h4><h5 id="1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）"><a href="#1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）" class="headerlink" title="1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）"></a>1、现代内核派系-关键功能和服务功能均在内核空间提供（linux）</h5><ul><li>运行效率高</li><li>扩展性差</li></ul><h5 id="2、微内核-内核空间提供关键功能，服务功能在用户空间提供"><a href="#2、微内核-内核空间提供关键功能，服务功能在用户空间提供" class="headerlink" title="2、微内核-内核空间提供关键功能，服务功能在用户空间提供"></a>2、微内核-内核空间提供关键功能，服务功能在用户空间提供</h5><ul><li>运行效率低</li><li>扩展性较高</li></ul><p>两者区别如下图：</p><p><img src="/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/image-20220909130421444.png" alt="image-20220909130421444"></p><h4 id="内核模块实验环境搭建"><a href="#内核模块实验环境搭建" class="headerlink" title="内核模块实验环境搭建"></a>内核模块实验环境搭建</h4><h5 id="1、搭建开发板环境"><a href="#1、搭建开发板环境" class="headerlink" title="1、搭建开发板环境"></a>1、搭建开发板环境</h5><ul><li>开发板烧录Debain镜像-当前开发板内核版本：4.19.35-imx6</li><li>启动开发板，搭建nfs客户端，挂载共享文件夹</li><li>获取debain镜像内核源码-编译</li></ul><h5 id="2、获取内核源码-编译（4-19-35-imx6）"><a href="#2、获取内核源码-编译（4-19-35-imx6）" class="headerlink" title="2、获取内核源码-编译（4.19.35-imx6）"></a>2、获取内核源码-编译（4.19.35-imx6）</h5><ul><li><p>获取linux内核源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone  https://gitee.com/Embedfire/ebf_linux_kernel_6ull_depth1</span><br></pre></td></tr></table></figure></li><li><p>安装工具配置环境</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop</span><br></pre></td></tr></table></figure></li><li><p>开始编译，构建内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./make_deb.sh (如果权限不足加上sudo)</span><br><span class="line">修改build_opts=&quot;$&#123;build_opts&#125; O=X&quot;,可以改变安装的路径，X=你想要存放的路径</span><br></pre></td></tr></table></figure></li><li><p>获取编译的出来的内核文件的相关文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">将路径下存放的当前的内核相关文件 拷贝到你的工程路径下面</span><br><span class="line">/home/kernel/bulid</span><br></pre></td></tr></table></figure></li></ul><h4 id="内核模块所需头文件"><a href="#内核模块所需头文件" class="headerlink" title="内核模块所需头文件"></a>内核模块所需头文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;linux/module.h&gt;  //包含内核模块信声明的相关函数</span><br><span class="line">#include &lt;linux/init.h&gt; // 包含module_init module_exit 函数声明</span><br><span class="line">#include &lt;linux/kernel.h&gt;//包含内核提供的各种函数，例如printk内核模块打印函数</span><br></pre></td></tr></table></figure><h4 id="内核模块函数-x2F-命令"><a href="#内核模块函数-x2F-命令" class="headerlink" title="内核模块函数&#x2F;命令"></a>内核模块函数&#x2F;命令</h4><h5 id="1、内核模块加载、卸载"><a href="#1、内核模块加载、卸载" class="headerlink" title="1、内核模块加载、卸载"></a>1、内核模块加载、卸载</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内核加载命令：insmod</span><br><span class="line">内核卸载命令：rmmod</span><br></pre></td></tr></table></figure><h5 id="2、内核函数入口，出口"><a href="#2、内核函数入口，出口" class="headerlink" title="2、内核函数入口，出口"></a>2、内核函数入口，出口</h5><ul><li><p>内核函数模块入口-加载模块式函数自动执行，进行初始化操作</p></li><li><p>内核函数模块出口-卸载模块是函数自动执行，进行清理工作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内核模块入口函数：module_init();</span><br><span class="line">内核模块出口函数：module_exit();</span><br></pre></td></tr></table></figure></li></ul><h5 id="3、内核模块信息声明"><a href="#3、内核模块信息声明" class="headerlink" title="3、内核模块信息声明"></a>3、内核模块信息声明</h5><ul><li><p>MODULE_LICENSE：内核模块版权声明，模块接受软件许可协议</p></li><li><p>MODULE_AUTHOR：描述模块作者信息</p></li><li><p>MODULE_DESCRIPTION：对模块的简单介绍</p></li><li><p>MODULE_ALIAS：给模块设置一个别名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">内核模块版权声明，模块接受软件许可协议  MODULE_LICENSE();</span><br><span class="line">描述模块作者信息MODULE_AUTHOR();</span><br><span class="line">对模块的简单介绍MODULE_DESCRIPTION();</span><br><span class="line">给模块设置一个别名MODULE_ALIAS();</span><br></pre></td></tr></table></figure></li></ul><h5 id="4、内核模块打印函数"><a href="#4、内核模块打印函数" class="headerlink" title="4、内核模块打印函数"></a>4、内核模块打印函数</h5><ul><li><p>printk内核模块打印函数-需要指定打印等级</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//打印等级0-7</span><br><span class="line">#define KERN_EMERG&quot;&lt;0&gt;&quot; 通常是系统崩溃前的信息</span><br><span class="line">#define KERN_ALERT&quot;&lt;1&gt;&quot; 需要立即处理的消息</span><br><span class="line">#define KERN_CRIT&quot;&lt;2&gt;&quot; 严重情况</span><br><span class="line">#define KERN_ERR&quot;&lt;3&gt;&quot; 错误情况</span><br><span class="line">#define KERN_WARNING&quot;&lt;4&gt;&quot; 有问题的情况</span><br><span class="line">#define KERN_NOTICE&quot;&lt;5&gt;&quot; 注意信息</span><br><span class="line">#define KERN_INFO&quot;&lt;6&gt;&quot; 普通消息</span><br><span class="line">#define KERN_DEBUG&quot;&lt;7&gt;&quot; 调试信息</span><br><span class="line"></span><br><span class="line">打印内核所有打印信息：dmesg</span><br><span class="line">查看当前系统的printk打印等级：cat /proc/sys/kernel/printk</span><br><span class="line"></span><br><span class="line">下图的4417对应</span><br><span class="line">4当前控制台日志级别</span><br><span class="line">4 默认消息日志级别</span><br><span class="line">1最小的控制台级别</span><br><span class="line">7默认控制台日志级别</span><br></pre></td></tr></table></figure><p><img src="/2022/09/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/image-20220910225536855.png" alt="image-20220910225536855"></p></li></ul><h5 id="5、模块参数"><a href="#5、模块参数" class="headerlink" title="5、模块参数"></a>5、模块参数</h5><ul><li><p>模块参数：根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性</p></li><li><p>模块参数函数：module_param</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">module_param(name,type,perm);</span><br><span class="line">- name 参数名</span><br><span class="line">- type 参数类型</span><br><span class="line">- perm 读写权限</span><br><span class="line"></span><br><span class="line">数据类型对应type类型：</span><br><span class="line">int类型：int&lt;------------&gt; int</span><br><span class="line">char类型:char&lt;-----------&gt; byte</span><br><span class="line">bool类型：bool&lt;-----------&gt; bool</span><br><span class="line">字符串类型:char*&lt;----------&gt; charp</span><br><span class="line"></span><br><span class="line">perm读写权限：</span><br><span class="line">- 不可以设置执行权限 如0777</span><br><span class="line">- 在sys/modules/模块名/paramters 目录下生成该参数对应的文件名</span><br></pre></td></tr></table></figure></li></ul><h5 id="6、符号共享"><a href="#6、符号共享" class="headerlink" title="6、符号共享"></a>6、符号共享</h5><ul><li><p>内核模块可以共享导出的符号表</p></li><li><p>可以变量共享和函数共享</p></li><li><p>符号共享函数：EXPORT_SYMBOL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(sym);</span><br><span class="line">sym:变量名或者是函数名</span><br></pre></td></tr></table></figure></li><li><p>查看符号表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/kallsyms | grep xxx</span><br><span class="line">xxx:需要查看的模块名</span><br></pre></td></tr></table></figure></li></ul><h5 id="7、模块加载"><a href="#7、模块加载" class="headerlink" title="7、模块加载"></a>7、模块加载</h5><ul><li><p>模块手动加载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、模块加载时必须先加载相关依赖模块</span><br><span class="line">2、模块卸载时必须先卸载模块，在卸载依赖模块</span><br></pre></td></tr></table></figure></li><li><p>模块自动加载</p><ul><li><p>将所有内核模块统一放在 “&#x2F;lib&#x2F;modules&#x2F;内核版本”目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp *.ko /lib/modules/4.19.35-imx6 </span><br></pre></td></tr></table></figure></li><li><p>建立模块依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">depmod -a</span><br></pre></td></tr></table></figure></li><li><p>查看模块依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /lib/modules/4.19.35-imx6/modlue.dep</span><br></pre></td></tr></table></figure></li><li><p>加载、卸载模块及其依赖关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加载模块及依赖：modprobe xxx</span><br><span class="line">下载模块及依赖：modprobe -r xxx</span><br><span class="line">xxx：需要操作的模块</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内核模块&quot;&gt;&lt;a href=&quot;#内核模块&quot; class=&quot;headerlink&quot; title=&quot;内核模块&quot;&gt;&lt;/a&gt;内核模块&lt;/h2&gt;&lt;h4 id=&quot;内核模块概念-现代内核派系&quot;&gt;&lt;a href=&quot;#内核模块概念-现代内核派系&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="linux驱动开发" scheme="http://example.com/tags/linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo搭建个人博客</title>
    <link href="http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/09/09/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-09-08T16:21:19.000Z</published>
    <updated>2022-09-08T16:21:56.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用hexo搭建个人博客"><a href="#使用hexo搭建个人博客" class="headerlink" title="使用hexo搭建个人博客"></a>使用hexo搭建个人博客</h2><h3 id="1、安装环境依赖"><a href="#1、安装环境依赖" class="headerlink" title="1、安装环境依赖"></a>1、安装环境依赖</h3><ul><li><p>安装git（按照默认操作即可）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果点击鼠标右键 能够打开git bash 说明git 安装成功</span><br></pre></td></tr></table></figure></li><li><p>安装node.js</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">鼠标右键打开git bash</span><br><span class="line">查看node 是否安装成功</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure></li><li><p>安装hexo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">安装hexo</span><br><span class="line">1、桌面新建一个文件夹 blog，git bash 进入文件夹</span><br><span class="line">2、设置淘宝镜像原（npm config set registry http://registry.npm.taobao.org）//可要可不要</span><br><span class="line">3、安装hexo npm install hexo-cli -g</span><br><span class="line">4、检测hexo是否安装完成 hexo -v </span><br></pre></td></tr></table></figure></li></ul><h3 id="生成博客文件"><a href="#生成博客文件" class="headerlink" title="生成博客文件"></a>生成博客文件</h3><ul><li><p>生成博客文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开git</span><br><span class="line">hexo init blog(如果没有进入到blog文件夹)</span><br><span class="line">hexo init (如果进入到blog文件夹)</span><br></pre></td></tr></table></figure></li><li><p>预览博客文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br><span class="line">将生成的网址复制到网页执行，可以看到博客文件</span><br></pre></td></tr></table></figure></li></ul><h3 id="部署博客到gitee平台"><a href="#部署博客到gitee平台" class="headerlink" title="部署博客到gitee平台"></a>部署博客到gitee平台</h3><ul><li><p>在gitee创建一个仓库，创建仓库名称使用gitee用户名。（如果不适用用户名，需要再仓库名后面加.gitee.io）</p></li><li><p>仓库创建成功后，复制HTTP 链接网址。</p></li><li><p>配置博客配置文件 _config.yml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27; //选择git</span><br><span class="line">  repo: https://gitee.com/yys_cn_ccs/zhaoqaun.git //gitee http 链接地址</span><br><span class="line">  branch: master//git 分支的配置</span><br></pre></td></tr></table></figure></li><li><p>安装hexo部署工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>生成静态链接文件（public）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li><li><p>部署（需要输入gitee用户名字加密码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h3 id="开启gitee服务"><a href="#开启gitee服务" class="headerlink" title="开启gitee服务"></a>开启gitee服务</h3><ul><li>打开gitee 点击右上角“服务”—-选择Gitee Pages 点击部署。</li></ul><h3 id="设置hexo主题"><a href="#设置hexo主题" class="headerlink" title="设置hexo主题"></a>设置hexo主题</h3><p>1、去找到自己希望的 hexi主题，搜索主题名字。</p><p>2、将下载好的主题下载后放在 themes 文件下面 ，然后配置博客配置文件 _config.yml，将langscape修改成需要配置的主题名字。如果主题需要一些依赖，根据作者下面提示安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><p>3、安装pure</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/cofess/hexo-theme-pure.git themes/pure</span><br></pre></td></tr></table></figure><p>4、pure的依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-wordcount --save</span><br><span class="line">npm install hexo-generator-json-content --save</span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure><h3 id="使用hexo开始写博客"><a href="#使用hexo开始写博客" class="headerlink" title="使用hexo开始写博客"></a>使用hexo开始写博客</h3><ul><li><p>开始写博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new newpapername</span><br></pre></td></tr></table></figure></li><li><p>博客写完之后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></li></ul><h3 id="hexo基本配置"><a href="#hexo基本配置" class="headerlink" title="hexo基本配置"></a>hexo基本配置</h3><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table><h4 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h4><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks">永久链接</a> 格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用hexo搭建个人博客&quot;&gt;&lt;a href=&quot;#使用hexo搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;使用hexo搭建个人博客&quot;&gt;&lt;/a&gt;使用hexo搭建个人博客&lt;/h2&gt;&lt;h3 id=&quot;1、安装环境依赖&quot;&gt;&lt;a href=&quot;#1、安装环</summary>
      
    
    
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/08/30/hello-world/"/>
    <id>http://example.com/2022/08/30/hello-world/</id>
    <published>2022-08-30T12:16:49.877Z</published>
    <updated>2022-08-30T12:27:49.047Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>hexo如何在网页上面显示图片</title>
    <link href="http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/"/>
    <id>http://example.com/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/</id>
    <published>2022-08-29T09:24:28.000Z</published>
    <updated>2022-08-30T12:16:49.877Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hexo如何在网页上面显示图片"><a href="#hexo如何在网页上面显示图片" class="headerlink" title="hexo如何在网页上面显示图片"></a>hexo如何在网页上面显示图片</h2><h5 id="1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径"><a href="#1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径" class="headerlink" title="1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径"></a>1、将typora的图像设置设置成复制到指定路径，和优先使用相对路径</h5><p><img src="/2022/08/29/hexo%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E9%9D%A2%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87/image-20220829172657020.png" alt="image-20220829172657020"></p><h5 id="2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。"><a href="#2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。" class="headerlink" title="2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。"></a>2、在根目录安装hexo-asset-image，就能按照markdown的格式进行图片的插入。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure><h5 id="3、配置-config-yml文件"><a href="#3、配置-config-yml文件" class="headerlink" title="3、配置_config_yml文件"></a>3、配置_config_yml文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设置 post_asset_folder 为true</span><br><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;hexo如何在网页上面显示图片&quot;&gt;&lt;a href=&quot;#hexo如何在网页上面显示图片&quot; class=&quot;headerlink&quot; title=&quot;hexo如何在网页上面显示图片&quot;&gt;&lt;/a&gt;hexo如何在网页上面显示图片&lt;/h2&gt;&lt;h5 id=&quot;1、将typora的图像设</summary>
      
    
    
    
    <category term="hexo" scheme="http://example.com/categories/hexo/"/>
    
    
    <category term="hexo" scheme="http://example.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>数组指针和指针数组</title>
    <link href="http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2022/08/29/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84/</id>
    <published>2022-08-29T06:25:05.000Z</published>
    <updated>2022-08-30T12:16:49.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组指针和指针数组"><a href="#数组指针和指针数组" class="headerlink" title="数组指针和指针数组"></a>数组指针和指针数组</h2><h5 id="1、数组指针"><a href="#1、数组指针" class="headerlink" title="1、数组指针"></a>1、数组指针</h5><ul><li><p>数组指针：指向数组的指针，优先级顺序是：（）&gt; [] &gt; *</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//根据优先级，先看括号内，则p是一个指针，这个指针指向一个一维数组，数组长度为n，这是“数组的指针”，即数组指针</span><br><span class="line">int （*p1）[5];</span><br></pre></td></tr></table></figure></li><li><p>对于语句“int ( * p1)[5]”，“()”的优先级比“[]”高，“*”号和 p1 构成一个指针的定义，指针变量名为 p1，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p1 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如下所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> -------------------------------------------</span><br><span class="line">p1 ----&gt; | int * | init * | int * | init * | int * |</span><br><span class="line"> -------------------------------------------</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int (*p)[5]; //定义一个数组指针</span><br><span class="line">        int arr[5] = &#123;1,2,3,4,5&#125;; //定义一个数组</span><br><span class="line">        p = &amp;arr;//p指向数组首地址</span><br><span class="line">        printf(&quot;p0 value = %d\r\n&quot;,*(*p + 0)); //arr[0]</span><br><span class="line">        printf(&quot;p1 value = %d\r\n&quot;,*(*p + 1));//arr[1]</span><br><span class="line">        printf(&quot;p2 value = %d\r\n&quot;,*(*p + 2));//arr[2]</span><br><span class="line">        printf(&quot;p3 value = %d\r\n&quot;,*(*p + 3));//arr[3]</span><br><span class="line">        printf(&quot;p4 value = %d\r\n&quot;,*(*p + 4));  //arr[4]</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//p 代表的是数组首地址</span><br><span class="line">//arr 代表的是整个数组首元素首地址</span><br><span class="line">//&amp;arr 代表整个数组首地址(对数组首元素首地址取地址得到数组首地址)</span><br><span class="line">//*p 代表数组首元素首地址</span><br><span class="line">//*p+1 代表数组首元素地址 + 1</span><br><span class="line">//**p //表示数组首元素首地址对应的值</span><br><span class="line"></span><br><span class="line">//将二维数组赋给指针</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int b[3][4];</span><br><span class="line">int (*pp)[4];//定义一个数组指针，指向含四个元素的一维数组</span><br><span class="line">pp = b;//将该二维数组的首地址赋给pp，也就是b[0]或&amp;b[0]，二维数组中pp=b和pp=&amp;b[0]是等价的</span><br><span class="line">pp++;//该语句执行过后pp的指向从行b[0][]变为了行b[1][]，pp=&amp;b[1]</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">//根据上面二维数组可以得出，数组指针也称指向一维数组的指针，所以数组指针也称行指针。</span><br></pre></td></tr></table></figure></li></ul><h5 id="2、指针数组"><a href="#2、指针数组" class="headerlink" title="2、指针数组"></a>2、指针数组</h5><ul><li><p>指针数组：装着指针的数组，优先级顺序：[] &gt;*</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int *p2[5];</span><br><span class="line">//根据优先级，先看[]，则p是一个数组，再结合*，这个数组的元素是指针类型，共n个元素，这是“指针的数组”，即指针数组。</span><br></pre></td></tr></table></figure></li><li><p>对于int *p2[5] 来说，因为“ [] ”的优先级要比 “ * ”的优先级要高，所以p2先和“ [] ”结合，构成一个数组的定义，数组名为p2,而“ int ”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如下所示。因此他是一个指针数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p2</span><br><span class="line">----------------------------------------------------------------------------</span><br><span class="line">|               |                   |                  |                   |</span><br><span class="line">int *           int *               int *              int *               int *</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">// ptr 里面存放的是 5个字符串的首元素地址</span><br><span class="line">        char *ptr[5]=&#123;&quot;hello&quot;,&quot;world&quot;,&quot;blos&quot;,&quot;456&quot;,&quot;hhels&quot;&#125;;</span><br><span class="line">        int a = 1;</span><br><span class="line">        int b = 2;</span><br><span class="line">        int *p[2];</span><br><span class="line">        p[0] = &amp;a;</span><br><span class="line">        p[1] = &amp;b;</span><br><span class="line"></span><br><span class="line">        printf(&quot;%d\r\n&quot;,*p[0]);</span><br><span class="line">        printf(&quot;%d\r\n&quot;,*p[1]);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%s\r\n&quot;,ptr[0]);</span><br><span class="line">printf(&quot;%s\r\n&quot;,ptr[1]);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h5 id="对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针"><a href="#对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针" class="headerlink" title="对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针."></a>对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针.</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组指针和指针数组&quot;&gt;&lt;a href=&quot;#数组指针和指针数组&quot; class=&quot;headerlink&quot; title=&quot;数组指针和指针数组&quot;&gt;&lt;/a&gt;数组指针和指针数组&lt;/h2&gt;&lt;h5 id=&quot;1、数组指针&quot;&gt;&lt;a href=&quot;#1、数组指针&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>git初始化连接远程仓库</title>
    <link href="http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/"/>
    <id>http://example.com/2022/08/26/git%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</id>
    <published>2022-08-26T14:47:35.000Z</published>
    <updated>2022-08-30T12:16:49.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何使用git"><a href="#如何使用git" class="headerlink" title="如何使用git"></a>如何使用git</h2><h4 id="1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）"><a href="#1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）" class="headerlink" title="1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）"></a>1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//配置用户名</span><br><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">//配置邮箱</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br><span class="line">//查看是否配置成功</span><br><span class="line">git config --list --global</span><br></pre></td></tr></table></figure><h4 id="2、初始化git仓库"><a href="#2、初始化git仓库" class="headerlink" title="2、初始化git仓库"></a>2、初始化git仓库</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="3、配置ssh公钥"><a href="#3、配置ssh公钥" class="headerlink" title="3、配置ssh公钥"></a>3、配置ssh公钥</h4><ul><li><p>生成公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;youremail&quot; //youremail是前面global配置的email</span><br></pre></td></tr></table></figure></li><li><p>查看获取公钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li><li><p>将获取到的公钥添加到gitee上面</p></li><li><p>查看公钥是否配置成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br></pre></td></tr></table></figure></li><li><p>远程仓库的添加和查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//远程仓库添加</span><br><span class="line">git remote add origin +(远程仓库地址)</span><br><span class="line">//git remote add origin git@gitee.com:linux_4/drivers-imx6ull.git</span><br><span class="line">//查看远程仓库</span><br><span class="line">git remote</span><br></pre></td></tr></table></figure></li><li><p>拉取远程分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master </span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何使用git&quot;&gt;&lt;a href=&quot;#如何使用git&quot; class=&quot;headerlink&quot; title=&quot;如何使用git&quot;&gt;&lt;/a&gt;如何使用git&lt;/h2&gt;&lt;h4 id=&quot;1、安装完git之后一开始需要配置全局git（每个操作系统只需要初始化一次）&quot;&gt;&lt;a hr</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>git的一些常用操作</title>
    <link href="http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://example.com/2022/08/26/git%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</id>
    <published>2022-08-26T13:42:20.000Z</published>
    <updated>2022-08-30T12:16:49.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h2><h5 id="1、单个文件加入缓存区"><a href="#1、单个文件加入缓存区" class="headerlink" title="1、单个文件加入缓存区"></a>1、单个文件加入缓存区</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add +需要加入缓存的文件</span><br><span class="line">git add . //将所有文件加入跟踪</span><br></pre></td></tr></table></figure><h5 id="2、撤销add添加缓存命令"><a href="#2、撤销add添加缓存命令" class="headerlink" title="2、撤销add添加缓存命令"></a>2、撤销add添加缓存命令</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset + 想要撤销的文件</span><br><span class="line">git reset . //撤销add 的所有文件</span><br></pre></td></tr></table></figure><h5 id="3、将缓存区里面的内容提交-x2F-修改"><a href="#3、将缓存区里面的内容提交-x2F-修改" class="headerlink" title="3、将缓存区里面的内容提交&#x2F;修改"></a>3、将缓存区里面的内容提交&#x2F;修改</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//提交</span><br><span class="line">git commit -m &quot;需要添加的注释&quot;</span><br><span class="line">//修改commit提交的信息</span><br><span class="line">git commit --amend + 修改commit提交的信息</span><br></pre></td></tr></table></figure><h5 id="4、创建分支-x2F-查看分支-x2F-切换分支-x2F-合并分支"><a href="#4、创建分支-x2F-查看分支-x2F-切换分支-x2F-合并分支" class="headerlink" title="4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支"></a>4、创建分支&#x2F;查看分支&#x2F;切换分支&#x2F;合并分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//创建分支</span><br><span class="line">git branch + 创建分支名</span><br><span class="line">//查看分支</span><br><span class="line">git branch</span><br><span class="line">//切换分支</span><br><span class="line">git checkout + 切换分支名</span><br><span class="line"></span><br><span class="line">//切换分支 如果没有分支就创建分支 </span><br><span class="line">git checkout -b +分支名</span><br><span class="line"></span><br><span class="line">//分支合并</span><br><span class="line">git merge + 分支名称</span><br></pre></td></tr></table></figure><h5 id="5、删除分支"><a href="#5、删除分支" class="headerlink" title="5、删除分支"></a>5、删除分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//删除时需要做检查</span><br><span class="line">git branch -d +分支名称 （要做检查的删除分支）</span><br><span class="line">//删除时不需要做任何检查</span><br><span class="line">git branch -D +分支名称 （不做任何检查的强制删除）</span><br></pre></td></tr></table></figure><h5 id="6、查看提交的历史信息"><a href="#6、查看提交的历史信息" class="headerlink" title="6、查看提交的历史信息"></a>6、查看提交的历史信息</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//查看提交的详细历史信息</span><br><span class="line">git log git log --graph --oneline (以图形化界面查看)</span><br><span class="line">//获取每条日志的简要信息</span><br><span class="line">git log --pretty=oneline</span><br><span class="line">//查看本地的操作历史</span><br><span class="line">git reflog</span><br></pre></td></tr></table></figure><h5 id="7、配置SSH公钥"><a href="#7、配置SSH公钥" class="headerlink" title="7、配置SSH公钥"></a>7、配置SSH公钥</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//生成公钥</span><br><span class="line">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br><span class="line">//获取公钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">//查看公钥是否添加成功</span><br><span class="line"> ssh -T git@gitee.com</span><br></pre></td></tr></table></figure><h5 id="8、远程仓库的添加-x2F-推送-x2F-查看-x2F-删除-x2F-拉取"><a href="#8、远程仓库的添加-x2F-推送-x2F-查看-x2F-删除-x2F-拉取" class="headerlink" title="8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取"></a>8、远程仓库的添加&#x2F;推送&#x2F;查看&#x2F;删除&#x2F;拉取</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//远程仓库的添加</span><br><span class="line">git remote add origin +(远程仓库地址)</span><br><span class="line">//远程仓库的查看</span><br><span class="line"> git remote</span><br><span class="line">//远程仓库的推送</span><br><span class="line"> git push origin master</span><br><span class="line"> git pull --rebase origin master（如果推送不成功使用这个）（保持远端和本地数据同步）</span><br><span class="line"> //与远端分支关系绑定</span><br><span class="line">  git push --set-upstream origin master:master （与远端关系绑定） （本地master） (远端master)</span><br><span class="line"> //删除指定远程分支</span><br><span class="line">  git push origin --delete master git push origin :master</span><br><span class="line"> //指定拉取分支</span><br><span class="line"> git pull origin master（如果pull出现冲突，可以版本回退和 封存修改，pull之后在还原）</span><br></pre></td></tr></table></figure><h5 id="9、查看本地分支与远程分支的对应关系"><a href="#9、查看本地分支与远程分支的对应关系" class="headerlink" title="9、查看本地分支与远程分支的对应关系"></a>9、查看本地分支与远程分支的对应关系</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -vv</span><br></pre></td></tr></table></figure><h5 id="10、git克隆"><a href="#10、git克隆" class="headerlink" title="10、git克隆"></a>10、git克隆</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone + 克隆地址</span><br></pre></td></tr></table></figure><h5 id="11、git版本回退"><a href="#11、git版本回退" class="headerlink" title="11、git版本回退"></a>11、git版本回退</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//git 回退到你想要回退的版本号</span><br><span class="line">git reset --hard + 版本对应的id</span><br></pre></td></tr></table></figure><h5 id="12、强制拉取合并分支"><a href="#12、强制拉取合并分支" class="headerlink" title="12、强制拉取合并分支"></a>12、强制拉取合并分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure><h5 id="13、删除远程仓库"><a href="#13、删除远程仓库" class="headerlink" title="13、删除远程仓库"></a>13、删除远程仓库</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin </span><br></pre></td></tr></table></figure><h5 id="14、创建远端仓库分支"><a href="#14、创建远端仓库分支" class="headerlink" title="14、创建远端仓库分支"></a>14、创建远端仓库分支</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin + 本地分支</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git常用命令&quot;&gt;&lt;a href=&quot;#git常用命令&quot; class=&quot;headerlink&quot; title=&quot;git常用命令&quot;&gt;&lt;/a&gt;git常用命令&lt;/h2&gt;&lt;h5 id=&quot;1、单个文件加入缓存区&quot;&gt;&lt;a href=&quot;#1、单个文件加入缓存区&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>markdown使用说明</title>
    <link href="http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://example.com/2022/08/25/markdown%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2022-08-25T15:17:46.000Z</published>
    <updated>2022-08-30T12:16:49.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="markdown-使用说明"><a href="#markdown-使用说明" class="headerlink" title="markdown 使用说明"></a>markdown 使用说明</h2><h4 id="功能快捷键"><a href="#功能快捷键" class="headerlink" title="功能快捷键"></a>功能快捷键</h4><p>撤销：<kbd>Ctrl/Command</kbd> + <kbd>Z</kbd><br>重做：<kbd>Ctrl/Command</kbd> + <kbd>Y</kbd><br>加粗：<kbd>Ctrl/Command</kbd> + <kbd>B</kbd><br>斜体：<kbd>Ctrl/Command</kbd> + <kbd>I</kbd><br>标题：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>H</kbd><br>无序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>U</kbd><br>有序列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>O</kbd><br>检查列表：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>C</kbd><br>插入代码：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>K</kbd><br>插入链接：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>L</kbd><br>插入图片：<kbd>Ctrl/Command</kbd> + <kbd>Shift</kbd> + <kbd>G</kbd><br>查找：<kbd>Ctrl/Command</kbd> + <kbd>F</kbd><br>替换：<kbd>Ctrl/Command</kbd> + <kbd>G</kbd></p><h4 id="标题的创建"><a href="#标题的创建" class="headerlink" title="标题的创建"></a>标题的创建</h4><p>直接输入1次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成1级标题。<br>输入2次<kbd>#</kbd>，并按下<kbd>space</kbd>后，将生成2级标题。<br>以此类推，我们支持6级标题。有助于使用<code>TOC</code>语法后生成一个完美的目录。</p><h4 id="如何改变文本的样式、"><a href="#如何改变文本的样式、" class="headerlink" title="如何改变文本的样式、"></a>如何改变文本的样式、</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*强调文本* _强调文本_</span><br><span class="line"></span><br><span class="line">**加粗文本** __加粗文本__</span><br><span class="line"></span><br><span class="line">==标记文本==</span><br><span class="line"></span><br><span class="line">~~删除文本~~</span><br><span class="line"></span><br><span class="line">&gt; 引用文本</span><br><span class="line"></span><br><span class="line">H~2~O is是液体。</span><br><span class="line"></span><br><span class="line">2^10^ 运算结果是 1024.</span><br></pre></td></tr></table></figure><p><em>强调文本</em> <em>强调文本</em></p><p><strong>加粗文本</strong> <strong>加粗文本</strong></p><p>&#x3D;&#x3D;标记文本&#x3D;&#x3D;</p><p><del>删除文本</del></p><blockquote><p>引用文本</p></blockquote><p>H<del>2</del>O is是液体。</p><p>2^10^ 运算结果是 1024.</p><h4 id="插入链接与图片"><a href="#插入链接与图片" class="headerlink" title="插入链接与图片"></a>插入链接与图片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: [link](https://www.csdn.net/).</span><br></pre></td></tr></table></figure><p>链接: <a href="https://www.csdn.net/">link</a>.</p><h4 id="生成列表"><a href="#生成列表" class="headerlink" title="生成列表"></a>生成列表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 项目</span><br><span class="line">  - 项目</span><br><span class="line">    - 项目</span><br><span class="line"></span><br><span class="line">1. 项目1</span><br><span class="line">2. 项目2</span><br><span class="line">3. 项目3</span><br><span class="line"></span><br><span class="line">- [ ] 计划任务</span><br><span class="line">- [x] 完成任务</span><br></pre></td></tr></table></figure><ul><li>项目<ul><li>项目<ul><li>项目</li></ul></li></ul></li></ul><ol><li>项目1</li><li>项目2</li><li>项目3</li></ol><ul><li><input disabled type="checkbox"> 计划任务</li><li><input checked disabled type="checkbox"> 完成任务</li></ul><h4 id="创建表格"><a href="#创建表格" class="headerlink" title="创建表格"></a>创建表格</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">项目     | Value</span><br><span class="line">-------- | -----</span><br><span class="line">电脑  | $1600</span><br><span class="line">手机  | $12</span><br><span class="line">导管  | $1</span><br></pre></td></tr></table></figure><table><thead><tr><th>项目</th><th>Value</th></tr></thead><tbody><tr><td>电脑</td><td>$1600</td></tr><tr><td>手机</td><td>$12</td></tr><tr><td>导管</td><td>$1</td></tr></tbody></table><h4 id="设定内容居中，居左，居右"><a href="#设定内容居中，居左，居右" class="headerlink" title="设定内容居中，居左，居右"></a>设定内容居中，居左，居右</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用`:---------:`居中</span><br><span class="line">使用`:----------`居左</span><br><span class="line">使用`----------:`居右</span><br><span class="line">| 第一列       | 第二列         | 第三列        |</span><br><span class="line">|:-----------:| :-------------:|:-------------|</span><br><span class="line">| 第一列文本居中 | 第二列文本居右  | 第三列文本居左 |</span><br></pre></td></tr></table></figure><p>使用<code>:---------:</code>居中<br>使用<code>:----------</code>居左<br>使用<code>----------:</code>居右</p><table><thead><tr><th align="center">第一列</th><th align="center">第二列</th><th align="left">第三列</th></tr></thead><tbody><tr><td align="center">第一列文本居中</td><td align="center">第二列文本居右</td><td align="left">第三列文本居左</td></tr></tbody></table><h4 id="创建一个注脚"><a href="#创建一个注脚" class="headerlink" title="创建一个注脚"></a>创建一个注脚</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一个具有注脚的文本。[^2]</span><br><span class="line"></span><br><span class="line">[^2]: 注脚的解释</span><br></pre></td></tr></table></figure><p>一个具有注脚的文本。<a href="%E6%B3%A8%E8%84%9A%E7%9A%84%E8%A7%A3%E9%87%8A">^2</a></p><h4 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">这将产生一个流程图。:</span><br><span class="line"></span><br><span class="line">​```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br><span class="line">​```</span><br></pre></td></tr></table></figure><p>这将产生一个流程图。:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[长方形] -- 链接 --&gt; B((圆))</span><br><span class="line">A --&gt; C(圆角长方形)</span><br><span class="line">B --&gt; D&#123;菱形&#125;</span><br><span class="line">C --&gt; D</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;markdown-使用说明&quot;&gt;&lt;a href=&quot;#markdown-使用说明&quot; class=&quot;headerlink&quot; title=&quot;markdown 使用说明&quot;&gt;&lt;/a&gt;markdown 使用说明&lt;/h2&gt;&lt;h4 id=&quot;功能快捷键&quot;&gt;&lt;a href=&quot;#功能快捷</summary>
      
    
    
    
    
    <category term="md" scheme="http://example.com/tags/md/"/>
    
  </entry>
  
</feed>
