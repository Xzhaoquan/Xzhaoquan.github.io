<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>Siwat</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-09-13T01:49:59.224Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Napat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Qt信号和槽</title>
    <link href="http://example.com/2023/09/12/Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/"/>
    <id>http://example.com/2023/09/12/Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD/</id>
    <published>2023-09-12T09:27:00.000Z</published>
    <updated>2023-09-13T01:49:59.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt信号与槽"><a href="#Qt信号与槽" class="headerlink" title="Qt信号与槽"></a>Qt信号与槽</h2><h4 id="QT信号与槽机制"><a href="#QT信号与槽机制" class="headerlink" title="QT信号与槽机制"></a>QT信号与槽机制</h4><p>信号（signal）：在特定情况下被发送的事件</p><p>槽（slot）：对信号响应的函数，槽函数可以与一个信号关联，当信号被发送时，槽函数自动执行。</p><p>信号与槽关联使用QObject::connect()函数实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example：</span><br><span class="line">QObject::connect(sender,SIGNAL(signal()),receiver,SLOT(slot()));</span><br><span class="line">connect(sender,SIGNAL(signal()),receiver,SLOT(slot()));</span><br><span class="line">上面两种写法都可以，因为QObject是QT的基类，在调用是可以忽略前面的限定符。</span><br><span class="line">sender:发送信号的对象</span><br><span class="line">receiver:接受信号的对象</span><br><span class="line">SIGNAL和SLOT是QT的宏，用于指明信号和槽，并将参数转化成相应字符串。</span><br><span class="line">signal:需要发送的信号</span><br><span class="line">slot:接收信号的槽</span><br></pre></td></tr></table></figure><h5 id="信号的创建"><a href="#信号的创建" class="headerlink" title="信号的创建"></a>信号的创建</h5><ul><li>在mainwindow.h里面引入 <QPushButton></QPushButton></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QPushButton&gt;</span><br></pre></td></tr></table></figure><ul><li>声明一个信号</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">signals:</span><br><span class="line">    void pushButtonTextChanged();</span><br></pre></td></tr></table></figure><h5 id="槽的创建"><a href="#槽的创建" class="headerlink" title="槽的创建"></a>槽的创建</h5><ul><li>直接在mainwindow.h里面声明槽。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public slots:</span><br><span class="line">    void changeButtonText();</span><br><span class="line">    void pushButtonClicked();</span><br></pre></td></tr></table></figure><ul><li>并且在mainwindow.cpp里面实现槽的定义。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::pushButtonClicked()&#123;</span><br><span class="line">    /*use emit send signal*/</span><br><span class="line">    emit pushButtonTextChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::changeButtonText()&#123;</span><br><span class="line">    pushButton-&gt;setText(&quot;按钮被按下&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>槽可以是任何成员函数，不同全局函数，静态函数。</li><li>槽函数和信号的参数和返回值要一样。</li></ul><h5 id="信号和槽的连接"><a href="#信号和槽的连接" class="headerlink" title="信号和槽的连接"></a>信号和槽的连接</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));</span><br><span class="line">connect(this,SIGNAL(pushButtonTextChanged()),this,SLOT(changeButtonText()));</span><br></pre></td></tr></table></figure><h5 id="mainwindow如下："><a href="#mainwindow如下：" class="headerlink" title="mainwindow如下："></a>mainwindow如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    /*set windows width hight 480 * 800*/</span><br><span class="line">    this-&gt;resize(800,480);</span><br><span class="line">    /*create QPushBotton Class*/</span><br><span class="line">    pushButton = new QPushButton(this);</span><br><span class="line">    /*use setText() set text infomation*/</span><br><span class="line">    pushButton-&gt;setText(&quot;按钮&quot;);</span><br><span class="line"></span><br><span class="line">    /*signal slot connect signal*/</span><br><span class="line">    connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));</span><br><span class="line">    connect(this,SIGNAL(pushButtonTextChanged()),this,SLOT(changeButtonText()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::pushButtonClicked()&#123;</span><br><span class="line">    /*use emit send signal*/</span><br><span class="line">    emit pushButtonTextChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::changeButtonText()&#123;</span><br><span class="line">    pushButton-&gt;setText(&quot;按钮被按下&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt信号与槽&quot;&gt;&lt;a href=&quot;#Qt信号与槽&quot; class=&quot;headerlink&quot; title=&quot;Qt信号与槽&quot;&gt;&lt;/a&gt;Qt信号与槽&lt;/h2&gt;&lt;h4 id=&quot;QT信号与槽机制&quot;&gt;&lt;a href=&quot;#QT信号与槽机制&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt输入窗口部件</title>
    <link href="http://example.com/2023/09/12/Qt%E8%BE%93%E5%85%A5%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6/"/>
    <id>http://example.com/2023/09/12/Qt%E8%BE%93%E5%85%A5%E7%AA%97%E5%8F%A3%E9%83%A8%E4%BB%B6/</id>
    <published>2023-09-12T09:26:46.000Z</published>
    <updated>2023-09-13T08:31:59.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt窗口输入部件"><a href="#Qt窗口输入部件" class="headerlink" title="Qt窗口输入部件"></a>Qt窗口输入部件</h2><h3 id="1、QComboBox"><a href="#1、QComboBox" class="headerlink" title="1、QComboBox"></a>1、QComboBox</h3><p>QComboBox提供下拉组合框的组件。</p><h3 id="QComboBox使用示例"><a href="#QComboBox使用示例" class="headerlink" title="QComboBox使用示例"></a>QComboBox使用示例</h3><ul><li>声明<QComboBox></QComboBox></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    QComboBox *ComboBox;</span><br></pre></td></tr></table></figure><ul><li>实例化 QComboBox组件，和初始化QComboBox组件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComboBox = new QComboBox(this);</span><br><span class="line">ComboBox-&gt;setGeometry(300,200,150,30);</span><br><span class="line">ComboBox-&gt;addItem(&quot;四川(default)&quot;);</span><br><span class="line">ComboBox-&gt;addItem(&quot;云南&quot;);</span><br><span class="line">ComboBox-&gt;addItem(&quot;贵州&quot;);</span><br></pre></td></tr></table></figure><ul><li>实现信号和槽的连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(ComboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(ComboBoxIndexChanged(int)));</span><br></pre></td></tr></table></figure><ul><li>实现QComboBox的槽函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::ComboBoxIndexChanged(int index)&#123;</span><br><span class="line">    qDebug()&lt;&lt;&quot;您选择的省份是&quot;&lt;&lt;ComboBox-&gt;itemText(index)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="示例代码如下"><a href="#示例代码如下" class="headerlink" title="示例代码如下"></a>示例代码如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    ComboBox = new QComboBox(this);</span><br><span class="line">    ComboBox-&gt;setGeometry(300,200,150,30);</span><br><span class="line">    ComboBox-&gt;addItem(&quot;四川(default)&quot;);</span><br><span class="line">    ComboBox-&gt;addItem(&quot;云南&quot;);</span><br><span class="line">    ComboBox-&gt;addItem(&quot;贵州&quot;);</span><br><span class="line">    connect(ComboBox,SIGNAL(currentIndexChanged(int)),this,SLOT(ComboBoxIndexChanged(int)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::ComboBoxIndexChanged(int index)&#123;</span><br><span class="line">    qDebug()&lt;&lt;&quot;您选择的省份是&quot;&lt;&lt;ComboBox-&gt;itemText(index)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、QFontComboBox"><a href="#2、QFontComboBox" class="headerlink" title="2、QFontComboBox"></a>2、QFontComboBox</h3><p>QFontComboBox 类提供了下拉选择字体系列的组合框小部件。  </p><h3 id="QFontComboBox使用示例"><a href="#QFontComboBox使用示例" class="headerlink" title="QFontComboBox使用示例"></a>QFontComboBox使用示例</h3><ul><li><p>引入<QFontComboBox></QFontComboBox></p></li><li><p>声明QFontComboBox对象</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    QFontComboBox *FontConboBox;</span><br></pre></td></tr></table></figure><ul><li>实例化对象QFontComboBox</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FontConboBox = new QFontComboBox(this);</span><br><span class="line">    Label = new QLabel(this);</span><br><span class="line"></span><br><span class="line">    FontConboBox-&gt;setGeometry(280,200,200,30);</span><br><span class="line">    Label-&gt;setGeometry(280,250,300,50);</span><br></pre></td></tr></table></figure><ul><li>实现槽函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*将lable里面的文本内容设置为所选择的字体*/</span><br><span class="line">    Label-&gt;setFont(Font);</span><br><span class="line">    /*定义一个字符串接收当前项的字体*/</span><br><span class="line">    QString str = &quot;用此标签显示字体效果\n设置的字体为:&quot; +</span><br><span class="line">            FontConboBox-&gt;itemText(FontConboBox-&gt;currentIndex());</span><br><span class="line">    /*将字符串的内容作为lable的显示内容*/</span><br><span class="line">    Label-&gt;setText(str);</span><br></pre></td></tr></table></figure><ul><li>连接信号和槽</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(FontConboBox,SIGNAL(currentFontChanged(QFont)),this,SLOT(FontComboBoxFontChanged(QFont)));</span><br></pre></td></tr></table></figure><h5 id="代码示例如下"><a href="#代码示例如下" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    FontConboBox = new QFontComboBox(this);</span><br><span class="line">    Label = new QLabel(this);</span><br><span class="line"></span><br><span class="line">    FontConboBox-&gt;setGeometry(280,200,200,30);</span><br><span class="line">    Label-&gt;setGeometry(280,250,300,50);</span><br><span class="line"></span><br><span class="line">    connect(FontConboBox,SIGNAL(currentFontChanged(QFont)),this,SLOT(FontComboBoxFontChanged(QFont)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::FontComboBoxFontChanged(QFont Font)&#123;</span><br><span class="line">    /*将lable里面的文本内容设置为所选择的字体*/</span><br><span class="line">    Label-&gt;setFont(Font);</span><br><span class="line">    /*定义一个字符串接收当前项的字体*/</span><br><span class="line">    QString str = &quot;用此标签显示字体效果\n设置的字体为:&quot; +</span><br><span class="line">            FontConboBox-&gt;itemText(FontConboBox-&gt;currentIndex());</span><br><span class="line">    /*将字符串的内容作为lable的显示内容*/</span><br><span class="line">    Label-&gt;setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、QLineEdit"><a href="#3、QLineEdit" class="headerlink" title="3、QLineEdit"></a>3、QLineEdit</h3><p>QLineEdit 小部件是一个单行文本编辑器。  </p><h4 id="QLineEdit的使用示例"><a href="#QLineEdit的使用示例" class="headerlink" title="QLineEdit的使用示例"></a>QLineEdit的使用示例</h4><ul><li>引入<QLineEdit></QLineEdit></li><li>声明和实例化QLineEdit</li><li>实现和连接槽函数</li></ul><h5 id="示例代码如下-1"><a href="#示例代码如下-1" class="headerlink" title="示例代码如下"></a>示例代码如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    LineEdit = new QLineEdit(this);</span><br><span class="line">    LineEdit-&gt;setGeometry(280,200,200,20);</span><br><span class="line">    PushButton = new QPushButton(this);</span><br><span class="line">    PushButton-&gt;setGeometry(500,200,50,20);</span><br><span class="line">    PushButton-&gt;setText(&quot;确认&quot;);</span><br><span class="line">    Label = new QLabel(this);</span><br><span class="line">    Label-&gt;setGeometry(280,250,400,20);</span><br><span class="line">    Label-&gt;setText(&quot;您输入的内容是:&quot;);</span><br><span class="line"></span><br><span class="line">    connect(PushButton,SIGNAL(clicked()),this,SLOT(PushButtonClicked()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::PushButtonClicked()&#123;</span><br><span class="line">    QString str;</span><br><span class="line"></span><br><span class="line">    str = &quot;您输入的内容是: &quot;;</span><br><span class="line">    str += LineEdit-&gt;text();</span><br><span class="line">    /*设置label文本显示内容*/</span><br><span class="line">    Label-&gt;setText(str);</span><br><span class="line">    /*点击确认键之后清空LineEdit单行输入框*/</span><br><span class="line">    LineEdit-&gt;clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、QTextEdit"><a href="#4、QTextEdit" class="headerlink" title="4、QTextEdit"></a>4、QTextEdit</h3><p>QTextEdit 类提供了一个查看器&#x2F;编辑器小部件。  </p><h4 id="QTextEdit的使用示例"><a href="#QTextEdit的使用示例" class="headerlink" title="QTextEdit的使用示例"></a>QTextEdit的使用示例</h4><ul><li>引入<QTextEdit></QTextEdit></li><li>声明和实例化QTextEdit</li><li>实现槽函数和信号和槽的连接</li></ul><h5 id="代码示例如下-1"><a href="#代码示例如下-1" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    textEdit = new QTextEdit(this);</span><br><span class="line">    textEdit-&gt;setGeometry(0,0,800,400);</span><br><span class="line"></span><br><span class="line">    pushButtonSelect = new QPushButton(this);</span><br><span class="line">    pushButtonSelect-&gt;setGeometry(200,420,50,30);</span><br><span class="line">    pushButtonSelect-&gt;setText(&quot;全选&quot;);</span><br><span class="line"></span><br><span class="line">    pushButtonClear = new QPushButton(this);</span><br><span class="line">    pushButtonClear-&gt;setGeometry(500,420,50,30);</span><br><span class="line">    pushButtonClear-&gt;setText(&quot;清除&quot;);</span><br><span class="line"></span><br><span class="line">    connect(pushButtonSelect,SIGNAL(clicked()),this,SLOT(pushButtonSelectAllClicked()));</span><br><span class="line">    connect(pushButtonClear,SIGNAL(clicked()),this,SLOT(pushButtonClearAllClicked()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::pushButtonSelectAllClicked()&#123;</span><br><span class="line">    /*设置焦点为textEdit*/</span><br><span class="line">    textEdit-&gt;setFocus();</span><br><span class="line">    /*判断文本编辑内容是否为空，不为空则全选*/</span><br><span class="line">    if(!textEdit-&gt;toPlainText().isEmpty())&#123;</span><br><span class="line">        textEdit-&gt;selectAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::pushButtonClearAllClicked()&#123;</span><br><span class="line">    /*清空textEdit里面的内容*/</span><br><span class="line">    textEdit-&gt;clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、QPlainTextEdit"><a href="#5、QPlainTextEdit" class="headerlink" title="5、QPlainTextEdit"></a>5、QPlainTextEdit</h3><p>QPlainTextEdit 类提供了一个用于编辑和显示纯文本的小部件，常用于显示多行文本或简单<br>文本。  </p><h5 id="示例代码如下-2"><a href="#示例代码如下-2" class="headerlink" title="示例代码如下"></a>示例代码如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QDir&gt;</span><br><span class="line">#include &lt;QTextStream&gt;</span><br><span class="line">#include &lt;QCoreApplication&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    /*设置当前程序的工作目录为可执行程序的工作目录*/</span><br><span class="line">    QDir::setCurrent(QCoreApplication::applicationDirPath());</span><br><span class="line"></span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    plainTextEdit = new QPlainTextEdit(this);</span><br><span class="line">    plainTextEdit-&gt;setGeometry(0,50,800,430);</span><br><span class="line"></span><br><span class="line">    radioButton = new QRadioButton(this);</span><br><span class="line">    radioButton-&gt;setGeometry(650,20,100,20);</span><br><span class="line">    radioButton-&gt;setText(&quot;只读模式&quot;);</span><br><span class="line"></span><br><span class="line">    /*打开可执行程序目录里面的moc_mainwindow.cpp.cpp*/</span><br><span class="line">    QFile file(&quot;moc_mainwindow.cpp&quot;);</span><br><span class="line">    /*以只读模式打开，但是可以在plainTextEdit里面编辑*/</span><br><span class="line">    file.open(QFile::ReadOnly | QFile::Text);</span><br><span class="line">    /*加载到文件流*/</span><br><span class="line">    QTextStream in(&amp;file);</span><br><span class="line">    /*从文件流中读取全部*/</span><br><span class="line">    plainTextEdit-&gt;insertPlainText(in.readAll());</span><br><span class="line">    connect(radioButton,SIGNAL(clicked()),this,SLOT(radioButtonClicked()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::radioButtonClicked()&#123;</span><br><span class="line">    if(radioButton-&gt;isChecked())&#123;</span><br><span class="line">        /*设置为只读模式*/</span><br><span class="line">        plainTextEdit-&gt;setReadOnly(true);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        plainTextEdit-&gt;setReadOnly(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、QSpinBox"><a href="#6、QSpinBox" class="headerlink" title="6、QSpinBox"></a>6、QSpinBox</h3><p>QSpinBox 类提供了一个微调框小部件  </p><h5 id="示例代码如下-3"><a href="#示例代码如下-3" class="headerlink" title="示例代码如下"></a>示例代码如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    this-&gt;setStyleSheet(&quot;QMainWindow &#123;background-color: rgba(100,100,100,100%)&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    SpinBox = new QSpinBox(this);</span><br><span class="line">    SpinBox-&gt;setGeometry(350,200,150,30);</span><br><span class="line"></span><br><span class="line">    /*设置范围0~100*/</span><br><span class="line">    SpinBox-&gt;setRange(0,100);</span><br><span class="line">    /*设置步长值为10*/</span><br><span class="line">    SpinBox-&gt;setSingleStep(10);</span><br><span class="line">    /*设置初始值为100*/</span><br><span class="line">    SpinBox-&gt;setValue(100);</span><br><span class="line">    /*设置后缀*/</span><br><span class="line">    SpinBox-&gt;setSuffix(&quot;%不透明度&quot;);</span><br><span class="line">    connect(SpinBox,SIGNAL(valueChanged(int)),this,SLOT(spinBoxValueChanged(int)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::spinBoxValueChanged(int value)&#123;</span><br><span class="line">    /*转换为double 数据类型*/</span><br><span class="line">    double dvalue = (double)value / 100;</span><br><span class="line">    this-&gt;setWindowOpacity(dvalue);</span><br><span class="line">    qDebug()&lt;&lt; &quot;value is: &quot;&lt;&lt;value&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7、QDoubleSpinBox"><a href="#7、QDoubleSpinBox" class="headerlink" title="7、QDoubleSpinBox"></a>7、QDoubleSpinBox</h3><p>QDoubleSpinBox 类提供了一个用于处理浮点值微调框小部件。与 QSpinBox 作用基本一样，<br>与 QSpinBox 不同的是， QDoubleSpinBox 类处理的是浮点值数据。  </p><h5 id="示例代码如下-4"><a href="#示例代码如下-4" class="headerlink" title="示例代码如下"></a>示例代码如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    /*实例化和设置显示的位置大小*/</span><br><span class="line">    DoubleSpinBox = new QDoubleSpinBox(this);</span><br><span class="line">    DoubleSpinBox-&gt;setGeometry((this-&gt;width() - 200)/2,(this-&gt;height() - 30) / 2,200,30);</span><br><span class="line">    /*设置前缀*/</span><br><span class="line">    DoubleSpinBox-&gt;setPrefix(&quot;窗口大小&quot;);</span><br><span class="line">    /*设置后缀*/</span><br><span class="line">    DoubleSpinBox-&gt;setSuffix(&quot;%&quot;);</span><br><span class="line">    /*设置范围*/</span><br><span class="line">    DoubleSpinBox-&gt;setRange(50.00,100.00);</span><br><span class="line">    /*设置初始值*/</span><br><span class="line">    DoubleSpinBox-&gt;setValue(100.00);</span><br><span class="line">    /*设置步长*/</span><br><span class="line">    DoubleSpinBox-&gt;setSingleStep(0.1);</span><br><span class="line"></span><br><span class="line">    connect(DoubleSpinBox,SIGNAL(valueChanged(double)),this,SLOT(DoubleSpinBoxValueChanged(double)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::DoubleSpinBoxValueChanged(double value)&#123;</span><br><span class="line">    int width = 800 * value / 100;</span><br><span class="line">    int height = 480 *value / 100;</span><br><span class="line"></span><br><span class="line">    this-&gt;setGeometry(0,0,width,height);</span><br><span class="line">    DoubleSpinBox-&gt;setGeometry((this-&gt;width() - 200)/2,</span><br><span class="line">                               (this-&gt;height() - 30) / 2,200,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8、QTimeEdit-QTimeDateEdit-QDateEdit"><a href="#8、QTimeEdit-QTimeDateEdit-QDateEdit" class="headerlink" title="8、QTimeEdit QTimeDateEdit QDateEdit"></a>8、QTimeEdit QTimeDateEdit QDateEdit</h3><p>QTimeEdit 类提供一个基于 QDateTimeEdit 类编辑时间的小部件。  </p><p>QDateEdit 类提供一个基于 QDateTimeEdit 类编辑时间的小部件。  </p><p>QDateTimeEdit 类提供了一个用于编辑日期和时间的小部件。 QDateTimeEdit<br>允许用户使用键盘或箭头键编辑日期，以增加或减少日期和时间值。  </p><h5 id="代码示例如下-2"><a href="#代码示例如下-2" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    /*实例化对象，传入当前日期和时间*/</span><br><span class="line">    dateTimeEdit = new QDateTimeEdit(QDateTime::currentDateTime(),this);</span><br><span class="line">    dateTimeEdit-&gt;setGeometry(300,200,200,30);</span><br><span class="line"></span><br><span class="line">    /*设置弹出日期控件与否*/</span><br><span class="line">    dateTimeEdit-&gt;setCalendarPopup(true);</span><br><span class="line">    /*实例化对象，传入当前时间*/</span><br><span class="line">    timeEdit = new QTimeEdit(QTime::currentTime(),this);</span><br><span class="line">    timeEdit-&gt;setGeometry(300,240,200,30);</span><br><span class="line">    /*实例化对象传入当前日期*/</span><br><span class="line">    dateEdit = new QDateEdit(QDate::currentDate(),this);</span><br><span class="line">    dateEdit-&gt;setGeometry(300,280,200,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9、QDial"><a href="#9、QDial" class="headerlink" title="9、QDial"></a>9、QDial</h3><p>QDial 类提供了一个圆形范围控制(如速度计或电位器)。 QDial 用于当用户需要在可编程定义的范围内控制一个值，并且该范围要么是环绕的(例如，从 0 到 359 度测量的角度)，要么对话框布局需要一个正方形小部件。  当 wrapping（）为 false（默认设置）时，滑块和刻度盘之间没有真正的区别。  </p><h5 id="代码示例如下-3"><a href="#代码示例如下-3" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    dial = new QDial(this);</span><br><span class="line">    dial-&gt;setGeometry(300,100,200,200);</span><br><span class="line"></span><br><span class="line">    /*设置页长(两个最大刻度的间距)*/</span><br><span class="line">    dial-&gt;setPageStep(10);</span><br><span class="line">    /*设置刻度可见*/</span><br><span class="line">    dial-&gt;setNotchesVisible(true);</span><br><span class="line">    /*设置两个凹槽之间的目标像素数*/</span><br><span class="line">    dial-&gt;setNotchTarget(1.00);</span><br><span class="line">    /*设置dial值的范围*/</span><br><span class="line">    dial-&gt;setRange(0,100);</span><br><span class="line">//    /*开启后可以指向圆的任何角度*/</span><br><span class="line">//    dial-&gt;setWrapping(true);</span><br><span class="line"></span><br><span class="line">    label = new QLabel(this);</span><br><span class="line">    label-&gt;setGeometry(370,300,200,50);</span><br><span class="line">    label-&gt;setText(&quot;0km/h&quot;);</span><br><span class="line"></span><br><span class="line">    connect(dial,SIGNAL(valueChanged(int)),this,SLOT(dialValueChanged(int)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::dialValueChanged(int value)&#123;</span><br><span class="line">    /*使用QString::number()转化成字符串*/</span><br><span class="line">    label-&gt;setText(QString::number(value) + &quot;km/h&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10、QScroolBar"><a href="#10、QScroolBar" class="headerlink" title="10、QScroolBar"></a>10、QScroolBar</h3><p>QScrollBar 继承 QAbstractSlider。 QScrollBar 小部件提供垂直或水平滚动条，允许用户访问比用于显示文档的小部件大的文档部分。它提供了用户在文档中的当前位置和可见文档数量的可视化指示。  </p><h5 id="代码示例如下-4"><a href="#代码示例如下-4" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    /*实例化水平滚动条hScrollBar*/</span><br><span class="line">    hScrollBar = new QScrollBar(Qt::Horizontal,this);</span><br><span class="line">    hScrollBar-&gt;setGeometry(0,450,800,30);</span><br><span class="line">    /*实例化竖直滚动条vScrollBar*/</span><br><span class="line">    vScrollBar = new QScrollBar(Qt::Vertical,this);</span><br><span class="line">    vScrollBar-&gt;setGeometry(770,0,30,480);</span><br><span class="line"></span><br><span class="line">    label = new QLabel(this);</span><br><span class="line">    label-&gt;setText(&quot;这是一个测试&quot;);</span><br><span class="line">    label-&gt;setGeometry(300,200,120,30);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="11、QSlider"><a href="#11、QSlider" class="headerlink" title="11、QSlider"></a>11、QSlider</h3><p>QSlider 继承 QAbstractSlider。 QScrollBar 类提供垂直或水平滑动条小部件，滑动条是用于控制有界值的典型小部件。它允许用户沿着水平或垂直凹槽移动滑块手柄，并将手柄的位置转换为合法范围内的整数值。  </p><h5 id="代码示例如下-5"><a href="#代码示例如下-5" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    vSlider = new QSlider(Qt::Vertical,this);</span><br><span class="line">    vSlider-&gt;setGeometry(200,50,20,200);</span><br><span class="line">    vSlider-&gt;setRange(0,100);</span><br><span class="line"></span><br><span class="line">    hSlider = new QSlider(Qt::Horizontal,this);</span><br><span class="line">    hSlider-&gt;setGeometry(250,100,200,20);</span><br><span class="line">    hSlider-&gt;setRange(0,100);</span><br><span class="line"></span><br><span class="line">    label = new QLabel(&quot;滑动条值: 0&quot;,this);</span><br><span class="line">    label-&gt;setGeometry(250,200,100,20);</span><br><span class="line"></span><br><span class="line">    connect(vSlider,SIGNAL(valueChanged(int)),this,SLOT(vSliderValueChanged(int)));</span><br><span class="line">    connect(hSlider,SIGNAL(valueChanged(int)),this,SLOT(hSliderValueChanged(int)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::vSliderValueChanged(int value)&#123;</span><br><span class="line">    hSlider-&gt;setSliderPosition(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::hSliderValueChanged(int value)&#123;</span><br><span class="line">    /*当水平滑动条的值改变时，改变垂直滑动条的值*/</span><br><span class="line">    vSlider-&gt;setSliderPosition(value);</span><br><span class="line">    QString str = &quot;滑动条值: &quot; + QString::number(value);</span><br><span class="line">    label-&gt;setText(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="12、QKeySequenceEdit"><a href="#12、QKeySequenceEdit" class="headerlink" title="12、QKeySequenceEdit"></a>12、QKeySequenceEdit</h3><p>QKeySequenceEdit 继承 QWidget。这个小部件允许用户选择 QKeySequence, QKeySequence通常用作快捷方式。当小部件接收到焦点并在用户释放最后一个键后一秒结束时，将启动记录，通常用作记录快捷键。  </p><h5 id="代码示例如下-6"><a href="#代码示例如下-6" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    KeySequenceEdit = new QKeySequenceEdit(this);</span><br><span class="line">    KeySequenceEdit-&gt;setGeometry(350,200,150,30);</span><br><span class="line"></span><br><span class="line">    connect(KeySequenceEdit,SIGNAL(keySequenceChanged(const QKeySequence &amp;)),</span><br><span class="line">            this,SLOT(KeySequenceEditChanged(const QKeySequence &amp;)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::KeySequenceEditChanged(const QKeySequence &amp;keySequence)&#123;</span><br><span class="line">    /*判断输入的组合键是否为Ctrl + Q，如果是则退出程序*/</span><br><span class="line">    if(keySequence == QKeySequence(tr(&quot;Ctrl+Q&quot;)))&#123;</span><br><span class="line">        this-&gt;close();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        qDebug()&lt;&lt;keySequence.toString()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt窗口输入部件&quot;&gt;&lt;a href=&quot;#Qt窗口输入部件&quot; class=&quot;headerlink&quot; title=&quot;Qt窗口输入部件&quot;&gt;&lt;/a&gt;Qt窗口输入部件&lt;/h2&gt;&lt;h3 id=&quot;1、QComboBox&quot;&gt;&lt;a href=&quot;#1、QComboBox&quot; class</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt按钮控件</title>
    <link href="http://example.com/2023/09/12/Qt%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/"/>
    <id>http://example.com/2023/09/12/Qt%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/</id>
    <published>2023-09-12T09:26:21.000Z</published>
    <updated>2023-09-13T01:49:59.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt按钮控件的使用"><a href="#Qt按钮控件的使用" class="headerlink" title="Qt按钮控件的使用"></a>Qt按钮控件的使用</h2><h2 id="按钮控件（button）"><a href="#按钮控件（button）" class="headerlink" title="按钮控件（button）"></a>按钮控件（button）</h2><ul><li>pushButton （下压按钮）</li><li>ToolButton  （工具按钮）</li><li>RadioButton （选择按钮）</li><li>CheckBox （检查框）</li><li>Command Link Button （命令连接按钮）</li><li>Dialog Button Box （对话框按钮）</li></ul><h3 id="QPushButton"><a href="#QPushButton" class="headerlink" title="QPushButton"></a>QPushButton</h3><ul><li>引入<QpushButton>类。</QpushButton></li><li>定义声明信号与槽，和实例化对象</li><li>连接信号与槽</li></ul><h4 id="代码定义声明如下"><a href="#代码定义声明如下" class="headerlink" title="代码定义声明如下"></a>代码定义声明如下</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">/* import QPushButton Class*/</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWindow(QWidget *parent = nullptr);</span><br><span class="line">    ~MainWindow();</span><br><span class="line">    /*statement signal*/</span><br><span class="line">    </span><br><span class="line">signals:</span><br><span class="line">    void pushButtonTextChanged();</span><br><span class="line">    </span><br><span class="line">    /*statement slot*/</span><br><span class="line">public slots:</span><br><span class="line">    void changeButtonText();</span><br><span class="line">    void pushButtonClicked();</span><br><span class="line">private:</span><br><span class="line">    /*statement QPushBotton Class*/</span><br><span class="line">    QPushButton *pushButton;</span><br><span class="line">&#125;;</span><br><span class="line">#endif // MAINWINDOW_H</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    /*set windows width hight 480 * 800*/</span><br><span class="line">    this-&gt;resize(800,480);</span><br><span class="line">    /*create QPushBotton Class*/</span><br><span class="line">    pushButton = new QPushButton(this);</span><br><span class="line">    /*use setText() set text infomation*/</span><br><span class="line">    pushButton-&gt;setText(&quot;按钮&quot;);</span><br><span class="line"></span><br><span class="line">    /*signal slot connect signal*/</span><br><span class="line">    connect(pushButton,SIGNAL(clicked()),this,SLOT(pushButtonClicked()));</span><br><span class="line">    connect(this,SIGNAL(pushButtonTextChanged()),this,SLOT(changeButtonText()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::pushButtonClicked()&#123;</span><br><span class="line">    /*use emit send signal*/</span><br><span class="line">    emit pushButtonTextChanged();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::changeButtonText()&#123;</span><br><span class="line">    pushButton-&gt;setText(&quot;按钮被按下&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QToolButton"><a href="#QToolButton" class="headerlink" title="QToolButton"></a>QToolButton</h3><p>​QtoolButton和QpushButton的区别是QtoolButton可以带图标。</p><h4 id="使用QtoolButton"><a href="#使用QtoolButton" class="headerlink" title="使用QtoolButton"></a>使用QtoolButton</h4><ul><li>引入<QToolButton>和<QToolBar>类</QToolBar></QToolButton></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;QToolButton&gt;</span><br><span class="line">#include &lt;QToolBar&gt;</span><br></pre></td></tr></table></figure><ul><li>声明QToolButton和QToolBar对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    QToolBar *toolBar;</span><br><span class="line">    QToolButton *toolButton;</span><br></pre></td></tr></table></figure><ul><li>实例化对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toolBar = new QToolBar(this);</span><br></pre></td></tr></table></figure><h5 id="主程序如下："><a href="#主程序如下：" class="headerlink" title="主程序如下："></a>主程序如下：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QStyle&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    /*create QToolBar Class*/</span><br><span class="line">    toolBar = new QToolBar(this);</span><br><span class="line">    toolBar-&gt;setGeometry(0,0,800,100);</span><br><span class="line">    /*create style Class,use set icon and Style*/</span><br><span class="line">    QStyle *style = QApplication::style();</span><br><span class="line">    /*use QT&#x27;s icon*/</span><br><span class="line">    QIcon icon = style-&gt;standardIcon(QStyle::SP_TitleBarMenuButton);</span><br><span class="line"></span><br><span class="line">    /*create QToolButton Class*/</span><br><span class="line">    toolButton = new QToolButton();</span><br><span class="line">    /*toolButton set icon and text*/</span><br><span class="line">    toolButton-&gt;setIcon(icon);</span><br><span class="line">    toolButton-&gt;setText(&quot;help&quot;);</span><br><span class="line"></span><br><span class="line">    /*use setToolButtonStyle Function set ToolButton Style,</span><br><span class="line">        set icon is under this button*/</span><br><span class="line">    toolButton-&gt;setToolButtonStyle(Qt::ToolButtonTextUnderIcon);</span><br><span class="line">    /*will button add the toolbar*/</span><br><span class="line">    toolBar-&gt;addWidget(toolButton);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QRadioButton"><a href="#QRadioButton" class="headerlink" title="QRadioButton"></a>QRadioButton</h3><h4 id="使用QRadioButton"><a href="#使用QRadioButton" class="headerlink" title="使用QRadioButton"></a>使用QRadioButton</h4><ul><li>添加资源文件（添加顺序如下）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">需要添加的项目-&gt;Add New-&gt;QT-&gt;Qt Resource File-&gt;Choose-&gt;(添加资源文件名称)</span><br><span class="line">双击添加的资源文件.qrc-&gt;Add Prefix-&gt;前缀添加&quot;/&quot;-&gt;Add Files</span><br></pre></td></tr></table></figure><ul><li>添加qss文件</li></ul><p>QSS文件使用Qt程序相关联的样式文件，包括GUI的布局，颜色，鼠标的行为，大小和字体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">新建添加一个qss文件。</span><br><span class="line">右键点击资源文件.qrc-&gt;Qt-&gt;Qt Resource File-&gt;Choose-&gt;填写名称-&gt;下一步</span><br></pre></td></tr></table></figure><ul><li>引入<QRadioButton></QRadioButton></li><li>声明 QRadioButton对象，实例化对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton *radioButton1;</span><br><span class="line">QRadioButton *radioButton2;</span><br><span class="line">    </span><br><span class="line">radioButton1 = new QRadioButton(this);</span><br><span class="line">radioButton2 = new QRadioButton(this);</span><br></pre></td></tr></table></figure><ul><li>初始化QRadioButton 状态</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">radioButton1-&gt;setChecked(false);</span><br><span class="line">radioButton2-&gt;setChecked(true);</span><br></pre></td></tr></table></figure><ul><li><p>编写.qss资源文件</p></li><li><p>引用<QFile>打开资源文件</QFile></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">QFile file(&quot;:/style.qss&quot;);</span><br><span class="line">    /*if file is exist*/</span><br><span class="line">    if(file.exists())&#123;</span><br><span class="line">        file.open(QFile::ReadOnly);</span><br><span class="line">        QString styleSheet = QLatin1String(file.readAll());</span><br><span class="line"></span><br><span class="line">        /*set global style*/</span><br><span class="line">        qApp-&gt;setStyleSheet(styleSheet);</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="代码示例如下："><a href="#代码示例如下：" class="headerlink" title="代码示例如下："></a>代码示例如下：</h5><p>.qss</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">QRadioButton&#123;</span><br><span class="line">    spacing:2px;</span><br><span class="line">    color:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QRadioButton::indicator&#123;</span><br><span class="line">    width:45px;</span><br><span class="line">    height:30px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QRadioButton::indicator:unchecked&#123;</span><br><span class="line">    image: url(:/image/idesign-logo.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QRadioButton::indicator:checked&#123;</span><br><span class="line">    image: url(:/image/SzsFox-logo.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">/*import &lt;QFile&gt;*/</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    QFile file(&quot;:/style.qss&quot;);</span><br><span class="line">    /*if file is exist*/</span><br><span class="line">    if(file.exists())&#123;</span><br><span class="line">        file.open(QFile::ReadOnly);</span><br><span class="line">        QString styleSheet = QLatin1String(file.readAll());</span><br><span class="line"></span><br><span class="line">        /*set global style*/</span><br><span class="line">        qApp-&gt;setStyleSheet(styleSheet);</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>mainwindow.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    /*set mainwindows&#x27;s background-color*/</span><br><span class="line">    this-&gt;setStyleSheet(&quot;QMainWindow &#123;background-color:rgba(200,50,100,100%);&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    radioButton1 = new QRadioButton(this);</span><br><span class="line">    radioButton2 = new QRadioButton(this);</span><br><span class="line"></span><br><span class="line">    /*set radiobutton&#x27;s position and size*/</span><br><span class="line">    radioButton1-&gt;setGeometry(300,200,100,50);</span><br><span class="line">    radioButton2-&gt;setGeometry(400,200,100,50);</span><br><span class="line"></span><br><span class="line">    radioButton1-&gt;setText(&quot;Button1&quot;);</span><br><span class="line">    radioButton2-&gt;setText(&quot;Button2&quot;);</span><br><span class="line"></span><br><span class="line">    /*set radioButton&#x27;s init status*/</span><br><span class="line">    radioButton1-&gt;setChecked(false);</span><br><span class="line">    radioButton2-&gt;setChecked(true);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="QCheckBox"><a href="#QCheckBox" class="headerlink" title="QCheckBox"></a>QCheckBox</h3><p>QCheckBox是三态选择框，可以有三种状态。</p><h4 id="QCheckBox-使用"><a href="#QCheckBox-使用" class="headerlink" title="QCheckBox 使用"></a>QCheckBox 使用</h4><ul><li>添加资源文件</li></ul><p><img src="/2023/09/12/Qt%E6%8C%89%E9%92%AE%E6%8E%A7%E4%BB%B6/image-20230911160821782-1694510917974.png" alt="image-20230911160821782"></p><ul><li>实例化QCheckBox,初始化QCheckBox状态。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*set checkBox status*/</span><br><span class="line">checkBox-&gt;setText(&quot;初始化状态为Checked&quot;);</span><br><span class="line">checkBox-&gt;setCheckState(Qt::Checked);</span><br><span class="line">/*open three status mode*/</span><br><span class="line">checkBox-&gt;setTristate();</span><br><span class="line">/*connect slot*/</span><br><span class="line">connect(checkBox,SIGNAL(stateChanged(int)),this,SLOT(checkBoxStatusChanged(int)));</span><br></pre></td></tr></table></figure><ul><li>实现Slot槽函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void MainWindow::checkBoxStatusChanged(int status)</span><br></pre></td></tr></table></figure><ul><li>编写.qss文件</li></ul><h5 id="代码示例如下"><a href="#代码示例如下" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><p>mainwindow.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    this-&gt;setStyleSheet(&quot;QMainWindow &#123;background-color:rgba(100,100,100,100%);&#125;&quot;);</span><br><span class="line"></span><br><span class="line">    checkBox = new QCheckBox(this);</span><br><span class="line">    checkBox-&gt;setGeometry(350,200,250,50);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /*set checkBox status*/</span><br><span class="line">    checkBox-&gt;setText(&quot;初始化状态为Checked&quot;);</span><br><span class="line">    checkBox-&gt;setCheckState(Qt::Checked);</span><br><span class="line">    /*open three status mode*/</span><br><span class="line">    checkBox-&gt;setTristate();</span><br><span class="line">    /*connect slot*/</span><br><span class="line">    connect(checkBox,SIGNAL(stateChanged(int)),this,SLOT(checkBoxStatusChanged(int)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::checkBoxStatusChanged(int status)&#123;</span><br><span class="line">    switch(status)&#123;</span><br><span class="line">    case Qt::Checked:</span><br><span class="line">        checkBox-&gt;setText(&quot;Checked status&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case Qt::Unchecked:</span><br><span class="line">        checkBox-&gt;setText(&quot;Unchecked status&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case Qt::PartiallyChecked:</span><br><span class="line">        checkBox-&gt;setText(&quot;PartiallyChecked status&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QFile&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QApplication a(argc, argv);</span><br><span class="line">    QFile file(&quot;:/style.qss&quot;);</span><br><span class="line">    if(file.exists())&#123;</span><br><span class="line">        file.open(QFile::ReadOnly);</span><br><span class="line">        QString styleSheet = QLatin1String(file.readAll());</span><br><span class="line">        /*set global style*/</span><br><span class="line">        qApp-&gt;setStyleSheet(styleSheet);</span><br><span class="line">        file.close();</span><br><span class="line">    &#125;</span><br><span class="line">    MainWindow w;</span><br><span class="line">    w.show();</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.qss</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">QCheckBox&#123;</span><br><span class="line">    spacing:5px;</span><br><span class="line">    color:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator&#123;</span><br><span class="line">    width:50px;</span><br><span class="line">    height:50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:enabled:unchecked&#123;</span><br><span class="line">    image: url(:/image/chuangzaoshi-logo.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:enabled:checked&#123;</span><br><span class="line">    image: url(:/image/idesign-logo.png);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QCheckBox::indicator:enabled:indeterminate&#123;</span><br><span class="line">    image: url(:/image/SzsFox-logo.png);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QCommandLinkButton"><a href="#QCommandLinkButton" class="headerlink" title="QCommandLinkButton"></a>QCommandLinkButton</h3><p>QCommandLinkButton命令链接按钮 和QRadioButton相似，用于在互斥选项中选择一项，携带一个箭头图标。</p><h4 id="QCommandLinkButton使用"><a href="#QCommandLinkButton使用" class="headerlink" title="QCommandLinkButton使用"></a>QCommandLinkButton使用</h4><ul><li>引用<QCommandLinkButton> ,<QDesktopServices>,<QUrl></QUrl></QDesktopServices></QCommandLinkButton></li><li>声明和实例化QCommandLinkButton</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">   QCommandLinkButton *CommandLinkButton;</span><br><span class="line">CommandLinkButton = new QCommandLinkButton(</span><br><span class="line">   &quot;点击打开目录&quot;,this);</span><br></pre></td></tr></table></figure><ul><li>实现信号和槽之间的连接</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connect(CommandLinkButton,SIGNAL(clicked()),this,SLOT(CommandLinkButtonClicked()));</span><br></pre></td></tr></table></figure><ul><li>实现CommandLinkButtonClicked槽函数</li></ul><h5 id="代码实现如下"><a href="#代码实现如下" class="headerlink" title="代码实现如下"></a>代码实现如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">/*import desk server,open system folder*/</span><br><span class="line">#include &lt;QDesktopServices&gt;</span><br><span class="line">/*import QUrl*/</span><br><span class="line">#include &lt;QUrl&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    CommandLinkButton = new QCommandLinkButton(</span><br><span class="line">    &quot;点击打开目录&quot;,this);</span><br><span class="line"></span><br><span class="line">    CommandLinkButton-&gt;setGeometry(300,200,250,60);</span><br><span class="line">    connect(CommandLinkButton,SIGNAL(clicked()),this,SLOT(CommandLinkButtonClicked()));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::CommandLinkButtonClicked()&#123;</span><br><span class="line">    /*call system server open catalogue*/</span><br><span class="line">    QDesktopServices::openUrl(QUrl(&quot;D:/emulate&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="QDialogButtonBox"><a href="#QDialogButtonBox" class="headerlink" title="QDialogButtonBox"></a>QDialogButtonBox</h3><h4 id="QDialogButtonBox的使用"><a href="#QDialogButtonBox的使用" class="headerlink" title="QDialogButtonBox的使用"></a>QDialogButtonBox的使用</h4><p>​QDialogButtonBox 允许开发人员向其添加按钮，并将自动使用适合用户桌面环境的布局  。我们可以实现自定义按钮。</p><ul><li>引入<QDialogButtonBox></QDialogButtonBox></li><li>声明QDialogButtonBox 对象和QpushButton对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">    QDialogButtonBox *dialogButtonBox;</span><br><span class="line">    QPushButton *PushButton;</span><br><span class="line">private slots:</span><br><span class="line">    void DialogButtonBoxClicked(QAbstractButton *);</span><br></pre></td></tr></table></figure><ul><li>实例化QDialogButtonBox对象</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dialogButtonBox = new QDialogButtonBox(this);</span><br><span class="line">    dialogButtonBox-&gt;setGeometry(300,200,200,30);</span><br><span class="line"></span><br><span class="line">    dialogButtonBox-&gt;addButton(QDialogButtonBox::Cancel);</span><br><span class="line">    dialogButtonBox-&gt;button(QDialogButtonBox::Cancel)-&gt;setText(&quot;取消&quot;);</span><br></pre></td></tr></table></figure><ul><li>实例化QPushButton</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushButton = new QPushButton(tr(&quot;自定义&quot;));</span><br></pre></td></tr></table></figure><ul><li>将QPushButton添加到QDialogButtonBox里面，并且实现信号和槽的连接。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*will pushbutton add to dialogbuttonBox,and set buttonRole is ActionRole*/</span><br><span class="line">    dialogButtonBox-&gt;addButton(PushButton,QDialogButtonBox::ActionRole);</span><br><span class="line">    connect(dialogButtonBox,SIGNAL(clicked(QAbstractButton *)),this,SLOT(DialogButtonBoxClicked(QAbstractButton *)));</span><br></pre></td></tr></table></figure><ul><li>槽函数的实现</li></ul><h5 id="代码示例如下-1"><a href="#代码示例如下-1" class="headerlink" title="代码示例如下"></a>代码示例如下</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    dialogButtonBox = new QDialogButtonBox(this);</span><br><span class="line">    dialogButtonBox-&gt;setGeometry(300,200,200,30);</span><br><span class="line"></span><br><span class="line">    dialogButtonBox-&gt;addButton(QDialogButtonBox::Cancel);</span><br><span class="line">    dialogButtonBox-&gt;button(QDialogButtonBox::Cancel)-&gt;setText(&quot;取消&quot;);</span><br><span class="line"></span><br><span class="line">    PushButton = new QPushButton(tr(&quot;自定义&quot;));</span><br><span class="line">    /*will pushbutton add to dialogbuttonBox,and set buttonRole is ActionRole*/</span><br><span class="line">    dialogButtonBox-&gt;addButton(PushButton,QDialogButtonBox::ActionRole);</span><br><span class="line">    connect(dialogButtonBox,SIGNAL(clicked(QAbstractButton *)),this,SLOT(DialogButtonBoxClicked(QAbstractButton *)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void MainWindow::DialogButtonBoxClicked(QAbstractButton *button)&#123;</span><br><span class="line">    if(button == dialogButtonBox-&gt;button((QDialogButtonBox::Cancel)))&#123;</span><br><span class="line">        qDebug() &lt;&lt;&quot;clicked Cancel&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else if(button == PushButton)&#123;</span><br><span class="line">        qDebug() &lt;&lt;&quot;clicked self button&quot;&lt;&lt;endl;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt按钮控件的使用&quot;&gt;&lt;a href=&quot;#Qt按钮控件的使用&quot; class=&quot;headerlink&quot; title=&quot;Qt按钮控件的使用&quot;&gt;&lt;/a&gt;Qt按钮控件的使用&lt;/h2&gt;&lt;h2 id=&quot;按钮控件（button）&quot;&gt;&lt;a href=&quot;#按钮控件（button）&quot;</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>__atrribute__的一些用法</title>
    <link href="http://example.com/2023/01/27/atrribute-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/"/>
    <id>http://example.com/2023/01/27/atrribute-%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95/</id>
    <published>2023-01-27T12:00:31.000Z</published>
    <updated>2023-09-13T01:49:59.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="attribute-用法"><a href="#attribute-用法" class="headerlink" title="__attribute__用法"></a>__attribute__用法</h1><h3 id="attribute属性声明：format"><a href="#attribute属性声明：format" class="headerlink" title="attribute属性声明：format"></a>attribute属性声明：format</h3><p>GNU 通过 <strong>atttribute</strong> 扩展的 format 属性，用来<em><strong>指定变参函数的参数格式检查</strong></em>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__attribute__(( format (archetype, string-index, first-to-check)))</span><br></pre></td></tr></table></figure><ul><li>archetype：指定格式类型</li><li>string-index：格式字符串的位置在所有参数列表中的索引</li><li>first-to-check：编译器帮忙检查的参数，在所有的参数列表里索引的位置</li></ul><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LOG(const char *fmt, ...)  __attribute__((format(printf,1,2)));</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数 printf 是告诉编译器，按照 printf 函数的检查标准来检查；</p></li><li><p>第2个参数表示在 LOG 函数所有的参数列表中，格式字符串的位置索引；</p></li><li><p>第3个参数是告诉编译器要检查的参数的起始位置。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void LOG(int num, char *fmt, ...)  __attribute__((format(printf,2,3)));</span><br></pre></td></tr></table></figure><p>在这个函数定义中，多了一个参数 num，格式字符串在参数列表中的位置发生了变化（在所有的参数列表中，索引为2），要检查的第一个变参的位置也发生了变化（索引为3），那我们使用 format 属性声明时，就要写成 format(printf,2,3) 的形式了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void __attribute__ ((format(printf,1,2))) ESP_LOGI(char *fmt,...) </span><br><span class="line">&#123;</span><br><span class="line">va_list arg;</span><br><span class="line">    va_start(arg, fmt);</span><br><span class="line">    vprintf(fmt, arg);</span><br><span class="line">    va_end(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;attribute-用法&quot;&gt;&lt;a href=&quot;#attribute-用法&quot; class=&quot;headerlink&quot; title=&quot;__attribute__用法&quot;&gt;&lt;/a&gt;__attribute__用法&lt;/h1&gt;&lt;h3 id=&quot;attribute属性声明：forma</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>mqtt协议解析</title>
    <link href="http://example.com/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/"/>
    <id>http://example.com/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2023-01-18T06:53:02.000Z</published>
    <updated>2023-09-13T01:49:59.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MQTT数据帧解析"><a href="#MQTT数据帧解析" class="headerlink" title="MQTT数据帧解析"></a>MQTT数据帧解析</h1><p>[TOC]</p><h2 id="MQTT-控制报文格式"><a href="#MQTT-控制报文格式" class="headerlink" title="MQTT 控制报文格式"></a>MQTT 控制报文格式</h2><h4 id="MQTT控制报文结构组成"><a href="#MQTT控制报文结构组成" class="headerlink" title="MQTT控制报文结构组成"></a>MQTT控制报文结构组成</h4><ul><li>固定报头（所有控制报文都包含）</li><li>可变报头</li><li>消息体</li></ul><h4 id="固定报头的组成格式"><a href="#固定报头的组成格式" class="headerlink" title="固定报头的组成格式"></a>固定报头的组成格式</h4><p><img src="/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/image-20230118145809356.png" alt="image-20230118145809356"></p><ul><li><p><strong>控制报文的类型</strong></p><ul><li>控制报文的类型由第一个字节的4-7位组成</li></ul><p><img src="/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/image-20230118150005166.png" alt="image-20230118150005166"></p><p><img src="/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/image-20230118150027077.png" alt="image-20230118150027077"></p></li><li><p><strong>控制报文类型标志位</strong></p><p><img src="/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/image-20230118150625999.png" alt="image-20230118150625999"></p></li><li><p><strong>剩余长度</strong>：从第二个字节开始，剩余长度（Remaining Length） 表示当前报文剩余部分的字节数， 包括可变报头和负载的数据。 剩余长度不包括用于编码剩余长度字段本身的字节数。  </p><p><img src="/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/image-20230118212354474.png" alt="image-20230118212354474"></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分别表示（每个字节的低 7 位用于编码数据， 最高位是标志位） ：</span><br><span class="line">1 个字节时， 从 0(0x00)到 127(0x7f)</span><br><span class="line">2 个字节时， 从 128(0x80,0x01)到 16383(0Xff,0x7f)</span><br><span class="line">3 个字节时， 从 16384(0x80,0x80,0x01)到 2097151(0xFF,0xFF,0x7F)</span><br><span class="line">4 个字节时， 从 2097152(0x80,0x80,0x80,0x01)到 268435455(0xFF,0xFF,0xFF,0x7F)</span><br></pre></td></tr></table></figure><h4 id="可变报头"><a href="#可变报头" class="headerlink" title="可变报头"></a>可变报头</h4><p><strong>可变报头在固定报头和负载之间，可变报头的内容根据报文类型的不同而不同</strong></p><ul><li><p><strong>报文标识符</strong></p><ul><li><strong>报文标识符类型</strong></li></ul><p><img src="/2023/01/18/mqtt%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/image-20230118151514215.png" alt="image-20230118151514215"></p><ul><li><p>很多控制报文的可变报头部分包含一个两字节的报文标识符字段。 这些报文是 PUBLISH（QoS&gt;0 时），<br>  PUBACK， PUBREC， PUBREL， PUBCOMP， SUBSCRIBE, SUBACK， UNSUBSCIBE，UNSUBACK。 </p></li><li><p>&#96;&#96;&#96;<br>1、SUBSCRIBE， UNSUBSCRIBE 和 PUBLISH（QoS 大于 0） 控制报文必须包含一个非零的 16 位报文标识<br>符（Packet Identifier）。<br>2、客户端每次发送一个新的这些类型的报文时都必须分配一个当前未使用的报文标识符。<br>3、如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时， 它必须使用相同的标识符。 当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。<br>4、QoS 1 的 PUBLISH 对应的是 PUBACK， QoS 2 的 PUBLISH 对应的是 PUBCOMP，与 SUBSCRIBE 或<br>UNSUBSCRIBE 对应的分别是 SUBACK 或 UNSUBACK [MQTT-2.3.1-3]。<br>5、QoS 设置为 0 的 PUBLISH 报文不能包含报文标识符<br>6、PUBACK, PUBREC, PUBREL 报文必须包含与最初发送的 PUBLISH 报文相同的报文标识符<br>7、SUBACK 和 UNSUBACK 必须包含在对应的 SUBSCRIBE 和 UNSUBSCRIBE 报文中使用的报文标识符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - **包含标识符的控制报文**</span><br><span class="line"></span><br><span class="line">  ​![image-20230118152304772](mqtt协议解析/image-20230118152304772.png)</span><br><span class="line"></span><br><span class="line">客户端和服务端彼此独立地分配报文标识符。 因此，客户端服务端组合使用相同的报文标识符可以实现并</span><br><span class="line">发的消息交换。  </span><br><span class="line"></span><br><span class="line">## MQTT控制报文</span><br><span class="line"></span><br><span class="line">### 1、CONNECT-连接服务端</span><br><span class="line"></span><br><span class="line">#### 客户端和服务端的网络建立后，第一个报文必须是connect报文，且一个网络连接上只能发送一个网络连接</span><br><span class="line"></span><br><span class="line">##### connect连接的固定报头（0x10）</span><br><span class="line"></span><br><span class="line">![image-20230118153045359](mqtt协议解析/image-20230118153045359.png)</span><br><span class="line"></span><br><span class="line">***剩余字段长度长度等于有效负荷长度加上可变报头的长度***</span><br><span class="line"></span><br><span class="line">#### 可变报头长度</span><br><span class="line"></span><br><span class="line">***CONNECT 报文的可变报头按下列次序包含四个字段：***</span><br><span class="line"></span><br><span class="line">- 协议名（Protocol Name） **（协议名是表示协议名 MQTT 的 UTF-8 编码的字符串） **</span><br><span class="line"></span><br><span class="line">  - 协议名构成</span><br><span class="line"></span><br><span class="line">  ![image-20230118153430526](mqtt协议解析/image-20230118153430526.png)</span><br><span class="line"></span><br><span class="line">  ![image-20230118153505227](mqtt协议解析/image-20230118153505227.png)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">- 协议级别（ProtocolLevel） </span><br><span class="line"></span><br><span class="line">  - Protocol Level byte 协议级别字节构成  </span><br><span class="line"></span><br><span class="line">  ![image-20230118153636758](mqtt协议解析/image-20230118153636758.png)</span><br><span class="line"></span><br><span class="line">-  连接标志（Connect Flags）</span><br><span class="line"></span><br><span class="line">  - 连接标志位**（连接标志字节包含一些用于指定 MQTT 连接行为的参数。 它还指出有效载荷中的字段是否存在。）  **</span><br><span class="line">  - 服务端必须验证 CONNECT 控制报文的保留标志位（第 0 位） 是否为 0， 如果不为 0 必须断开客户端连接 。</span><br><span class="line"></span><br><span class="line">  ![image-20230118153804825](mqtt协议解析/image-20230118153804825.png)</span><br><span class="line"></span><br><span class="line">  - 清理会话（CleanSession）</span><br><span class="line"></span><br><span class="line">    - CleanSession置0：**表示创建一个持久会话，在客户端断开连接时，会话仍然保持并保存离线消息，直到会话超时注销。**</span><br><span class="line">    - CleanSession置1：**表示创建一个新的临时会话，在客户端断开时，会话自动销毁。**</span><br><span class="line"></span><br><span class="line">  - 遗嘱标志（Will Flsg）</span><br><span class="line"></span><br><span class="line">    - WillFlag位置1：表示如果连接请求被接受了， 遗嘱（Will Message） 消息必须被存储在服务端并且与这个网络连接关联。  之后网络连接关闭时，服务端必须发布这个遗嘱消息， 除非服务端收到DISCONNECT 报文时删除了这个遗嘱消息  。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>  可以理解为简而言之，就是客户端预先定义好，在自己异常断开的情况下，所留下的最后遗愿（Last Will），也称之为遗嘱（Testament）。这个遗嘱就是一个由客户端预先定义好的主题和对应消息，附加在CONNECT的可变报文头部中，在客户端连接出现异常的情况下，由服务器主动发布此消息。</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    - WillFlag位置0：网络连接断开时， 不能发送遗嘱消息  </span><br><span class="line"></span><br><span class="line">  - 遗嘱QoS标志（WillQos）**两位标志位用于指定发布遗嘱消息时使用的服务质量等级。  **</span><br><span class="line"></span><br><span class="line">    - WillQoS可以设置：</span><br><span class="line">      - 0x00：遗嘱 QoS  服务质量等级  0</span><br><span class="line">      - 0x01：遗嘱 QoS  服务质量等级  1</span><br><span class="line">      - 0x02：遗嘱 QoS  服务质量等级  2</span><br><span class="line"></span><br><span class="line">  - 遗嘱保留标志（WillRetain）：</span><br><span class="line"></span><br><span class="line">    - WillRetain置0：遗嘱消息被发布时需要保留  </span><br><span class="line">    - WillRetain置1：遗嘱消息被发布时不需要保留  </span><br><span class="line"></span><br><span class="line">  - 用户标志（UserNameFlag）</span><br><span class="line"></span><br><span class="line">    - UserNameFlag置0：有效载荷中不能包含用户名字段  </span><br><span class="line">    - UserNameFlag置1：有效载荷中必须包含用户名字段  </span><br><span class="line"></span><br><span class="line">  - 密码标志（PasswordFlag）**（如果用户名标志被设置为 0， 密码标志也必须设置为 0  ）**</span><br><span class="line"></span><br><span class="line">    - PasswordFlag置0：有效载荷中不能包含密码字段  </span><br><span class="line">    - PasswordFlag置1：有效载荷中必须包含密码字段  </span><br><span class="line"></span><br><span class="line">- 保持连接（Keep Alive） </span><br><span class="line"></span><br><span class="line">  **保持字节连接**</span><br><span class="line"></span><br><span class="line">  ![image-20230118161545118](mqtt协议解析/image-20230118161545118.png)</span><br><span class="line"></span><br><span class="line">  保持连接（Keep Alive） 是一个以秒为单位的时间间隔，表示为一个 16 位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻， 两者之间允许空闲的最大时间间隔。  </span><br><span class="line"></span><br><span class="line">  - 保持连接的值为零表示关闭保持连接功能  </span><br><span class="line"></span><br><span class="line">  - 如果没有任何其它的控制报文可以发送， 客户端必须发送一个**PINGREQ** 报文  </span><br><span class="line">  - 不管保持连接的值是多少，客户端任何时候都可以发送 PINGREQ 报文，并且使用 PINGRESP 报文判断网络和服务端的活动状态。  </span><br><span class="line"></span><br><span class="line">  - 客户端发送了 PINGREQ 报文之后， 如果在**合理的时间内仍没有收到 PINGRESP 报文**， 它应该关闭到服务端的网络连接。  </span><br><span class="line"></span><br><span class="line">#### 有效负载</span><br><span class="line"></span><br><span class="line">***CONNECT 报文的有效载荷（payload） 包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。 如果包含的话， 必须按这个顺序出现：客户端标识符， 遗嘱主题， 遗嘱消息， 用户名， 密码***</span><br><span class="line"></span><br><span class="line">- 客户端标识符（**服务端使用客户端表示符识别客户端**）</span><br><span class="line"></span><br><span class="line">  - 连接服务端的每个客户端都有**唯一的客户端标识符**（ClientId） 。客户端和服务端都必须使用 ClientId 识别两者之间的 MQTT 会话相关的状态。</span><br><span class="line"></span><br><span class="line">  - 客户端标识符 (ClientId) 必须存在而且必须是 CONNECT 报文有效载荷的第一个字段   （**标识符ID必须是UTF8编码，只能包含大小写字母和数字**）</span><br><span class="line"></span><br><span class="line">  - 服务端可以允许客户端提供一个零字节的客户端标识符 (ClientId)  ，务端必须将这看作特殊情况并分配唯一的客户端标识符给那个客户端。如果客户端提供了一个零字节的客户端标识符， 它必须同时将清理会话标志设置为 1    </span><br><span class="line"></span><br><span class="line">- 遗嘱主题</span><br><span class="line"></span><br><span class="line">  如果遗嘱标志被设置为 1， 有效载荷的下一个字段是遗嘱主题（Will Topic）  </span><br><span class="line"></span><br><span class="line">- 遗嘱消息</span><br><span class="line"></span><br><span class="line">  如果遗嘱标志被设置为 1， 有效载荷的下一个字段是遗嘱消息。  </span><br><span class="line"></span><br><span class="line">- 用户名</span><br><span class="line"></span><br><span class="line">  如果用户名（User Name） 标志被设置为 1， 有效载荷的下一个字段就是它。   </span><br><span class="line"></span><br><span class="line">- 密码</span><br><span class="line"></span><br><span class="line">  如果密码（Password） 标志被设置为 1， 有效载荷的下一个字段就是它。  密码字段包含一个两字节的长度字段， 长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节） ， 后面跟着 0 到 65535 字节的二进制数据。  </span><br><span class="line"></span><br><span class="line">#### 响应</span><br><span class="line"></span><br><span class="line">- 服务端响应</span><br><span class="line">  - 网络连接建立后， 如果服务端在合理的时间内没有收到 CONNECT 报文， 服务端应该关闭这个连接。  </span><br><span class="line">  - 服务端必须按照 3.1 节的要求验证 CONNECT 报文， 如果报文不符合规范， 服务端不发送CONNACK 报文直接关闭网络连接  。</span><br><span class="line">  - 如果任何一项检查没通过，按照 3.2 节的描述，它应该发送一个适当的、 返回码非零的CONNACK 响应， 并且必须关闭这个网络连接。  </span><br><span class="line"></span><br><span class="line">### 2、CONNACK-确认连接请求</span><br><span class="line"></span><br><span class="line">#### CONNACK固定报头</span><br><span class="line"></span><br><span class="line">![image-20230118165402419](mqtt协议解析/image-20230118165402419.png)</span><br><span class="line"></span><br><span class="line">***剩余长度字段  ：***</span><br><span class="line"></span><br><span class="line">- 表示可变报头的长度。 对于 CONNACK 报文这个值等于 2。  </span><br><span class="line"></span><br><span class="line">#### 可变报头</span><br><span class="line"></span><br><span class="line">![image-20230118165749540](mqtt协议解析/image-20230118165749540.png)</span><br><span class="line"></span><br><span class="line">- **确认连接标志**</span><br><span class="line">  - 第 1 个字节是 连接确认标志， 位 7-1 是保留位且必须设置为 0。  第 0 (SP)位 是当前会话（Session Present） 标志。  </span><br><span class="line"></span><br><span class="line">- **当前会话**（**连接确认标志的第 0 位。**）</span><br><span class="line"></span><br><span class="line">  -   如果服务端收到清理会话（CleanSession） 标志为 1 的连接，除了将 CONNACK 报文中的返回码设置为 0之外，还必须将 CONNACK 报文中的当前会话设置（Session Present） 标志为 0  </span><br><span class="line"></span><br><span class="line">  - 如果服务端收到一个 CleanSession 为 0 的连接， 当前会话标志的值取决于服务端是否已经保存了 ClientId对应客户端的会话状态。  </span><br><span class="line"></span><br><span class="line">    - 如果服务端已经保存了会话状态， 它必须将 CONNACK 报文中的当前会话标志设置为 1</span><br><span class="line">    - 如果服务端没有已保存的会话状态， 它必须将 CONNACK 报文中的当前会话设置为 0，还需要将 CONNACK 报文中的返回码设置为 0  。</span><br><span class="line"></span><br><span class="line">    - 如果服务端发送了一个包含非零返回码的 CONNACK 报文， 它必须将当前会话标志设置为 0  </span><br><span class="line"></span><br><span class="line">- **连接返回码（可变报头的第二个字节）**</span><br><span class="line"></span><br><span class="line">  ![image-20230118170752934](mqtt协议解析/image-20230118170752934.png)</span><br><span class="line"></span><br><span class="line">  ![image-20230118170806394](mqtt协议解析/image-20230118170806394.png)</span><br><span class="line"></span><br><span class="line">#### 有效负载</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">### 3、PUBLISH-发布消息</span><br><span class="line"></span><br><span class="line">#### publish的固定报头：</span><br><span class="line"></span><br><span class="line">![image-20230118171158474](mqtt协议解析/image-20230118171158474.png)</span><br><span class="line"></span><br><span class="line">- **重发标志位** **（第一个字节第3位）**</span><br><span class="line">  - DUP 标志被设置为 0， 表示这是客户端或服务端第一次请求发送这个 PUBLISH 报文  </span><br><span class="line">  - DUP 标志被设置为 1，表示这可能是一个早前报文请求的重发。  </span><br><span class="line">  - **客户端或服务端请求重发一个 PUBLISH 报文时， 必须将 DUP 标志设置为 1 ， 对于 QoS0 的消息， DUP 标志必须设置为 0  **</span><br><span class="line"></span><br><span class="line">- **服务质量等级** **（第一个字节第1，2位）**</span><br><span class="line"></span><br><span class="line">  - QoS值 = 00：最多分发一次</span><br><span class="line">  - QoS值 = 01：至少分发一次</span><br><span class="line">  - QoS值 = 10：只分发一次</span><br><span class="line">  - QoS值 = 11：保留位</span><br><span class="line"></span><br><span class="line">- **保留标志位** **（第一个字节第0位）**</span><br><span class="line"></span><br><span class="line">  - 如果客户端发给服务端的 PUBLISH 报文的保留（RETAIN） 标志被设置为 1， 服务端必须存储这个应用消息和它的服务质量等级（QoS） ，以便它可以被分发给未来的主题名匹配的订阅者  </span><br><span class="line"></span><br><span class="line">  - 服务端发送 PUBLISH 报文给客户端时，如果消息是作为客户端一个新订阅的结果发送， 它必须将报文的保留标志设为 1  </span><br><span class="line">  - 当一个 PUBLISH 报文发送给客户端是因为匹配一个已建立的订阅时，服务端必须将保留标志设为 0  </span><br><span class="line">  - 保留标志为 1 且有效载荷为零字节的 PUBLISH 报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息  </span><br><span class="line">  - 如果客户端发给服务端的 PUBLISH 报文的保留标志位 0， 服务端不能存储这个消息也不能移除或替换任何现存的保留消息  </span><br><span class="line"></span><br><span class="line">- 剩余长度</span><br><span class="line"></span><br><span class="line">#### publish可变报头</span><br><span class="line"></span><br><span class="line">##### 主题名</span><br><span class="line"></span><br><span class="line">- 主题名必须是 PUBLISH 报文可变报头的第一个字段。   </span><br><span class="line">- PUBLISH 报文中的主题名不能包含通配符   </span><br><span class="line"></span><br><span class="line">##### 报文标识符</span><br><span class="line"></span><br><span class="line">​只有当 QoS 等级是 1 或 2 时，报文标识符（Packet Identifier） 字段才能出现在 PUBLISH 报文中。   </span><br><span class="line"></span><br><span class="line">##### 有效负荷</span><br><span class="line"></span><br><span class="line">​有效载荷包含将被发布的应用消息。  有效载荷的长度这样计算： 用固定报头中的剩余长度字段的值减去可变报头的长度。  </span><br><span class="line"></span><br><span class="line">##### 响应</span><br><span class="line"></span><br><span class="line">- 服务质量等级Qos0：无响应</span><br><span class="line">- 服务质量等级Qos1：PUBACK 报文</span><br><span class="line">- 服务质量等级Qos2：PUBREC 报文</span><br><span class="line"></span><br><span class="line">##### 动作</span><br><span class="line"></span><br><span class="line">​客户端使用 PUBLISH 报文发送应用消息给服务端， 目的是分发到其它订阅匹配的客户端。  </span><br><span class="line"></span><br><span class="line">​服务端使用 PUBLISH 报文发送应用消息给每一个订阅匹配的客户端。  </span><br><span class="line"></span><br><span class="line">### 4、PUBACK –发布确认  </span><br><span class="line"></span><br><span class="line">PUBACK 报文是对 QoS 1 等级的 PUBLISH 报文的响应。 </span><br><span class="line"></span><br><span class="line">#### PUBACK 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118173146808](mqtt协议解析/image-20230118173146808.png) </span><br><span class="line"></span><br><span class="line">![image-20230118173205345](mqtt协议解析/image-20230118173205345.png)</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">表示可变报头的长度。对 PUBACK 报文这个值等于 2.  </span><br><span class="line"></span><br><span class="line">#### 可变报头  </span><br><span class="line"></span><br><span class="line">包含等待确认的 PUBLISH 报文的报文标识符  </span><br><span class="line"></span><br><span class="line">![image-20230118173304813](mqtt协议解析/image-20230118173304813.png)</span><br><span class="line"></span><br><span class="line">#### 有效负载</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">### 5、PUBREC – 发布收到（QoS 2， 第一步）  </span><br><span class="line"></span><br><span class="line">#### PUBREC 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118173620945](mqtt协议解析/image-20230118173620945.png)</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">表示可变报头的长度。 对 PUBREC 报文它的值等于 2。  </span><br><span class="line"></span><br><span class="line">#### PUBREC 可变报头  </span><br><span class="line"></span><br><span class="line">可变报头包含等待确认的 PUBLISH 报文的报文标识符。  </span><br><span class="line"></span><br><span class="line">![image-20230118173711725](mqtt协议解析/image-20230118173711725.png)</span><br><span class="line"></span><br><span class="line">#### 有效负载</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">### 6、PUBREL – 发布释放（QoS 2， 第二步）  </span><br><span class="line"></span><br><span class="line">PUBREL 报文是对 PUBREC 报文的响应。 它是 QoS 2 等级协议交换的第三个报文。  </span><br><span class="line"></span><br><span class="line">#### 固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118173845828](mqtt协议解析/image-20230118173845828.png)</span><br><span class="line"></span><br><span class="line">**PUBREL 控制报文固定报头的第 3,2,1,0 位是保留位， 必须被设置为 0,0,1,0。 **</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">表示可变报头的长度。 对 PUBREL 报文这个值等于 2.   </span><br><span class="line"></span><br><span class="line">#### PUBREL 报文可变报头  </span><br><span class="line"></span><br><span class="line">可变报头包含与等待确认的 PUBREC 报文相同的报文标识符。  </span><br><span class="line"></span><br><span class="line">![image-20230118173946287](mqtt协议解析/image-20230118173946287.png)</span><br><span class="line"></span><br><span class="line">#### 有效负载</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">### 7 、PUBCOMP – 发布完成（QoS 2， 第三步）</span><br><span class="line"></span><br><span class="line">PUBCOMP 报文是对 PUBREL 报文的响应。 它是 QoS 2 等级协议交换的第四个也是最后一个报文。    </span><br><span class="line"></span><br><span class="line">#### PUBCOMP 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118174114030](mqtt协议解析/image-20230118174114030.png)</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">表示可变报头的长度。 对 PUBCOMP 报文这个值等于 2。  </span><br><span class="line"></span><br><span class="line">#### PUBCOMP 报文可变报头  </span><br><span class="line"></span><br><span class="line">可变报头包含与等待确认的 PUBREL 报文相同的报文标识符。  </span><br><span class="line"></span><br><span class="line">![image-20230118174227721](mqtt协议解析/image-20230118174227721.png)</span><br><span class="line"></span><br><span class="line">#### 有效负载</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">### 8、SUBSCRIBE - 订阅主题  </span><br><span class="line"></span><br><span class="line">客户端向服务端发送 SUBSCRIBE 报文用于创建一个或多个订阅。 每个订阅注册客户端关心的一个或多个主题。 为了将应用消息转发给与那些订阅匹配的主题， 服务端发送 PUBLISH 报文给客户端。 SUBSCRIBE报文也（为每个订阅） 指定了最大的 QoS 等级， 服务端根据这个发送应用消息给客户端。  </span><br><span class="line"></span><br><span class="line">#### SUBSCRIBE 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118174630367](mqtt协议解析/image-20230118174630367.png)</span><br><span class="line"></span><br><span class="line">**SUBSCRIBE 控制报固定报头的第 3,2,1,0 位是保留位， 必须分别设置为 0,0,1,0。**  </span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">等于可变报头的长度（2 字节） 加上有效载荷的长度。  </span><br><span class="line"></span><br><span class="line">#### SUBSCRIBE 可变报头</span><br><span class="line"></span><br><span class="line">可变报头包含客户端标识符。  </span><br><span class="line"></span><br><span class="line">#### SUBSCRIBE 有效载荷</span><br><span class="line"></span><br><span class="line">SUBSCRIBE 报文的有效载荷包含了一个主题过滤器列表， 它们表示客户端想要订阅的主题。  </span><br><span class="line"></span><br><span class="line">**报文有效载荷格式**</span><br><span class="line"></span><br><span class="line">![image-20230118174912107](mqtt协议解析/image-20230118174912107.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 有效载荷字节格式非规范示例  </span><br><span class="line"></span><br><span class="line">![image-20230118175051471](mqtt协议解析/image-20230118175051471.png)</span><br><span class="line"></span><br><span class="line">![image-20230118175107151](mqtt协议解析/image-20230118175107151.png)</span><br><span class="line"></span><br><span class="line">#### 响应</span><br><span class="line"></span><br><span class="line">服务端收到客户端发送的一个 SUBSCRIBE 报文时， 必须使用 SUBACK 报文响应  </span><br><span class="line"></span><br><span class="line">SUBACK 报文必须和等待确认的 SUBSCRIBE 报文有相同的报文标识符  </span><br><span class="line"></span><br><span class="line">### 9、 SUBACK – 订阅确认  </span><br><span class="line"></span><br><span class="line">服务端发送 SUBACK 报文给客户端， 用于确认它已收到并且正在处理 SUBSCRIBE 报文。  </span><br><span class="line"></span><br><span class="line">SUBACK 报文包含一个返回码清单， 它们指定了 SUBSCRIBE 请求的每个订阅被授予的最大 QoS 等级。  </span><br><span class="line"></span><br><span class="line">#### SUBACK 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118175316108](mqtt协议解析/image-20230118175316108.png)</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">等于可变报头的长度加上有效载荷的长度。  </span><br><span class="line"></span><br><span class="line">#### SUBACK 报文可变报头  </span><br><span class="line"></span><br><span class="line">可变报头包含等待确认的 SUBSCRIBE 报文的报文标识符。  </span><br><span class="line"></span><br><span class="line">![image-20230118175404006](mqtt协议解析/image-20230118175404006.png)</span><br><span class="line"></span><br><span class="line">#### 有效载荷</span><br><span class="line"></span><br><span class="line">有效载荷包含一个返回码清单。 每个返回码对应等待确认的 SUBSCRIBE 报文中的一个主题过滤器。</span><br><span class="line"></span><br><span class="line">返回码的顺序必须和 SUBSCRIBE 报文中主题过滤器的顺序相同  </span><br><span class="line"></span><br><span class="line">##### 有效载荷格式</span><br><span class="line"></span><br><span class="line">![image-20230118175637006](mqtt协议解析/image-20230118175637006.png)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>允许的返回码值：<br>0x00 - 最大 QoS 0<br>0x01 - 成功 – 最大 QoS 1<br>0x02 - 成功 – 最大 QoS 2<br>0x80 - Failure 失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 10 、UNSUBSCRIBE –取消订阅  </span><br><span class="line"></span><br><span class="line">客户端发送 UNSUBSCRIBE 报文给服务端， 用于取消订阅主题。  </span><br><span class="line"></span><br><span class="line">#### UNSUBSCRIBE 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118175754029](mqtt协议解析/image-20230118175754029.png)</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">等于可变报头的长度加上有效载荷的长度。  </span><br><span class="line"></span><br><span class="line">#### UNSUBSCRIBE 报文可变报头  </span><br><span class="line"></span><br><span class="line">![image-20230118175834119](mqtt协议解析/image-20230118175834119.png)</span><br><span class="line"></span><br><span class="line">可变报头包含一个报文标识符。  </span><br><span class="line"></span><br><span class="line">#### 有效载荷</span><br><span class="line"></span><br><span class="line">UNSUBSCRIBE 报文的有效载荷包含客户端想要取消订阅的主题过滤器列表。  </span><br><span class="line"></span><br><span class="line">#### 响应</span><br><span class="line"></span><br><span class="line">服务端必须发送 UNSUBACK 报文响应客户端的 UNSUBSCRIBE 请求。</span><br><span class="line"></span><br><span class="line">UNSUBACK 报文必须包含和UNSUBSCRIBE 报文相同的报文标识符。 即使没有删除任何主题订阅， 服务端也必须发送一个 SUBACK 响应。  </span><br><span class="line"></span><br><span class="line">### 11、UNSUBACK – 取消订阅确认  </span><br><span class="line"></span><br><span class="line">服务端发送 UNSUBACK 报文给客户端用于确认收到 UNSUBSCRIBE 报文。  </span><br><span class="line"></span><br><span class="line">#### UNSUBACK 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118202732410](mqtt协议解析/image-20230118202732410.png)</span><br><span class="line"></span><br><span class="line">剩余长度字段</span><br><span class="line">表示可变报头的长度， 对 UNSUBACK 报文这个值等于 2。  </span><br><span class="line"></span><br><span class="line">#### 可变报头  </span><br><span class="line"></span><br><span class="line">可变报头包含等待确认的 UNSUBSCRIBE 报文的报文标识符。  </span><br><span class="line"></span><br><span class="line">![image-20230118202813135](mqtt协议解析/image-20230118202813135.png)</span><br><span class="line"></span><br><span class="line">### 有效负载</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">## 12、PINGREQ – 心跳请求  </span><br><span class="line"></span><br><span class="line">#### 客户端发送 PINGREQ 报文给服务端的。  </span><br><span class="line"></span><br><span class="line">- 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。  </span><br><span class="line">- 请求服务端发送 响应确认它还活着。  </span><br><span class="line">- 使用网络以确认网络连接没有断开。  </span><br><span class="line"></span><br><span class="line">保持连接（Keep Alive） 处理中用到这个报文  。</span><br><span class="line"></span><br><span class="line">#### PINGREQ 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118203020292](mqtt协议解析/image-20230118203020292.png)</span><br><span class="line"></span><br><span class="line">![image-20230118203038983](mqtt协议解析/image-20230118203038983.png)</span><br><span class="line"></span><br><span class="line">#### 可变报头</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">#### 有效载荷</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">#### 响应</span><br><span class="line"></span><br><span class="line">服务端必须发送 PINGRESP 报文响应客户端的 PINGREQ 报文  </span><br><span class="line"></span><br><span class="line">### 13、PINGRESP – 心跳响应  </span><br><span class="line"></span><br><span class="line">服务端发送 PINGRESP 报文响应客户端的 PINGREQ 报文。 表示服务端还活着。  </span><br><span class="line"></span><br><span class="line">#### PINGRESP 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118203421595](mqtt协议解析/image-20230118203421595.png)</span><br><span class="line"></span><br><span class="line">#### 可变报头</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">#### 有效载荷</span><br><span class="line"></span><br><span class="line">无</span><br><span class="line"></span><br><span class="line">### 14、DISCONNECT –断开连接  </span><br><span class="line"></span><br><span class="line">DISCONNECT 报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。  </span><br><span class="line"></span><br><span class="line">#### DISCONNECT 报文固定报头  </span><br><span class="line"></span><br><span class="line">![image-20230118203629687](mqtt协议解析/image-20230118203629687.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 报文例子详解</span><br><span class="line"></span><br><span class="line">#### 1、CONECT 报文（client）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte) 0x01 ??<br>可变报头<br>    协议名(6byte) 0x00 0x04 ‘M’ ‘Q’ ‘T’ ‘T’<br>    协议级别(1byte) ??<br>    连接标志(1byte) ??<br>    保持连接(2byte) ?? ??<br>有效载荷<br>    客户端标识符(xbyte)<br>    遗嘱主题(如果开启遗嘱标志才有)(abyte)<br>    遗嘱消息(如果开启遗嘱标志才有)(bbyte)<br>    用户名(ybyte)<br>    密码(zbyte &#x3D; 2byte + ?)<br>byte &#x3D; 2 + 6 + 1 + 1 + 2 + x + y + z<br>开启遗嘱标志：byte &#x3D; 2 + 6 + 1 + 1 + 2 + x + y + z + a + b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2、CONNACK 报文(server)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0x20 0x20<br>报文标识符(2byte) ?? ??<br>byte &#x3D; 2 + 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3、PUBLISH 报文(client)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)?? ??<br>可变报头<br>    主题名(xbyte)<br>    报文标识符(2byte)(只有qos1或qos2才有报文标识符)<br>有效载荷(ybyte) ?? ?? …<br>byte &#x3D; 2 + x + 2 + y</p><p>如果是qos0：byte &#x3D; 2 + x + y</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 4、PUBACK 报文 (server)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0x40 0x20<br>报文标识符(2byte) ?? ??<br>byte &#x3D; 2 + 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 5、PUBREC 报文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0x50 0x20<br>报文标识符(2byte) ?? ??<br>byte &#x3D; 2 + 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6、PUBREL报文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0x60 0x20<br>报文标识符(2byte) ?? ??<br>byte &#x3D; 2 + 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 7、PUBCOMP 报文 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0x60 0x20<br>报文标识符(2byte) ?? ??<br>byte &#x3D; 2 + 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 8、SUBSCRIBE报文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0x80 ??<br>可变报头<br>    报文标识符(2byte) ?? ??<br>主题过滤器(nbyte &#x3D; 2byte + xbyte + 1byte)<br>    长度(2byte)<br>    主题过滤器(xbyte)<br>    服务质量要求(1byte)<br>byte &#x3D; 2 + 2 + n<br>报文标识符主要用于主题订阅和订阅确认的身份识别!!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 9、SUBACK 报文(server)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte) 0x90 03<br>可变报头(2byte) ?? ??(返回的这是SUBSCRIBE报文的报文标识符)<br>有效载荷(1byte) ??<br>byte &#x3D; 2 + 2 + 1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 10、UNSUBSCRIBE  (client)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0xA0 ??<br>可变报头<br>    报文标识符(2byte) ?? ??<br>主题过滤器(nbyte &#x3D; 2byte + xbyte)<br>    长度(2byte)<br>    主题过滤器(xbyte)<br>byte &#x3D; 2 + 2 + n</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 11、UNSUBACK （server）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte) 0xB0 02<br>可变报头(2byte) ?? ??(返回的这是SUBSCRIBE报文的报文标识符)<br>byte &#x3D; 2 + 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 12、PINGREQ报文（client）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0xC0 0x00<br>byte &#x3D; 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 13、PINGRESP报文（server）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0xD0 0x00<br>byte &#x3D; 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 14、DISCONNECT报文（client）</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>固定报头(2byte)0xE0 0x60<br>byte &#x3D; 2</p><pre><code></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MQTT数据帧解析&quot;&gt;&lt;a href=&quot;#MQTT数据帧解析&quot; class=&quot;headerlink&quot; title=&quot;MQTT数据帧解析&quot;&gt;&lt;/a&gt;MQTT数据帧解析&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;MQTT-控制报文格式&quot;&gt;&lt;a href=&quot;#M</summary>
      
    
    
    
    
    <category term="MQTT" scheme="http://example.com/tags/MQTT/"/>
    
  </entry>
  
  <entry>
    <title>红黑树</title>
    <link href="http://example.com/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://example.com/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2023-01-09T12:12:35.000Z</published>
    <updated>2023-09-13T01:49:59.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="红黑树（rbtree）"><a href="#红黑树（rbtree）" class="headerlink" title="红黑树（rbtree）"></a>红黑树（rbtree）</h2><p>[TOC]</p><h3 id="红黑树特性"><a href="#红黑树特性" class="headerlink" title="红黑树特性"></a>红黑树特性</h3><ul><li>1、节点是红节点或者是黑节点</li><li>2、根节点为黑色</li><li>3、叶节点为黑色（叶节点是指末梢的空姐点Nil或NULL）（保证一半以上是黑节点）（是一个满二叉树）</li><li>4、红节点的子节点必须是黑节点</li><li>5、新插入的节点是红节点</li><li>6、每个节点到叶子节点的所有路径，都包含相同数目的黑色节点（相同黑色高度）</li></ul><p>红黑树规则说明：</p><ul><li><p>规则4和5保证了红黑树的大致平衡，根节点到叶子的所有路径中，最长路径不会超过最短路径的两倍</p><p>使得红黑树在最坏的情况下，也能有O（log2N）的查找效率；</p></li></ul><h4 id="红黑树插入规律"><a href="#红黑树插入规律" class="headerlink" title="红黑树插入规律"></a>红黑树插入规律</h4><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230105144601026.png" alt="image-20230105144601026"></p><h3 id="红黑树的基本操作左旋右旋"><a href="#红黑树的基本操作左旋右旋" class="headerlink" title="红黑树的基本操作左旋右旋"></a>红黑树的基本操作左旋右旋</h3><h4 id="对X节点进行左旋"><a href="#对X节点进行左旋" class="headerlink" title="对X节点进行左旋"></a>对X节点进行左旋</h4><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230109161252478.png" alt="image-20230109161252478"></p><h4 id="对X节点进行右旋"><a href="#对X节点进行右旋" class="headerlink" title="对X节点进行右旋"></a>对X节点进行右旋</h4><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230109161710020.png" alt="image-20230109161710020"></p><h3 id="红黑树节点添加调整"><a href="#红黑树节点添加调整" class="headerlink" title="红黑树节点添加调整"></a>红黑树节点添加调整</h3><h5 id="红黑树节点添加（添加的节点都是红色节点）"><a href="#红黑树节点添加（添加的节点都是红色节点）" class="headerlink" title="红黑树节点添加（添加的节点都是红色节点）"></a>红黑树节点添加（添加的节点都是红色节点）</h5><p>将红黑树当作普通二叉树添加节点，只有在进行调整和着色。</p><p>当节点插入成功之后，我们需要根据插入的节点进行调整，使其变成一颗红黑树。</p><h5 id="插入节点的调整"><a href="#插入节点的调整" class="headerlink" title="插入节点的调整"></a>插入节点的调整</h5><p>节点插入之后可能出现3种情况：</p><ul><li>情况1：插入节点的父亲节点和叔叔节点是红色</li></ul><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230109174621234.png" alt="image-20230109174621234"></p><p>情况1处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、将插入节点的父节点设为黑色</span><br><span class="line">2、将插入节点的叔叔节点设为黑色</span><br><span class="line">3、将插入节点的祖父节点设为红色</span><br><span class="line">4、将祖父节点设为当前节点，之后继续对红色节点操作</span><br></pre></td></tr></table></figure><p>情况1处理完成之后会变成，情况2</p><ul><li>情况2：插入节点的叔叔节点是黑色，且当前节点是父节点的右孩子</li></ul><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230109175632366.png" alt="image-20230109175632366"></p><p>情况2处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1、将父节点作为新的当前节点</span><br><span class="line">2、以新的当前节点作为支点进行左旋</span><br></pre></td></tr></table></figure><ul><li><p>情况3：插入节点的叔叔节点是黑色，且当前节点是父节点的左孩子</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110093517079.png" alt="image-20230110093517079"></p></li></ul><p>情况3处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、将父亲节点设为黑色</span><br><span class="line">2、将祖父节点设为红色</span><br><span class="line">3、以祖父节点为支点进行右旋</span><br></pre></td></tr></table></figure><h3 id="红黑树节点删除"><a href="#红黑树节点删除" class="headerlink" title="红黑树节点删除"></a>红黑树节点删除</h3><h4 id="红黑树节点删除可能出现的情况"><a href="#红黑树节点删除可能出现的情况" class="headerlink" title="红黑树节点删除可能出现的情况"></a>红黑树节点删除可能出现的情况</h4><h5 id="被删除节点无子节点"><a href="#被删除节点无子节点" class="headerlink" title="被删除节点无子节点"></a>被删除节点无子节点</h5><ul><li><p>case 1:被删除节点为红色</p><ul><li>不需要任何处理，红黑树是平衡的。</li></ul></li><li><p>case 2:被删除节点为黑色</p><p>因为删除黑色结点会破坏红黑树的性质5，所以为了不破坏性质5，将node删除后用一个拥有额外黑色的null替代它（可以想象是将node删除后，在这个位置放了一个黑色的权值），剩下的就是调平的过程，最终这个游离的黑色权值被扔掉，整个删除操作完成。</p><ul><li><p>1、node节点的兄弟节点是红色</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110212714544.png" alt="image-20230110212714544"></p><p>处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（左旋父，父祖换色）</span><br><span class="line">1、将node的兄弟节点设为“黑色”。</span><br><span class="line">2、将node的父节点设为“红色”。</span><br><span class="line">3、对node的父节点进行左旋。</span><br><span class="line">4、左旋后，重新设置node的兄弟节点。</span><br></pre></td></tr></table></figure><p>如果NL节点下面的节点是NIL节点的话，就变成case4情况。</p><p>如果NIL节点下面的左节点是红节点，右节点是黑色。变成case3情况.</p><p>如果NIL节点下面的右节点是红节点，左节点是黑色。变成case2情况.</p></li><li><p>2、node的兄弟节点是黑色，兄弟节点的右孩子是红色（兄黑，右红侄）</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110210208576.png" alt="image-20230110210208576"></p><p>处理：（处理后，红黑树平衡）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（左旋父，祖染父色，父叔黑）</span><br><span class="line">1、将node父亲节点的颜色赋值给node的兄弟节点</span><br><span class="line">2、将node父亲节点设为黑色</span><br><span class="line">3、将node兄弟节点的右孩子设为黑色</span><br><span class="line">4、以node父亲节点为支点进行左旋</span><br><span class="line">5、设置node节点为根节点</span><br></pre></td></tr></table></figure></li><li><p>3、node的兄弟节点是黑色，兄弟节点的左孩子是红色（兄黑，左红侄）</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110203948743.png" alt="image-20230110203948743"></p><p>处理：（处理后变成兄黑，右红侄）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（右旋兄，交换兄弟节点与其右子节点颜色）</span><br><span class="line">1、将node兄弟节点的左孩子设为“黑色”。</span><br><span class="line">2、将node兄弟节点设为“红色”。</span><br><span class="line">3、对node的兄弟节点进行右旋。</span><br><span class="line">4、 右旋后，重新设置node的兄弟节点。</span><br></pre></td></tr></table></figure></li><li><p>4、node节点的兄弟节点是黑色，双黑节点（兄弟节点的子节点是NIL节点）</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110210411856.png" alt="image-20230110210411856"></p><p>处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">（兄弟红，用递归，遇到根节点或者是红节点，染黑回）</span><br><span class="line">（将兄弟染红，视角递归到P节点（或者说是当前节点是NIL节点的父节点），如果P节点是红色或者是根节点，就直接将P节点染黑返回）</span><br><span class="line">1、将node节点的兄弟节点设为红色</span><br><span class="line">2、将node的父节点设为新的node节点</span><br></pre></td></tr></table></figure><p>如果P节点是红色，直接将P节点染黑返回</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110221049902.png" alt="image-20230110221049902"></p><p>如果P节点是黑色，会变成case1情况。</p></li></ul></li></ul><h5 id="被删除节点只有一个子节点"><a href="#被删除节点只有一个子节点" class="headerlink" title="被删除节点只有一个子节点"></a>被删除节点只有一个子节点</h5><ul><li><p>case 3:被删除节点是黑色（被删除节点是红色不可能，违反规则）</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110223237204.png" alt="image-20230110223237204"></p><ul><li>将Node节点删除之后，把他的子节点变成黑色完成红黑树平衡</li></ul></li></ul><h5 id="被删节点有两个子节点（被删节点是黑色或者是红色）"><a href="#被删节点有两个子节点（被删节点是黑色或者是红色）" class="headerlink" title="被删节点有两个子节点（被删节点是黑色或者是红色）"></a>被删节点有两个子节点（被删节点是黑色或者是红色）</h5><p>当被删节点有两个节点的时候，需要先找到这个被删节点的后继节点（或者是前驱节点），不用改变颜色，将后继节点替换删除节点。</p><p>如果删除节点的后继节点是（node-&gt;right&gt;nl）,使用nl替换删除node之后，出现以下情况：</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110224417963.png" alt="image-20230110224417963"></p><ul><li>如果nl是黑色，会转变成case 2</li><li>如果nl是红色,   会转变成case 1</li></ul><p>如果删除节点的后继节点是（node-&gt;right）,使用nl替换删除node之后，出现一下情况：</p><p><img src="/2023/01/09/%E7%BA%A2%E9%BB%91%E6%A0%91/image-20230110224548810.png" alt="image-20230110224548810"></p><ul><li>如果right是黑色，会变成 case 3 </li><li>如果right是红色，会变成case 1</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;红黑树（rbtree）&quot;&gt;&lt;a href=&quot;#红黑树（rbtree）&quot; class=&quot;headerlink&quot; title=&quot;红黑树（rbtree）&quot;&gt;&lt;/a&gt;红黑树（rbtree）&lt;/h2&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h3 id=&quot;红黑树特性&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>gpio子系统</title>
    <link href="http://example.com/2022/12/05/gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/12/05/gpio%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-12-05T06:59:46.000Z</published>
    <updated>2023-09-13T01:49:59.240Z</updated>
    
    <content type="html"><![CDATA[<h2 id="gpio子系统"><a href="#gpio子系统" class="headerlink" title="gpio子系统"></a>gpio子系统</h2><p>&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi文件中的 GPIO 子节点记录着 GPIO 控制器的寄存器地址  ，</p><h4 id="gpio4节点"><a href="#gpio4节点" class="headerlink" title="gpio4节点"></a>gpio4节点</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">gpio4: gpio@20a8000 &#123;</span><br><span class="line">    compatible = &quot;fsl,imx6ul-gpio&quot;, &quot;fsl,imx35-gpio&quot;;</span><br><span class="line">    reg = &lt;0x20a8000 0x4000&gt;;</span><br><span class="line">    interrupts = &lt;GIC_SPI 72 IRQ_TYPE_LEVEL_HIGH&gt;,</span><br><span class="line">    &lt;GIC_SPI 73 IRQ_TYPE_LEVEL_HIGH&gt;;</span><br><span class="line">    clocks = &lt;&amp;clks IMX6UL_CLK_GPIO4&gt;;</span><br><span class="line">    gpio-controller;</span><br><span class="line">    #gpio-cells = &lt;2&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    #interrupt-cells = &lt;2&gt;;</span><br><span class="line">    gpio-ranges = &lt;&amp;iomuxc 0 94 17&gt;, &lt;&amp;iomuxc 17 117 12&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>compatible：与GPIO子系统的平台驱动做匹配</li><li>reg：GPIO 寄存器的基地址， GPIO4 的寄存器组是的映射地址为 0x20a8000-0x20ABFFF  </li><li>interrupts：描述中断相关的信息  </li><li>clocks：初始化 GPIO 外设时钟信息  </li><li>gpio-controller：表示 gpio4 是一个 GPIO 控制器  </li><li>#gpio-cells：表示有多少个 cells 来描述 GPIO 引脚  </li><li>interrupt-controller：表示 gpio4 也是个中断控制器  </li><li>#interrupt-cells：表示用多少个 cells 来描述一个中断  </li><li>gpio-ranges：将 gpio 编号转换成 pin 引脚， &lt;&amp;iomuxc 0 94 17&gt;，表示将 gpio4 的第 0 个引<br>脚引脚映射为 97， 17 表示的是引脚的个数。</li></ul><p>gpio4这个节点对整个gpio4进行了描述，使用gpio子系统时需要往设备树添加节点，在驱动程序中使用gpio子系统提供的API实现控制gpio的效果。</p><h4 id="在设备树中添加RGB灯的设备树节点"><a href="#在设备树中添加RGB灯的设备树节点" class="headerlink" title="在设备树中添加RGB灯的设备树节点"></a>在设备树中添加RGB灯的设备树节点</h4><p>在&#x2F;imx6ull-mmc-npi.dtb  的根节点下面添加RGB节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rgb_led&#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line">    pinctrl-names = &quot;default&quot;;</span><br><span class="line">    compatible = &quot;fire,rgb-led&quot;;</span><br><span class="line">    pinctrl-0 = &lt;&amp;pinctrl_rgb_led&gt;; //指定rgb灯的引脚pinctrl信息。</span><br><span class="line">    rgb_led_red = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;//指定引脚使用的哪个 GPIO</span><br><span class="line">    rgb_led_green = &lt;&amp;gpio4 20 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    rgb_led_blue = &lt;&amp;gpio4 19 GPIO_ACTIVE_LOW&gt;;</span><br><span class="line">    status = &quot;okay&quot;;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rgb_led_red = &lt;&amp;gpio1 4 GPIO_ACTIVE_LOW&gt;;</span><br></pre></td></tr></table></figure><ul><li><p>rgb_led_red：设置引脚名字，在使用gpio子系统提供的API操作GPIO时会用到。</p><p>const char *propname 参数用到rgb_led_red,在获取gpio编号时使用。</p></li><li><p>&amp;gpio1：指定gpio组</p></li><li><p>4：指定gpio编号</p></li><li><p>GPIO_ACTIVE_LOW：指定有效电平</p></li></ul><p>向设备树中添加节点后重新编译设备树。</p><h3 id="gpio子系统常用API函数详解"><a href="#gpio子系统常用API函数详解" class="headerlink" title="gpio子系统常用API函数详解"></a>gpio子系统常用API函数详解</h3><h5 id="of-get-named-gpio：获取gpio编号函数"><a href="#of-get-named-gpio：获取gpio编号函数" class="headerlink" title="of_get_named_gpio：获取gpio编号函数"></a>of_get_named_gpio：获取gpio编号函数</h5><p>GPIO 编号可以通过 of_get_named_gpio 函数从设备树中获取。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static inline int of_get_named_gpio(struct device_node *np, const char *propname,</span><br><span class="line">int index)</span><br></pre></td></tr></table></figure><ul><li>np：指定设备节点</li><li>propname：GPIO 属性名，与设备树中定义的属性名对应。  </li><li>index：引脚索引值，在设备树中一条引脚属性可以包含多个引脚，该参数用于指定获取那个引脚。</li></ul><p>成功返回gpio编号，失败返回负数；</p><h5 id="gpio-request-：gpio申请函数"><a href="#gpio-request-：gpio申请函数" class="headerlink" title="gpio_request ：gpio申请函数"></a>gpio_request ：gpio申请函数</h5><p>一个 GPIO 只能被申请一次，当不再使用某一个引脚时记得将其释放掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int gpio_request(unsigned gpio, const char *label);</span><br></pre></td></tr></table></figure><ul><li>gpio: 要申请的 GPIO 编号，该值是函数 of_get_named_gpio 的返回值。  </li><li>label: 引脚名字，相当于为申请得到的引脚取了个别名。</li></ul><p>成功返回0，失败返回负数；</p><h5 id="gpio-free：gpio释放函数"><a href="#gpio-free：gpio释放函数" class="headerlink" title="gpio_free：gpio释放函数"></a>gpio_free：gpio释放函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline void gpio_free(unsigned gpio);</span><br></pre></td></tr></table></figure><ul><li>gpio：要释放的 GPIO 编号。</li></ul><h5 id="gpio-direction-output：gpio输出设置函数"><a href="#gpio-direction-output：gpio输出设置函数" class="headerlink" title="gpio_direction_output：gpio输出设置函数"></a>gpio_direction_output：gpio输出设置函数</h5><p>用于将引脚设置为输出模式  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int gpio_direction_output(unsigned gpio , int value);</span><br></pre></td></tr></table></figure><ul><li>gpio：设置的 GPIO 的编号。  </li><li>value：输出值， 1，表示高电平。 0 表示低电平。</li></ul><p>成功返回0，失败返回负数；</p><h5 id="gpio-direction-input：gpio输入设置函数"><a href="#gpio-direction-input：gpio输入设置函数" class="headerlink" title="gpio_direction_input：gpio输入设置函数"></a>gpio_direction_input：gpio输入设置函数</h5><p>用于将引脚设置为输入模式。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int gpio_direction_input(unsigned gpio)</span><br></pre></td></tr></table></figure><ul><li>gpio：要设置的 GPIO 的编号。</li></ul><p>成功返回0，失败返回负数；</p><h5 id="gpio-get-value：获取gpio引脚值函数"><a href="#gpio-get-value：获取gpio引脚值函数" class="headerlink" title="gpio_get_value：获取gpio引脚值函数"></a>gpio_get_value：获取gpio引脚值函数</h5><p>用于获取引脚的当前状态。无论引脚被设置为输出或者输入都可以用该函数获取引脚的当前状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int gpio_get_value(unsigned gpio);</span><br></pre></td></tr></table></figure><ul><li>gpio：要设置的 GPIO 的编号。</li></ul><p>成功返回0，失败返回负数；</p><h5 id="gpio-set-value：设置gpio输出值"><a href="#gpio-set-value：设置gpio输出值" class="headerlink" title="gpio_set_value：设置gpio输出值"></a>gpio_set_value：设置gpio输出值</h5><p>该函数只用于那些设置为输出模式的 GPIO.  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static inline int gpio_direction_output(unsigned gpio, int value);</span><br></pre></td></tr></table></figure><ul><li>gpio：设置的 GPIO 的编号。  </li><li>value：输出值， 1，表示高电平。 0 表示低电平。</li></ul><p>成功返回0，失败返回负数；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;gpio子系统&quot;&gt;&lt;a href=&quot;#gpio子系统&quot; class=&quot;headerlink&quot; title=&quot;gpio子系统&quot;&gt;&lt;/a&gt;gpio子系统&lt;/h2&gt;&lt;p&gt;&amp;#x2F;home&amp;#x2F;dirivers&amp;#x2F;clone&amp;#x2F;imx_kerne</summary>
      
    
    
    
    
    <category term="Linux设备驱动" scheme="http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>pinctrl子系统</title>
    <link href="http://example.com/2022/12/05/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/12/05/pinctrl%E5%AD%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-12-05T06:09:03.000Z</published>
    <updated>2023-09-13T01:49:59.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pinctrl子系统"><a href="#pinctrl子系统" class="headerlink" title="pinctrl子系统"></a>pinctrl子系统</h2><h3 id="pinctrl子系统简介"><a href="#pinctrl子系统简介" class="headerlink" title="pinctrl子系统简介"></a>pinctrl子系统简介</h3><p>pinctrl 子系统主要用于管理芯片的引脚  </p><h3 id="pinctrl子系统编写格式"><a href="#pinctrl子系统编写格式" class="headerlink" title="pinctrl子系统编写格式"></a>pinctrl子系统编写格式</h3><h4 id="iomuxc节点介绍"><a href="#iomuxc节点介绍" class="headerlink" title="iomuxc节点介绍"></a>iomuxc节点介绍</h4><h5 id="去找到imx6ull-dtsi里面的iomuxc节点"><a href="#去找到imx6ull-dtsi里面的iomuxc节点" class="headerlink" title="去找到imx6ull.dtsi里面的iomuxc节点"></a>去找到imx6ull.dtsi里面的iomuxc节点</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/dirivers/clone/imx_kernel_4.19.35/ebf_linux_kernel_6ull_depth1/arch/arm/boot/dts/imx6ull.dtsi</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">iomuxc: iomuxc@20e0000 &#123;</span><br><span class="line">    compatible = &quot;fsl,imx6ul-iomuxc&quot;;</span><br><span class="line">    reg = &lt;0x20e0000 0x4000&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>compatible：与平台驱动做匹配的名字，这里是与pinctrl平台做匹配的名字</li><li>reg：表示的是引脚配置寄存器的基地址</li></ul><h5 id="在imx6ull-mmc-npi-dts里面使用-amp-iomuxc向iomuxc节点追加内容。"><a href="#在imx6ull-mmc-npi-dts里面使用-amp-iomuxc向iomuxc节点追加内容。" class="headerlink" title="在imx6ull-mmc-npi.dts里面使用&amp;iomuxc向iomuxc节点追加内容。"></a>在imx6ull-mmc-npi.dts里面使用&amp;iomuxc向iomuxc节点追加内容。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line"></span><br><span class="line">pinctrl_hog_1: hoggrp-1 &#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_UART1_RTS_B__GPIO1_IO190x17059 /* SD1 CD */</span><br><span class="line">MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT0x17059 /* SD1 VSELECT */</span><br><span class="line">MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        0x17059 /* SD1 RESET */</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pinctrl-names：指定pin的状态列表，默认设置为”default”</li><li>pinctrl-0 &#x3D; &lt;&amp;pinctrl_hog_1&gt;：表示在默认设置下，将使用pinctrl_hog_1这个节点来设置GPIO端口状态</li><li>其余都是pinctrl子节点，按照规范格式编写</li></ul><h5 id="pinctrl向iomuxc举例说明"><a href="#pinctrl向iomuxc举例说明" class="headerlink" title="pinctrl向iomuxc举例说明"></a>pinctrl向iomuxc举例说明</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">  pinctrl-names = &quot;default&quot;,&quot;sleep&quot;,&quot;init&quot;;</span><br><span class="line">  pinctrl-0 = &lt;&amp;pinctrl_uart1&gt;;</span><br><span class="line">  pinctrl-1 =&lt;&amp;xxx&gt;;</span><br><span class="line">  pinctrl-2 =&lt;&amp;yyy&gt;;</span><br><span class="line">  ...</span><br><span class="line">  pinctrl_uart1: uart1grp &#123;</span><br><span class="line">    fsl,pins = &lt;</span><br><span class="line">      MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1</span><br><span class="line">      MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1b0b1</span><br><span class="line">    &gt;;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   xxx: xxx_grp &#123;</span><br><span class="line">      ... 这里设置将引脚设置为其他模式</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   yyy: yyy_grp &#123;</span><br><span class="line">      ... 这里设置将引脚设置为其他模式</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>pinctrl-names： 定义引脚状态。  </li><li>pinctrl-0： 定义第 0 种状态需要使用到的引脚配置，可引用其他节点标识。  </li><li>pinctrl-1： 定义第 1 种状态需要使用到的引脚配置。  </li><li>pinctrl-2： 定义第 2 种状态需要使用到的引脚配置</li></ul><h5 id="pinctrl子节点格式规范，格式框架"><a href="#pinctrl子节点格式规范，格式框架" class="headerlink" title="pinctrl子节点格式规范，格式框架"></a>pinctrl子节点格式规范，格式框架</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pinctrl_自定义名字：自定义名字&#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">引脚复用宏定义 PAD（引脚属性）</span><br><span class="line">引脚复用宏定义 PAD（引脚属性）</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引脚复用宏定义在&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ul-pinfunc.hl里面去寻找</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">宏定义格式：</span><br><span class="line">#define MX6UL_xxx mux_reg conf_reg input_reg mux_mode input_val</span><br><span class="line"></span><br><span class="line">mux_reg conf_reg input_reg mux_mode input_val</span><br><span class="line">0x0084 0x0310 0x0000 0x0 0x0</span><br></pre></td></tr></table></figure><ul><li>mux_reg：引 脚 复 用 选 择 寄 存 器 偏 移 地 址  (在寄存器基地址上面偏移（0x0084）)</li><li>conf_reg：引脚（PAD）属性控制寄存器偏移地址  （基本参考官方给出的配置）</li><li>input_reg：输入选择寄存器便宜地址</li><li>mux_mode：选择需要配置的复用模式0</li><li>input_val：输入选择寄存器的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define MX6UL_PAD_BOOT_MODE0__GPIO5_IO100x0014 0x02a0 0x0000 5 0</span><br><span class="line">#define MX6UL_PAD_BOOT_MODE1__GPIO5_IO110x0018 0x02a4 0x0000 5 0</span><br></pre></td></tr></table></figure><h3 id="如何新增pinctrl节点"><a href="#如何新增pinctrl节点" class="headerlink" title="如何新增pinctrl节点"></a>如何新增pinctrl节点</h3><p>在imx6ull-mmc-npi.dts新增pinctrl节点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&amp;iomuxc &#123;</span><br><span class="line">pinctrl-names = &quot;default&quot;;</span><br><span class="line">pinctrl-0 = &lt;&amp;pinctrl_hog_1&gt;;</span><br><span class="line">/*新增加的pinctrl节点*/</span><br><span class="line">pinctrl_rgb_led:rgb_led&#123;</span><br><span class="line">fsl,pins = &lt;</span><br><span class="line">MX6UL_PAD_GPIO1_IO04__GPIO1_IO04 0x000010B1</span><br><span class="line">MX6UL_PAD_CSI_HSYNC__GPIO4_IO20 0x000010B1</span><br><span class="line">MX6UL_PAD_CSI_VSYNC__GPIO4_IO19 0x000010B1</span><br><span class="line">&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;pinctrl子系统&quot;&gt;&lt;a href=&quot;#pinctrl子系统&quot; class=&quot;headerlink&quot; title=&quot;pinctrl子系统&quot;&gt;&lt;/a&gt;pinctrl子系统&lt;/h2&gt;&lt;h3 id=&quot;pinctrl子系统简介&quot;&gt;&lt;a href=&quot;#pinctrl子系</summary>
      
    
    
    
    
    <category term="Linux设备驱动" scheme="http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>设备树插件</title>
    <link href="http://example.com/2022/12/04/%E8%AE%BE%E5%A4%87%E6%A0%91%E6%8F%92%E4%BB%B6/"/>
    <id>http://example.com/2022/12/04/%E8%AE%BE%E5%A4%87%E6%A0%91%E6%8F%92%E4%BB%B6/</id>
    <published>2022-12-04T12:51:28.000Z</published>
    <updated>2023-09-13T01:49:59.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设备树插件"><a href="#设备树插件" class="headerlink" title="设备树插件"></a>设备树插件</h2><h3 id="设备树插件简介"><a href="#设备树插件简介" class="headerlink" title="设备树插件简介"></a>设备树插件简介</h3><p>设备树插件使用模块化管理硬件资源，可以更加灵活的去使用。</p><h5 id="如何使用设备树插件？"><a href="#如何使用设备树插件？" class="headerlink" title="如何使用设备树插件？"></a>如何使用设备树插件？</h5><p>如果没有开启设备树插件的话，需要更改配置去开启设备树插件</p><h5 id="设备树插件语法"><a href="#设备树插件语法" class="headerlink" title="设备树插件语法"></a>设备树插件语法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/plugin/;</span><br><span class="line">/&#123;</span><br><span class="line">fragment@0 &#123;</span><br><span class="line">        target-path = &quot;/&quot;;</span><br><span class="line">        __overlay__ &#123;</span><br><span class="line">        /* 在此添加要插入的节点 */</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>&#x2F;dts-v1&#x2F;：用于指定dts的版本</p></li><li><p>&#x2F;plugin&#x2F;：表示允许使用未定义的引用并记录它们，设备树插件中可以引用主设备树中的节<br>点，而这些“引用的节点”对于设备树插件来说就是未定义的，所以设备树插件应该加上<br>“&#x2F;plugin&#x2F;”。  </p></li><li><p>target-path &#x3D; “xxx”：指定插件设备树的 父节点路径</p></li></ul><p>  target-path &#x3D; “&#x2F;“,指定设备树插件的加载位置,默认加载到根节点下。</p><ul><li>{<em><strong>overlay</strong></em> }：将要插入的设备及节点或者要引用追加的设备树节点放在overlay{}内；</li></ul><h3 id="设备树插件使用方式"><a href="#设备树插件使用方式" class="headerlink" title="设备树插件使用方式"></a>设备树插件使用方式</h3><h4 id="编译设备树插件"><a href="#编译设备树插件" class="headerlink" title="编译设备树插件"></a>编译设备树插件</h4><h5 id="使用手动编译-借助linux内核里面的插件编译工具"><a href="#使用手动编译-借助linux内核里面的插件编译工具" class="headerlink" title="使用手动编译(借助linux内核里面的插件编译工具)"></a>使用手动编译(借助linux内核里面的插件编译工具)</h5><p>找到scripts目录下面的dtc文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/kernel/build/scripts/dtc</span><br></pre></td></tr></table></figure><p>在scripts当前目录执行,将dts文件编译成dtbo</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dts -O dtb -o xxx.dtbo arch/arm/dts/xxx.dts</span><br><span class="line">/home/kernel/build/scripts/dtc/dtc -I dts -O dtb -o xxx.dtbo arch/arm/dts/xxx.dts</span><br><span class="line">//实际使用</span><br><span class="line">sudo /home/kernel/build/scripts/dtc/dtc -I dts -O dtb -o devtree_led.dtbo devtree_led.dts</span><br></pre></td></tr></table></figure><p>将dtbo文件反编译成dts</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./scripts/dtc/dtc -I dtb -O dts -o xxx.dtbo arch/arm/dts/xxx.dtbo</span><br></pre></td></tr></table></figure><h5 id="使用apt下载dtc工具"><a href="#使用apt下载dtc工具" class="headerlink" title="使用apt下载dtc工具"></a>使用apt下载dtc工具</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install device-tree-compiler</span><br></pre></td></tr></table></figure><h4 id="插件设备树的加载"><a href="#插件设备树的加载" class="headerlink" title="插件设备树的加载"></a>插件设备树的加载</h4><h5 id="在内核运行状态加载（通用）"><a href="#在内核运行状态加载（通用）" class="headerlink" title="在内核运行状态加载（通用）"></a>在内核运行状态加载（通用）</h5><p>1、在&#x2F;sys&#x2F;kernel&#x2F;config&#x2F;device-tree&#x2F;overlays&#x2F;目录下创建一个新目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /sys/kernel/config/device-tree/overlays/xxx</span><br></pre></td></tr></table></figure><p>2、将dtbo固件echo到path属性文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo xxx.dtbo &gt; /sys/kernel/config/device-tree/overlays/xxx/path</span><br></pre></td></tr></table></figure><p>或者将dtbo的内容cat到dtbo属性文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat xxx.dtbo &gt;/sys/kernel/config/device-tree/overlays/xxx/dtbo</span><br></pre></td></tr></table></figure><p>3、节点将被创建，查看内核设备树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/device-tree</span><br></pre></td></tr></table></figure><p>4、删除“插件设备树”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /sys/kernerl/config/device-tree/overlays/xxx</span><br></pre></td></tr></table></figure><h5 id="使用uboot加载（Linux-野火开发板）"><a href="#使用uboot加载（Linux-野火开发板）" class="headerlink" title="使用uboot加载（Linux_野火开发板）"></a>使用uboot加载（Linux_野火开发板）</h5><p>修改&#x2F;boot&#x2F;uEnv.txt配置文件，在uEnv.txt文件里面添加需要加载的dtbo文件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;设备树插件&quot;&gt;&lt;a href=&quot;#设备树插件&quot; class=&quot;headerlink&quot; title=&quot;设备树插件&quot;&gt;&lt;/a&gt;设备树插件&lt;/h2&gt;&lt;h3 id=&quot;设备树插件简介&quot;&gt;&lt;a href=&quot;#设备树插件简介&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Linux驱动开发" scheme="http://example.com/tags/Linux%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux设备树</title>
    <link href="http://example.com/2022/11/27/Linux%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
    <id>http://example.com/2022/11/27/Linux%E8%AE%BE%E5%A4%87%E6%A0%91/</id>
    <published>2022-11-27T11:04:04.000Z</published>
    <updated>2023-09-13T01:49:59.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux设备树"><a href="#Linux设备树" class="headerlink" title="Linux设备树"></a>Linux设备树</h2><h3 id="Linux设备树简介"><a href="#Linux设备树简介" class="headerlink" title="Linux设备树简介"></a>Linux设备树简介</h3><p>设备树是用来描述硬件平台的硬件资源信息，设备树可以被bootloader（uboot）传递到内核，使内内核可以从设备树中获取硬件信息。</p><p>带.dtsi后缀的文件表示的使设备树文件，需要使用设备树文件的话，直接包含设备树文件即可。#include xxx</p><h5 id="DTS：指-dts格式文件，一种使用ASII文本格式的设备树描述，一个-dts文件对应一个硬件平台。"><a href="#DTS：指-dts格式文件，一种使用ASII文本格式的设备树描述，一个-dts文件对应一个硬件平台。" class="headerlink" title="DTS：指.dts格式文件，一种使用ASII文本格式的设备树描述，一个.dts文件对应一个硬件平台。"></a>DTS：指.dts格式文件，一种使用ASII文本格式的设备树描述，一个.dts文件对应一个硬件平台。</h5><p>一般位于&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts目录下。（我们一般修改编写的设备树源码就是这个）</p><h5 id="DTC：指编译设备树源码的工具，一般需要手动安装。"><a href="#DTC：指编译设备树源码的工具，一般需要手动安装。" class="headerlink" title="DTC：指编译设备树源码的工具，一般需要手动安装。"></a>DTC：指编译设备树源码的工具，一般需要手动安装。</h5><h5 id="DTB：设备树源码编译生成的文件。"><a href="#DTB：设备树源码编译生成的文件。" class="headerlink" title="DTB：设备树源码编译生成的文件。"></a>DTB：设备树源码编译生成的文件。</h5><h3 id="设备树框架"><a href="#设备树框架" class="headerlink" title="设备树框架"></a>设备树框架</h3><h4 id="设备树详解"><a href="#设备树详解" class="headerlink" title="设备树详解"></a>设备树详解</h4><h5 id="设备树源码分析"><a href="#设备树源码分析" class="headerlink" title="设备树源码分析"></a>设备树源码分析</h5><ul><li><p>头文件：设备树的头文件是可以使用#include 去应用设备树文件的。#include “imx6ull.dtsi”,</p><p>imx6ull.dtsi一般由NXP官方提供。</p></li><li><p>设备树节点：每一个设备树根节点只有一个根节点。其余都是根节点的子节点，子节点也可以包含其他节点。</p></li><li><p>设备树节点追加内容：使用&amp;符号去向节点追加数据。</p></li></ul><h4 id="设备树节点"><a href="#设备树节点" class="headerlink" title="设备树节点"></a>设备树节点</h4><h5 id="设备树节点基本格式"><a href="#设备树节点基本格式" class="headerlink" title="设备树节点基本格式"></a>设备树节点基本格式</h5><p>设备树中的节点都是按照以下约定命名。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">node-name@unit-address&#123;</span><br><span class="line">属性 1 = …</span><br><span class="line">属性 2 = …</span><br><span class="line">属性 3 = …</span><br><span class="line">子节点…</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>node-name节点名称</p><ul><li>node-name用于指定节点名称，一般是1-31个字符。</li><li>根节点没有节点名，直接使用”&#x2F;“代替这是一个根节点</li></ul></li><li><p>@：是一个分隔符</p></li><li><p>unit-address：用于指定单元地址，他的值要和”reg“属性的第一个地址一致，若没有”reg”属性可省略。</p></li></ul><h5 id="设备树节点标签"><a href="#设备树节点标签" class="headerlink" title="设备树节点标签"></a>设备树节点标签</h5><p>imx6ull.dtsi 头文件中  ，cpu前面多了个cpu0，这个cpu0就是该节点的标签。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpu0: cpu@0</span><br></pre></td></tr></table></figure><p>通常节点标签是节点名的简写。其他位置需要引用该节点时，可以直接使用节点标签。</p><h5 id="设备树节点路径"><a href="#设备树节点路径" class="headerlink" title="设备树节点路径"></a>设备树节点路径</h5><p>通过指定从根节点到所需节点的完整路径，可以唯一地标识设备树中的节点， 不同层次的设备树节点名字可以相同，同层次的设备树节点要唯一。  </p><h5 id="设备树节点属性"><a href="#设备树节点属性" class="headerlink" title="设备树节点属性"></a>设备树节点属性</h5><p>在节点的{}中包含的内容就是节点的属性。通常一个节点包含多个属性信息，这些信息会传递到内核的信息描述中，驱动可以通过API函数去获取这些属性信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">intc: interrupt-controller@a01000 &#123;</span><br><span class="line">    compatible = &quot;arm,cortex-a7-gic&quot;;</span><br><span class="line">    #interrupt-cells = &lt;3&gt;;</span><br><span class="line">    interrupt-controller;</span><br><span class="line">    reg = &lt;0xa01000 0x1000&gt;,</span><br><span class="line">    &lt;0xa02000 0x100&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>compatible属性：字符串类型的属性。</p><ul><li><p>compatible 属性值由一个或多个字符串组成，有多个字符串时使用“,”分隔开。  </p></li><li><p>设备树中没有代表了一个设备的节点都要有一个compatible属性，（设备驱动在匹配时需要使用compatible来匹配），compatible属性是用来查找节点的方法之一。节点名和节点路径都可以用来查找指定节点。</p></li></ul></li><li><p>model属性：字符串属性类型</p><p>model属性用于指定设备的制造商和型号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = &quot;Embedfire i.MX6ULL Board&quot;;</span><br></pre></td></tr></table></figure></li><li><p>status属性：字符串属性类型</p><p>status属性用于指示设备的操作状态；可以通过status去禁止设备或者是启用设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sound:sound&#123;</span><br><span class="line">status = &quot;disable&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>#address-cell和#size-cells</p><p>#address-cell和#size-cells属性同时存在，在设备树ocrams结构中，他们使用在由子节点的设备节点，可以用于设置节点的reg属性的书写格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">soc &#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line">    compatible = &quot;simple-bus&quot;;</span><br><span class="line">    interrupt-parent = &lt;&amp;gpc&gt;;</span><br><span class="line">    ranges;</span><br><span class="line">    ocrams: sram@900000 &#123;</span><br><span class="line">    compatible = &quot;fsl,lpm-sram&quot;;</span><br><span class="line">    reg = &lt;0x900000 0x4000&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>reg属性值由一串数字组成，reg &#x3D; &lt;0x900000 0x4000&gt;中 0x900000是数据地址（地址字段），0x4000是</p><p>长度字段（大小字段）。(cells 是一个 32 位宽的数字  )</p><ul><li>#address-cells：指定reg属性”地址字段“的长度，</li><li>#size-cells：指定reg属性”大小字段“的长度，</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">reg = &lt;address size&gt;</span><br><span class="line"></span><br><span class="line">#address-cells = &lt;2&gt;;</span><br><span class="line">#size-cells = &lt;1&gt;;</span><br><span class="line">reg = &lt;address address size&gt;</span><br><span class="line"></span><br><span class="line">#address-cells = &lt;1&gt;;</span><br><span class="line">#size-cells = &lt;2&gt;;</span><br><span class="line">reg = &lt;address size size&gt;</span><br></pre></td></tr></table></figure></li><li><p>reg属性：属性值类型，地址，长度数据对。</p><p>reg 属性描述设备资源在其父总线定义的地址空间内的地址。  通常情况下用于表示一块寄存器的<br>起始地址（偏移地址）和长度，在特定情况下也有不同的含义  。</p></li><li><p>ranges属性：属性值类型，任意数量的 &lt; 子地址、父地址、地址长度 &gt; 编码  </p><p>该属性提供了子节点地址空间和父地址空间的映射（转换）方法，常见格式是ranges &#x3D; &lt;子地址，父地址，转换长度&gt;。若父地址和子地址空间无需转换，直接省略ranges属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">若#address-cells 和 #size-cells 都为 1</span><br><span class="line">ranges=&lt;0x0 0x10 0x20&gt; </span><br></pre></td></tr></table></figure><p>将子地址0x0-0x20的地址空间映射到父地址0x20-(0x20+0x20)的地址。</p></li><li><p>追加、修改节点内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&amp;cpu0 &#123;</span><br><span class="line">dc-supply = &lt;&amp;reg_gpio_dvfs&gt;;</span><br><span class="line">clock-frequency = &lt;800000000&gt;;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>“&amp;cpu0”表示向“节点标签”为“cpu0”的节点追加数据，这个节点可能定义在本<br>文件也可能定义在本文件所包含的设备树文件中  </p></li><li><p>特殊节点：aliases子节点</p><p>作用是为其他节点起一个别名，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">can0 = &amp;flexcan1;</span><br><span class="line">can1 = &amp;flexcan2;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>flexcan1”是一个节点的名字，设置别名后我们可以使用“can0”<br>来指代 flexcan1 节点，与节点标签类似。  </p></li><li><p>chosen子节点</p></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">stdout-path = &amp;uart1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>chosen 子节点不代表实际硬件，它主要用于给内核传递参数。这里只设置了“stdout-path &#x3D;&amp;uart1;”<br>一条属性，表示系统标准输出 stdout 使用串口 uart1。</p></li></ul><h3 id="获取设备树节点信息"><a href="#获取设备树节点信息" class="headerlink" title="获取设备树节点信息"></a>获取设备树节点信息</h3><p>使用of操作函数去获取设备节点资源。</p><h4 id="查找节点函数"><a href="#查找节点函数" class="headerlink" title="查找节点函数"></a>查找节点函数</h4><p>device_node结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct device_node &#123;</span><br><span class="line">const char *name;</span><br><span class="line">const char *type;</span><br><span class="line">phandle phandle;</span><br><span class="line">const char *full_name;</span><br><span class="line">struct fwnode_handle fwnode;</span><br><span class="line"></span><br><span class="line">structproperty *properties;</span><br><span class="line">structproperty *deadprops;/* removed properties */</span><br><span class="line">structdevice_node *parent;</span><br><span class="line">structdevice_node *child;</span><br><span class="line">structdevice_node *sibling;</span><br><span class="line">#if defined(CONFIG_OF_KOBJ)</span><br><span class="line">structkobject kobj;</span><br><span class="line">#endif</span><br><span class="line">unsigned long _flags;</span><br><span class="line">void*data;</span><br><span class="line">#if defined(CONFIG_SPARC)</span><br><span class="line">const char *path_component_name;</span><br><span class="line">unsigned int unique_id;</span><br><span class="line">struct of_irq_controller *irq_trans;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>name： 节点中属性为 name 的值  </p></li><li><p>type： 节点中属性为 device_type 的值  </p></li><li><p>full_name： 节点的名字，在 device_node 结构体后面放一个字符串， full_name 指向它  </p></li><li><p>properties： 链表，连接该节点的所有属性  </p></li><li><p>parent： 指向父节点  </p></li><li><p>child： 指向子节点  </p></li><li><p>sibling： 指向兄弟节点</p></li></ul><h5 id="1、根据节点路径寻找节点函数（推荐）"><a href="#1、根据节点路径寻找节点函数（推荐）" class="headerlink" title="1、根据节点路径寻找节点函数（推荐）"></a>1、根据节点路径寻找节点函数（推荐）</h5><p>获取device_node结构体；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct device_node *of_find_node_by_path(const char *path)</span><br></pre></td></tr></table></figure><ul><li>path： 指定节点在设备树中的路径</li></ul><p>返回值：device_node： 结构体指针  ，如果查找失败则返回 NULL  </p><p>得到device_node 结构体之后我们就可以使用其他 of 函数获取节点的详细信息  </p><h5 id="2、根据节点名字寻找节点函数（不建议）"><a href="#2、根据节点名字寻找节点函数（不建议）" class="headerlink" title="2、根据节点名字寻找节点函数（不建议）"></a>2、根据节点名字寻找节点函数（不建议）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct device_node *of_find_node_by_name(struct device_node *from,</span><br><span class="line">const char *name);</span><br></pre></td></tr></table></figure><ul><li><p>from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果<br>设置为 NULL 表示从根节点开始查找。  </p></li><li><p>name： 要寻找的节点名。</p></li></ul><p>返回值：device_node： 结构体指针  ，如果查找失败则返回 NULL  </p><h5 id="3、根据节点类型寻找节点函数（不建议）"><a href="#3、根据节点类型寻找节点函数（不建议）" class="headerlink" title="3、根据节点类型寻找节点函数（不建议）"></a>3、根据节点类型寻找节点函数（不建议）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct device_node *of_find_node_by_type(struct device_node *from，</span><br><span class="line">constchar *type)</span><br></pre></td></tr></table></figure><ul><li><p>from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果<br>设置为 NULL 表示从根节点开始查找。  </p></li><li><p>type： 要查找节点的类型，这个类型就是 device_node-&gt; type。</p></li></ul><p>返回值：device_node： 结构体指针  ，如果查找失败则返回 NULL  </p><h5 id="4、根据节点类型和compatible属性寻找节点函数（不建议-）"><a href="#4、根据节点类型和compatible属性寻找节点函数（不建议-）" class="headerlink" title="4、根据节点类型和compatible属性寻找节点函数（不建议 ）"></a>4、根据节点类型和compatible属性寻找节点函数（不建议 ）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct device_node *of_find_compatible_node(struct device_node *from,</span><br><span class="line">const char *type, const char *compatible)</span><br></pre></td></tr></table></figure><ul><li><p>from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果<br>设置为 NULL 表示从根节点开始查找。  </p></li><li><p>type： 要查找节点的类型，这个类型就是 device_node-&gt; type。  </p></li><li><p>compatible： 要查找节点的 compatible 属性。</p></li></ul><p>返回值：device_node： 结构体指针  ，如果查找失败则返回 NULL  </p><h5 id="5、根据匹配表寻找节点函数"><a href="#5、根据匹配表寻找节点函数" class="headerlink" title="5、根据匹配表寻找节点函数"></a>5、根据匹配表寻找节点函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static inline struct device_node *of_find_matching_node_and_match(</span><br><span class="line">struct device_node *from, const struct of_device_id *matches,</span><br><span class="line">const struct of_device_id **match)</span><br></pre></td></tr></table></figure><ul><li><p>from： 指定从哪个节点开始查找，它本身并不在查找行列中，只查找它后面的节点，如果<br>设置为 NULL 表示从根节点开始查找。  </p></li><li><p>matches： 源匹配表，查找与该匹配表想匹配的设备节点。  </p></li><li><p>of_device_id： 结构体如下。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct of_device_id &#123;</span><br><span class="line">charname[32];</span><br><span class="line">chartype[32];</span><br><span class="line">charcompatible[128];</span><br><span class="line">const void *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name： 节点中属性为 name 的值  </li><li>type： 节点中属性为 device_type 的值  </li><li>compatible： 节点的名字，在 device_node 结构体后面放一个字符串， full_name 指向它  </li><li>data： 链表，连接该节点的所有属性</li></ul></li></ul><p>返回值：device_node： 结构体指针  ，如果查找失败则返回 NULL  </p><h5 id="6、寻找父节点函数"><a href="#6、寻找父节点函数" class="headerlink" title="6、寻找父节点函数"></a>6、寻找父节点函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct device_node *of_get_parent(const struct device_node *node)  </span><br></pre></td></tr></table></figure><ul><li>node： 指定谁（节点）要查找父节点。</li></ul><p>返回值：device_node： device_node 类型的结构体指针，保存获取得到的节点。  失败返回NULL</p><h5 id="7、寻找子节点函数"><a href="#7、寻找子节点函数" class="headerlink" title="7、寻找子节点函数"></a>7、寻找子节点函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct device_node *of_get_next_child(const struct device_node *node,</span><br><span class="line">struct device_node *prev)</span><br></pre></td></tr></table></figure><ul><li><p>node： 指定谁（节点）要查找它的子节点  </p></li><li><p>prev： 前一个子节点，寻找的是 prev 节点之后的节点。这是一个迭代寻找过程，例如寻找<br>第二个子节点，这里就要填第一个子节点。参数为 NULL 表示寻找第一个子节点。</p></li></ul><p>返回值：device_node： device_node 类型的结构体指针，保存获取得到的节点。  失败返回NULL</p><h4 id="提取属性值的of函数"><a href="#提取属性值的of函数" class="headerlink" title="提取属性值的of函数"></a>提取属性值的of函数</h4><p>我们获取了device_node结构体之后们就可以获取里面的设备节点属性信息  。</p><h5 id="获取节点属性函数"><a href="#获取节点属性函数" class="headerlink" title="获取节点属性函数"></a>获取节点属性函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct property *of_find_property(const struct device_node *np,</span><br><span class="line">const char name,int *lenp</span><br></pre></td></tr></table></figure><ul><li><p>np： 指定要获取那个设备节点的属性信息  </p></li><li><p>name： 属性名。  </p></li><li><p>lenp： 获取得到的属性值的大小，这个指针作为输出参数，这个参数“带回”的值是实际获<br>取得到的属性大小。</p></li></ul><p>返回值：获取得到的属性 结构体（property），失败返回NULL；</p><p>property属性结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct property &#123;</span><br><span class="line">char*name;</span><br><span class="line">intlength;</span><br><span class="line">void*value;</span><br><span class="line">struct property *next;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>name： 属性名  </p></li><li><p>length： 属性长度  </p></li><li><p>value： 属性值  </p></li><li><p>next： 下一个属性</p></li></ul><h5 id="读取整形属性函数"><a href="#读取整形属性函数" class="headerlink" title="读取整形属性函数"></a>读取整形属性函数</h5><p>读取属性函数是一组函数，分别为读取 8、 16、 32、 64 位数据。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//8 位整数读取函数</span><br><span class="line">int of_property_read_u8_array(const struct device_node *np,</span><br><span class="line">const char *propname, u8 *out_values, size_t sz)</span><br><span class="line">//16 位整数读取函数</span><br><span class="line">int of_property_read_u16_array(const struct device_node *np,</span><br><span class="line">const char *propname, u16 *out_values, size_t sz)</span><br><span class="line">//32 位整数读取函数</span><br><span class="line">int of_property_read_u32_array(const struct device_node *np,</span><br><span class="line">const char *propname, u32 *out_values, size_t sz)</span><br><span class="line">//64 位整数读取函数</span><br><span class="line">int of_property_read_u64_array(const struct device_node *np,</span><br><span class="line">const char *propname, u64 *out_values, size_t sz)</span><br></pre></td></tr></table></figure><ul><li><p>np： 指定要读取那个设备节点结构体，也就是说读取那个设备节点的数据。  </p></li><li><p>propname： 指定要获取设备节点的哪个属性。  </p></li><li><p>out_values： 这是一个输出参数，是函数的“返回值”，保存读取得到的数据。  </p></li><li><p>sz： 这是一个输入参数，它用于设置读取的长度。</p></li></ul><p>返回值：返回值，成功返回 0，错误返回错误状态码（非零值）， -EINVAL（属性不存在）， -ENODATA<br>（没有要读取的数据）， -EOVERFLOW（属性值列表太小）。  </p><h5 id="读取字符串属性函数"><a href="#读取字符串属性函数" class="headerlink" title="读取字符串属性函数"></a>读取字符串属性函数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int of_property_read_string(const struct device_node *np,</span><br><span class="line">const char *propname,const char **out_string)</span><br></pre></td></tr></table></figure><ul><li>np： 指定要获取那个设备节点的属性信息  </li><li>propname： 属性名  </li><li>out_string： 获取得到字符串指针，这是一个“输出”参数，带回一个字符串指针。也就是<br>字符串属性值的首地址。  这个地址是“属性值”在内存中的真实位置，也就是说我们可以<br>通过对地址操作获取整个字符串属性</li></ul><p>返回值：返回值，成功返回 0，错误返回错误状态码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int of_property_read_string_index(const struct device_node *np,</span><br><span class="line">const char *propname, int index,const char **out_string)</span><br></pre></td></tr></table></figure><p>相比前面的函数增加了参数 index，它用于指定读取属性值中第几个字符串， index 从零开始计数。<br>第一个函数只能得到属性值所在地址，也就是第一个字符串的地址，其他字符串需要我们手动修<br>改移动地址，非常麻烦，推荐使用第二个函数。  </p><p>….</p><h4 id="内存映射相关of函数"><a href="#内存映射相关of函数" class="headerlink" title="内存映射相关of函数"></a>内存映射相关of函数</h4><h5 id="of-ioremap函数，直接转换为虚拟地址"><a href="#of-ioremap函数，直接转换为虚拟地址" class="headerlink" title="of_ioremap函数，直接转换为虚拟地址"></a>of_ioremap函数，直接转换为虚拟地址</h5><p>我们获取相关寄存器地址后，需要将实际物理地址转化为虚拟地址。</p><p>内核提供了 of 函数，自动完成物理地址到虚拟地址的转换。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void __iomem *of_iomap(struct device_node *np, int index)</span><br></pre></td></tr></table></figure><ul><li><p>np： 指定要获取那个设备节点的属性信息。  </p></li><li><p>index： 通常情况下 reg 属性包含多段， index 用于指定映射那一段，标号从 0 开始。</p></li></ul><p>返回值：成功，得到转换得到的地址。失败返回 NULL。  </p><h5 id="常规获取地址的-of-函数-，获取的是实际物理地址"><a href="#常规获取地址的-of-函数-，获取的是实际物理地址" class="headerlink" title="常规获取地址的 of 函数  ，获取的是实际物理地址"></a>常规获取地址的 of 函数  ，获取的是实际物理地址</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int of_address_to_resource(struct device_node *dev, int index,</span><br><span class="line">struct resource *resource)</span><br></pre></td></tr></table></figure><ul><li><p>np： 指定要获取那个设备节点的属性信息。  </p></li><li><p>index： 通常情况下 reg 属性包含多段， index 用于指定映射那一段，标号从 0 开始。  </p></li><li><p>r： 这是一个 resource 结构体，是“输出参数”用于返回得到的地址信息。</p></li></ul><p>返回值：成功返回 0，失败返回错误状态码。  </p><h3 id="如何向设备树中添加自己的节点和获取信息"><a href="#如何向设备树中添加自己的节点和获取信息" class="headerlink" title="如何向设备树中添加自己的节点和获取信息"></a>如何向设备树中添加自己的节点和获取信息</h3><h4 id="1、向设备树里面添加设备节点"><a href="#1、向设备树里面添加设备节点" class="headerlink" title="1、向设备树里面添加设备节点"></a>1、向设备树里面添加设备节点</h4><p>找到&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-mmc-npi.dts的dts文件</p><p>进入&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F; </p><p>向dts设备树文件里面添加子节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">led_test&#123;</span><br><span class="line">    #address-cells = &lt;1&gt;;</span><br><span class="line">    #size-cells = &lt;1&gt;;</span><br><span class="line"></span><br><span class="line">    rgb_led_red@0x0209C000&#123;</span><br><span class="line">        compatible = &quot;fire,rgb_led_red&quot;;</span><br><span class="line">        reg = &lt;0x0209C000 0x00000020&gt;;</span><br><span class="line">        status = &quot;okay&quot;;</span><br><span class="line">     &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="使用命令只编译设备树"><a href="#使用命令只编译设备树" class="headerlink" title="使用命令只编译设备树"></a>使用命令只编译设备树</h5><p>进入&#x2F;home&#x2F;dirivers&#x2F;clone&#x2F;imx_kernel_4.19.35&#x2F;ebf_linux_kernel_6ull_depth1，在该目录下运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- npi_v7_defconfig</span><br><span class="line">sudo make ARCH=arm -j4 CROSS_COMPILE=arm-linux-gnueabihf- dtbs</span><br></pre></td></tr></table></figure><p>编译成功后生成的设备树文件（.dtb）位于源码目录下的&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;，文件名为“imx6ull-mmc-npi.dtb”  </p><h5 id="替换开发板上面的imx6ull-mmc-npi-dtb"><a href="#替换开发板上面的imx6ull-mmc-npi-dtb" class="headerlink" title="替换开发板上面的imx6ull-mmc-npi.dtb"></a>替换开发板上面的imx6ull-mmc-npi.dtb</h5><p>将重新编译的imx6ull-mmc-npi.dtb 设备树文件，替换开发板上面的&#x2F;usr&#x2F;lib&#x2F;linux-image-4.19.35-imx6&#x2F;imx6ull-mmc-npi.dtb  的设备树文件。</p><h4 id="Linux系统中查看设备树"><a href="#Linux系统中查看设备树" class="headerlink" title="Linux系统中查看设备树"></a>Linux系统中查看设备树</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls /proc/device-tree</span><br><span class="line">ls /sys/firmware/devicetree/base</span><br></pre></td></tr></table></figure><h4 id="获取设备树信息"><a href="#获取设备树信息" class="headerlink" title="获取设备树信息"></a>获取设备树信息</h4><p>使用of_find_node_by_path找到设备树节点，再去获取设备树子节点，再去获取子节点里面的寄存器信息。</p><p>在板卡上的部分 GPIO 可能会被系统占用，在使用前请根据需要修改 &#x2F;boot&#x2F;uEnv.txt 文件，可注释<br>掉某些设备树插件的加载，重启系统，释放相应的 GPIO 引脚。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux设备树&quot;&gt;&lt;a href=&quot;#Linux设备树&quot; class=&quot;headerlink&quot; title=&quot;Linux设备树&quot;&gt;&lt;/a&gt;Linux设备树&lt;/h2&gt;&lt;h3 id=&quot;Linux设备树简介&quot;&gt;&lt;a href=&quot;#Linux设备树简介&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Linux设备驱动" scheme="http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>平台设备驱动</title>
    <link href="http://example.com/2022/11/23/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    <id>http://example.com/2022/11/23/%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</id>
    <published>2022-11-23T12:50:30.000Z</published>
    <updated>2023-09-13T01:49:59.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="平台设备驱动"><a href="#平台设备驱动" class="headerlink" title="平台设备驱动"></a>平台设备驱动</h2><p>平台总线-Linux内核引进的一种虚拟总线（platfrom bus）</p><h3 id="平台总线"><a href="#平台总线" class="headerlink" title="平台总线"></a>平台总线</h3><h5 id="平台总线的注册和匹配方式"><a href="#平台总线的注册和匹配方式" class="headerlink" title="平台总线的注册和匹配方式"></a>平台总线的注册和匹配方式</h5><p>使用platfrom_bus_type来描述平台总线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type platform_bus_type = &#123;</span><br><span class="line">.name = &quot;platform&quot;,</span><br><span class="line">.dev_groups = platform_dev_groups,</span><br><span class="line">.match = platform_match,</span><br><span class="line">.uevent = platform_uevent,</span><br><span class="line">.pm = &amp;platform_dev_pm_ops</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>平台设备总线在Linux启动时自动注册</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bus_register(&amp;platform_bus_type);  </span><br></pre></td></tr></table></figure><h5 id="平台设备的匹配"><a href="#平台设备的匹配" class="headerlink" title="平台设备的匹配"></a>平台设备的匹配</h5><p>平台总线采用platform_match函数去匹配平台设备和平台驱动</p><p>平台设备去匹配设备可以通过四种方式：</p><ul><li><p>通过设备树机制去进行匹配</p><ul><li>通过设备树去获取设备信息，来进行匹配</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (of_driver_match_device(dev, drv))</span><br><span class="line">return 1</span><br></pre></td></tr></table></figure></li><li><p>ACPI匹配模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (acpi_driver_match_device(dev, drv))</span><br><span class="line">return 1;</span><br></pre></td></tr></table></figure></li><li><p>id_table方式去匹配</p><ul><li><p>通过我们在定义驱动结构体（platform_driver  ）时提供的id_table数组，去比较id_table里面的</p><p>name成员与平台设备成员里面的的name成员，来进行匹配。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (pdrv-&gt;id_table)</span><br><span class="line">return platform_match_id(pdrv-&gt;id_table, pdev) != NULL;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static const struct platform_device_id *platform_match_id(</span><br><span class="line">const struct platform_device_id *id,</span><br><span class="line">struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    while (id-&gt;name[0]) &#123;</span><br><span class="line">        if (strcmp(pdev-&gt;name, id-&gt;name) == 0) &#123;</span><br><span class="line">        pdev-&gt;id_entry = id;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    id++;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要使用id_table方式去进行匹配我们需要在添加平台驱动的时候添加id_table数组元素。</p></li></ul></li><li><p>字符串比较方式去匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return (strcmp(pdev-&gt;name, drv-&gt;name) == 0);</span><br></pre></td></tr></table></figure></li></ul><p>上面四种匹配方式的先后顺序是从上到下，最上面的匹配方式优先级最高，最下面的匹配方式优先级最低。</p><h5 id="什么时候进行平台总线匹配？"><a href="#什么时候进行平台总线匹配？" class="headerlink" title="什么时候进行平台总线匹配？"></a>什么时候进行平台总线匹配？</h5><p>每当有新的设备或者是新的驱动加入到总线时，总线会调用paltform_match函数去对新添加的设备或者是驱动，进行配对。</p><h3 id="平台设备"><a href="#平台设备" class="headerlink" title="平台设备"></a>平台设备</h3><h4 id="内核使用platform-device来描述平台设备"><a href="#内核使用platform-device来描述平台设备" class="headerlink" title="内核使用platform_device来描述平台设备"></a>内核使用platform_device来描述平台设备</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device &#123;</span><br><span class="line">const char*name;</span><br><span class="line">intid;</span><br><span class="line">boolid_auto;</span><br><span class="line">struct devicedev;</span><br><span class="line">u32num_resources;</span><br><span class="line">struct resource*resource;</span><br><span class="line"></span><br><span class="line">const struct platform_device_id*id_entry;</span><br><span class="line">char *driver_override; /* Driver name to force a match */</span><br><span class="line"></span><br><span class="line">/* MFD cell pointer */</span><br><span class="line">struct mfd_cell *mfd_cell;</span><br><span class="line"></span><br><span class="line">/* arch specific additions */</span><br><span class="line">struct pdev_archdataarchdata;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>name：设备名称，总线进行匹配时，会比较设备和驱动的名称是否一致；  </p></li><li><p>id  ：设备的编号，如果Linux里面设备同名，则通过该编号来识别不同设备。</p></li><li><p>dev：继承Linux里面的设备模型中的device结构体，管理平台设备。</p></li><li><p>num_resources：记录资源的个数，当结构成员resource存放的是数组时，记录的是数组的个数。</p><p>使用ARRAY_SIZE计算数组大小。</p></li><li><p>resource：平台设备提供给驱动的资源，irq,dma,io,内存。</p></li><li><p>id_entry：平台设备提供的一种匹配方式。</p></li></ul><h5 id="使用resource-来描述提供给驱动的资源"><a href="#使用resource-来描述提供给驱动的资源" class="headerlink" title="使用resource 来描述提供给驱动的资源"></a>使用resource 来描述提供给驱动的资源</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct resource &#123;</span><br><span class="line">resource_size_t start;</span><br><span class="line">resource_size_t end;</span><br><span class="line">const char *name;</span><br><span class="line">unsigned long flags;</span><br><span class="line">unsigned long desc;</span><br><span class="line">struct resource *parent, *sibling, *child;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要指定资源的名字（可有可无），指定资源的起始地址和结束地址，指定提供资源的类型。</p><ul><li>start：资源的起始地址</li><li>end：资源的结束地址</li><li>name：指定资源的名字（可设置为NULL）</li><li>flags：指定资源的类型<ul><li>IORESOURCE_IO：用于IO地址空间，用于IO端口映射</li><li>IORESOURCE_MEM：用于外设的可直接寻址的地址空间</li><li>IORESOURCE_IRQ：指定该设备使用某个中断</li><li>IORESOURCE_DMA：指定去使用某个DMA通道</li></ul></li></ul><p>一般使用IO内存映射的方式（IORESOURCE_MEM）去访问内存，去读写寄存器。</p><h6 id="注意：如果使用中断引脚或者是使用DMA通道只是用一个的话，start和end必须是相等的。"><a href="#注意：如果使用中断引脚或者是使用DMA通道只是用一个的话，start和end必须是相等的。" class="headerlink" title="注意：如果使用中断引脚或者是使用DMA通道只是用一个的话，start和end必须是相等的。"></a>注意：如果使用中断引脚或者是使用DMA通道只是用一个的话，start和end必须是相等的。</h6><h5 id="平台设备采用platform-device-结构体中的dev对象里面的platform-data-来保私有数据"><a href="#平台设备采用platform-device-结构体中的dev对象里面的platform-data-来保私有数据" class="headerlink" title="平台设备采用platform_device  结构体中的dev对象里面的platform_data  来保私有数据"></a>平台设备采用platform_device  结构体中的dev对象里面的platform_data  来保私有数据</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platform_device-&gt;device-&gt;platform_data  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static struct platform_device red_led_device = &#123;</span><br><span class="line">    .name = &quot;led_dev&quot;,/*需要和driver匹配的名字*/</span><br><span class="line">    .id = 1,</span><br><span class="line">    .num_resources = ARRAY_SIZE(red_led_resource),</span><br><span class="line">    .resource = red_led_resource,</span><br><span class="line">    .dev = &#123;</span><br><span class="line">        .release = red_led_release,</span><br><span class="line">        .platform_data = red_hard_info,/*硬件信息*/</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>平台设备提供的resource资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct resource red_led_resource[] = &#123;</span><br><span class="line">    [0] = DEFINE_RES_MEM(GPIO1_DR, 4),</span><br><span class="line">    [1] = DEFINE_RES_MEM(GPIO1_GDIR, 4),</span><br><span class="line">[2] = DEFINE_RES_MEM(IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04, 4),</span><br><span class="line">[3] = DEFINE_RES_MEM(CCM_CCGR1, 4),</span><br><span class="line">[4] = DEFINE_RES_MEM(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04, 4),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="平台设备的注册和注销"><a href="#平台设备的注册和注销" class="headerlink" title="平台设备的注册和注销"></a>平台设备的注册和注销</h4><p>我们定义和初始化platform_device  结构体后，需要将设备注册，挂载在平台设备总线上面。</p><h5 id="平台设备的注册"><a href="#平台设备的注册" class="headerlink" title="平台设备的注册"></a>平台设备的注册</h5><p>使用platform_device_register  函数将平台设备注册到平台设备总线上面去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int platform_device_register(struct platform_device *pdev)</span><br></pre></td></tr></table></figure><h5 id="平台设备的注销"><a href="#平台设备的注销" class="headerlink" title="平台设备的注销"></a>平台设备的注销</h5><p>注销挂载在设备总线上面的平台设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void platform_device_unregister(struct platform_device *pdev)  </span><br></pre></td></tr></table></figure><h3 id="平台驱动"><a href="#平台驱动" class="headerlink" title="平台驱动"></a>平台驱动</h3><h4 id="内核使用platform-driver来描述平台驱动"><a href="#内核使用platform-driver来描述平台驱动" class="headerlink" title="内核使用platform_driver来描述平台驱动"></a>内核使用platform_driver来描述平台驱动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct platform_driver &#123;</span><br><span class="line">int (*probe)(struct platform_device *);</span><br><span class="line">int (*remove)(struct platform_device *);</span><br><span class="line">void (*shutdown)(struct platform_device *);</span><br><span class="line">int (*suspend)(struct platform_device *, pm_message_t state);</span><br><span class="line">int (*resume)(struct platform_device *);</span><br><span class="line">struct device_driver driver;</span><br><span class="line">const struct platform_device_id *id_table;</span><br><span class="line">bool prevent_deferred_probe;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>probe：平台总线和设备匹配成功之后执行，一般用来对设备的一系列初始化（需自己实现）</li><li>remove：移除设备之后回调该函数。（需自己实现）</li><li>driver  ：继承device_driver对象</li><li>id_table：表示该驱动能够兼容的设备类型。  （需自己添加）</li></ul><p>填充id_table结体来支持平台总线的id_table匹配模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device_id &#123;</span><br><span class="line">char name[PLATFORM_NAME_SIZE];</span><br><span class="line">kernel_ulong_t driver_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name：支持匹配的驱动名字</li><li>driver_data：保存驱动配置（有一些是寄存器配置）</li></ul><h4 id="平台驱动的注册和注销"><a href="#平台驱动的注册和注销" class="headerlink" title="平台驱动的注册和注销"></a>平台驱动的注册和注销</h4><h5 id="平台设备的注册：注册成功后在-x2F-sys-x2F-bus-x2F-platform-x2F-driver-目录下生成一个新的目录项"><a href="#平台设备的注册：注册成功后在-x2F-sys-x2F-bus-x2F-platform-x2F-driver-目录下生成一个新的目录项" class="headerlink" title="平台设备的注册：注册成功后在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;driver 目录下生成一个新的目录项"></a>平台设备的注册：注册成功后在&#x2F;sys&#x2F;bus&#x2F;platform&#x2F;driver 目录下生成一个新的目录项</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int platform_driver_register(struct platform_driver *drv);  </span><br></pre></td></tr></table></figure><h5 id="平台设备的注销-1"><a href="#平台设备的注销-1" class="headerlink" title="平台设备的注销"></a>平台设备的注销</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void platform_driver_unregister(struct platform_driver *drv);</span><br></pre></td></tr></table></figure><h4 id="平台驱动获取设备信息（资源）"><a href="#平台驱动获取设备信息（资源）" class="headerlink" title="平台驱动获取设备信息（资源）"></a>平台驱动获取设备信息（资源）</h4><h5 id="平台驱动可以使用platform-get-resource-函数去获取设备中的resource资源数据。"><a href="#平台驱动可以使用platform-get-resource-函数去获取设备中的resource资源数据。" class="headerlink" title="平台驱动可以使用platform_get_resource()  函数去获取设备中的resource资源数据。"></a>平台驱动可以使用platform_get_resource()  函数去获取设备中的resource资源数据。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern struct resource *platform_get_resource(struct platform_device *dev,</span><br><span class="line">      unsigned int type, unsigned int num);</span><br></pre></td></tr></table></figure><ul><li>dev：指定要获取哪个平台设备的资源；  </li><li>type：指定获取资源的类型，如 IORESOURCE_MEM、 IORESOURCE_IO 等；  </li><li>num：指定要获取的资源编号。每个设备所需要资源的个数是不一定的，为此内核对这些<br>资源进行了编号，对于不同的资源，编号之间是相互独立的。</li></ul><p>平台驱动获取资源（和上面平台设备提供资源相对应）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">platform_get_resource(pdev,IORESOURCE_MEM,0);</span><br><span class="line">platform_get_resource(pdev,IORESOURCE_MEM,1);</span><br><span class="line">platform_get_resource(pdev,IORESOURCE_MEM,2);</span><br><span class="line">platform_get_resource(pdev,IORESOURCE_MEM,3);</span><br><span class="line">platform_get_resource(pdev,IORESOURCE_MEM,4);</span><br></pre></td></tr></table></figure><h5 id="平台设备获取irq设备资源（获取中断引脚）"><a href="#平台设备获取irq设备资源（获取中断引脚）" class="headerlink" title="平台设备获取irq设备资源（获取中断引脚）"></a>平台设备获取irq设备资源（获取中断引脚）</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int platform_get_irq(struct platform_device *pdev, unsigned int num)</span><br></pre></td></tr></table></figure><ul><li>dev：指定要获取哪个平台设备的资源；  </li><li>num： 指定要获取的资源编号。</li></ul><h5 id="平台设备获取私密资源（信息）"><a href="#平台设备获取私密资源（信息）" class="headerlink" title="平台设备获取私密资源（信息）"></a>平台设备获取私密资源（信息）</h5><p>获取platform_device-&gt;device-&gt;platform_data  保存的私有文件信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static inline void *dev_get_platdata(const struct device *dev)</span><br><span class="line">&#123;</span><br><span class="line">return dev-&gt;platform_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>dev： struct device 结构体类型指针</li></ul><h3 id="创建平台设备步骤"><a href="#创建平台设备步骤" class="headerlink" title="创建平台设备步骤"></a>创建平台设备步骤</h3><h4 id="1、定义填充platform-device结构体"><a href="#1、定义填充platform-device结构体" class="headerlink" title="1、定义填充platform_device结构体"></a>1、定义填充platform_device结构体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static struct platform_device red_led_device = &#123;</span><br><span class="line">    .name = &quot;led_dev&quot;,/*需要和driver匹配的名字*/</span><br><span class="line">    .id = 1,</span><br><span class="line">    .num_resources = ARRAY_SIZE(red_led_resource),</span><br><span class="line">    .resource = red_led_resource,</span><br><span class="line">    .dev = &#123;</span><br><span class="line">        .release = red_led_release,</span><br><span class="line">        .platform_data = red_hard_info,/*硬件信息*/</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、添加自定义resource资源结构体（以下示例）"><a href="#2、添加自定义resource资源结构体（以下示例）" class="headerlink" title="2、添加自定义resource资源结构体（以下示例）"></a>2、添加自定义resource资源结构体（以下示例）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct resource red_led_resource[] = &#123;</span><br><span class="line">    [0] = DEFINE_RES_MEM(GPIO1_DR, 4),</span><br><span class="line">    [1] = DEFINE_RES_MEM(GPIO1_GDIR, 4),</span><br><span class="line">[2] = DEFINE_RES_MEM(IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04, 4),</span><br><span class="line">[3] = DEFINE_RES_MEM(CCM_CCGR1, 4),</span><br><span class="line">[4] = DEFINE_RES_MEM(IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04, 4),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、实现dev-release回调函数，和添加platform-data私密信息"><a href="#3、实现dev-release回调函数，和添加platform-data私密信息" class="headerlink" title="3、实现dev.release回调函数，和添加platform_data私密信息"></a>3、实现dev.release回调函数，和添加platform_data私密信息</h4><h4 id="4、调用platform-device-register函数注册添加平台设备"><a href="#4、调用platform-device-register函数注册添加平台设备" class="headerlink" title="4、调用platform_device_register函数注册添加平台设备"></a>4、调用platform_device_register函数注册添加平台设备</h4><h3 id="创建平台驱动步骤"><a href="#创建平台驱动步骤" class="headerlink" title="创建平台驱动步骤"></a>创建平台驱动步骤</h3><h4 id="1、定义填充platform-driver结构体"><a href="#1、定义填充platform-driver结构体" class="headerlink" title="1、定义填充platform_driver结构体"></a>1、定义填充platform_driver结构体</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct platform_driver red_led_driver = &#123;</span><br><span class="line">    .driver.name = &quot;led_dev&quot;,</span><br><span class="line">    .remove = led_pdrv_remove,</span><br><span class="line">    .probe = led_pdrv_probe,</span><br><span class="line">    .id_table = led_id_table,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、实现remove，probe等回调函数"><a href="#2、实现remove，probe等回调函数" class="headerlink" title="2、实现remove，probe等回调函数"></a>2、实现remove，probe等回调函数</h4><h4 id="3、添加id-table匹配方式"><a href="#3、添加id-table匹配方式" class="headerlink" title="3、添加id_table匹配方式"></a>3、添加id_table匹配方式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct platform_device_id led_id_table[] = &#123;</span><br><span class="line">    &#123;.name = &quot;led_dev&quot;&#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、调用probe函数中初始化平台设备的时候去获取平台资源，并将资源保存到平台驱动结构体中。"><a href="#4、调用probe函数中初始化平台设备的时候去获取平台资源，并将资源保存到平台驱动结构体中。" class="headerlink" title="4、调用probe函数中初始化平台设备的时候去获取平台资源，并将资源保存到平台驱动结构体中。"></a>4、调用probe函数中初始化平台设备的时候去获取平台资源，并将资源保存到平台驱动结构体中。</h4><ul><li>使用dev_get_platdata获取私密数据</li><li>使用platform_get_resource去获取resource数据</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static int probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">dev_get_platdata(&amp;pdev-&gt;dev);</span><br><span class="line">platform_get_resource(pdev,IORESOURCE_MEM,0);</span><br><span class="line">latform_get_resource(pdev,IORESOURCE_MEM,1);</span><br><span class="line"></span><br><span class="line">platform_set_drvdata(pdev, cur_led);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用devm_ioremap去将寄存器地址转化为虚拟地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devm_ioremap(&amp;pdev-&gt;dev, mem_dr-&gt;start, resource_size(mem_dr));</span><br></pre></td></tr></table></figure><h4 id="5、调用platform-driver-register函数去注册添加驱动到平台总线上面"><a href="#5、调用platform-driver-register函数去注册添加驱动到平台总线上面" class="headerlink" title="5、调用platform_driver_register函数去注册添加驱动到平台总线上面"></a>5、调用platform_driver_register函数去注册添加驱动到平台总线上面</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;平台设备驱动&quot;&gt;&lt;a href=&quot;#平台设备驱动&quot; class=&quot;headerlink&quot; title=&quot;平台设备驱动&quot;&gt;&lt;/a&gt;平台设备驱动&lt;/h2&gt;&lt;p&gt;平台总线-Linux内核引进的一种虚拟总线（platfrom bus）&lt;/p&gt;
&lt;h3 id=&quot;平台总线&quot;&gt;</summary>
      
    
    
    
    
    <category term="Linux设备驱动" scheme="http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux设备模型</title>
    <link href="http://example.com/2022/11/23/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2022/11/23/Linux%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-11-23T12:31:45.000Z</published>
    <updated>2023-09-13T01:49:59.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-设备模型"><a href="#Linux-设备模型" class="headerlink" title="Linux 设备模型"></a>Linux 设备模型</h2><h3 id="设备模型概念"><a href="#设备模型概念" class="headerlink" title="设备模型概念"></a>设备模型概念</h3><ul><li>device（设备）：挂载在某个的物理设备</li><li>dirver（驱动）：初始化物理设备和提供一些操作方式</li><li>bus（总线）：管理挂载在bus上面的设备和驱动</li><li>class （类）：管理相同功能的设备类别，进行统一管理</li></ul><p>sys&#x2F;bus 目录下保存的是注册了的总线类型</p><p>devices目录下保存的是挂载在该总线上面的所有设备</p><p>driver目录下保存的是挂载在总线上面的所有驱动</p><p>sys&#x2F;class 目录下保存了在所有注册在kernel里面的设备类型</p><h3 id="总线（bus）"><a href="#总线（bus）" class="headerlink" title="总线（bus）"></a>总线（bus）</h3><p>总线驱动则负责实现总线的各种行为，其管理着两个链表，分别是添加到该总线的设备链表以及 注册到该总线的驱动链表。当你向总线添加（移除）一个设备（驱动）时，便会在对应的列表上 添加新的节点，同时对挂载在该总线的驱动以及设备进行匹配，在匹配过程中会忽略掉那些已经 有驱动匹配的设备。  </p><h4 id="bus-type：用来描述总线"><a href="#bus-type：用来描述总线" class="headerlink" title="bus_type：用来描述总线"></a>bus_type：用来描述总线</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    const struct attribute_group **bus_groups;</span><br><span class="line">    const struct attribute_group **dev_groups;</span><br><span class="line">    const struct attribute_group **drv_groups;</span><br><span class="line">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    int (*probe)(struct device *dev);</span><br><span class="line">    int (*remove)(struct device *dev);</span><br><span class="line">    ...</span><br><span class="line">    struct subsys_private *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name :  指定总线的名称，当新注册一种总线类型时，会在&#x2F;sys&#x2F;bus 目录创建一个新的目录， 目录名就是该参数的值。</li><li>bus_groups，dev_groups，drv_groups：分别表示驱动、设备以及总线的属性。  </li><li>match：总线用来匹配新注册的设备或者是新的驱动。</li><li>uevent：总线上面发生添加或移除，就会调用该回调函数。</li><li>probe：总线上面的驱动和设备匹配成功之后，执行该回调函数。</li><li>remove：设备从总线上面移除是回调该处理函数。</li><li>p：用来存放私有数据。</li></ul><h4 id="bus总线注册和注销"><a href="#bus总线注册和注销" class="headerlink" title="bus总线注册和注销"></a>bus总线注册和注销</h4><p>1、bus总线注册：注册成功后会在&#x2F;sys&#x2F;bus&#x2F; 目录下面生成 xxx 文件 &#x2F;sys&#x2F;bus&#x2F;xxx。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bus_register(struct bus_type *bus);  </span><br></pre></td></tr></table></figure><p>2、bus总线注销：注销bus总线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void bus_unregister(struct bus_type *bus);</span><br></pre></td></tr></table></figure><h3 id="设备（device）"><a href="#设备（device）" class="headerlink" title="设备（device）"></a>设备（device）</h3><h4 id="device结构体描述物理设备"><a href="#device结构体描述物理设备" class="headerlink" title="device结构体描述物理设备"></a>device结构体描述物理设备</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct device &#123;  </span><br><span class="line">    const char *init_name;</span><br><span class="line">    struct device *parent;</span><br><span class="line">    struct bus_type *bus;</span><br><span class="line">    struct device_driver *driver;</span><br><span class="line">    void *platform_data;</span><br><span class="line">    void *driver_data;</span><br><span class="line">    struct device_node *of_node;</span><br><span class="line">    dev_t devt;</span><br><span class="line">    struct class *class;</span><br><span class="line">    void (*release)(struct device *dev);</span><br><span class="line">    const struct attribute_group **groups;</span><br><span class="line">    struct device_private *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name ：device（设备）名称</li><li>parent：该设备的父对象（在哪一个目录下面挂载）</li><li>bus：挂载在哪一个总线</li><li>of_node：存放设备树中匹配节点</li><li>platform_data：特定设备的私有数据</li><li>driver_data：驱动的私有数据</li><li>class：指向了该设备对应类  </li><li>devt：标识设备设备号</li><li>release：设备被注销时，调用该函数</li><li>groups：设备属性组（设备的属性文件）</li></ul><h4 id="设备-device-的注册和注销"><a href="#设备-device-的注册和注销" class="headerlink" title="设备(device)的注册和注销"></a>设备(device)的注册和注销</h4><p>1、设备的注册：注册成功时会在该设备注册的总线目录下创建设备</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int device_register(struct device *dev);  </span><br></pre></td></tr></table></figure><p>2、设备的注销</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void device_unregister(struct device *dev);</span><br></pre></td></tr></table></figure><h3 id="driver（驱动）"><a href="#driver（驱动）" class="headerlink" title="driver（驱动）"></a>driver（驱动）</h3><p>使用device_driver结构体来描述驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct device_driver &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    struct bus_type *bus;</span><br><span class="line">    struct module *owner;</span><br><span class="line">    const char *mod_name;</span><br><span class="line">    const struct of_device_id</span><br><span class="line">    int (*probe) (struct device *dev);</span><br><span class="line">    int (*remove) (struct device *dev);</span><br><span class="line">    ...</span><br><span class="line">    const struct attribute_group **groups;</span><br><span class="line">    struct driver_private *p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>name：driver（驱动）名称</li><li>bus：驱动依赖于哪个总线  </li><li>owner：该驱动的拥有者  ，一般设置为 THIS_MODULE  </li><li>of_device_id：指定该驱动支持的设备类型  </li><li>probe：驱动与设备匹配成功之后，执行该回调函数</li><li>remove：设备从操作系统中拔出，或者系统重启，会执行该回调函数</li><li>groups：驱动属性文件组</li></ul><h4 id="驱动（driver）的注册和注销"><a href="#驱动（driver）的注册和注销" class="headerlink" title="驱动（driver）的注册和注销"></a>驱动（driver）的注册和注销</h4><p>1、驱动的注册：驱动注册成功之后会在该总线下面创建driver文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int driver_register(struct device_driver *drv);</span><br></pre></td></tr></table></figure><p>2、驱动的注销</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void driver_unregister(struct device_driver *drv);</span><br></pre></td></tr></table></figure><h3 id="属性文件"><a href="#属性文件" class="headerlink" title="属性文件"></a>属性文件</h3><h4 id="attribute属性文件"><a href="#attribute属性文件" class="headerlink" title="attribute属性文件"></a>attribute属性文件</h4><p>1、属性文件：attribute 结构体来描述&#x2F;sys 目录下的文件  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct attribute &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    umode_t mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>name : 指定文件的文件名；</li><li>mode : 指定文件的权限，</li></ul><p>2、属性文件组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct attribute_group &#123;</span><br><span class="line">    const char *name;</span><br><span class="line">    struct attribute **attrs;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h4 id="设备属性文件"><a href="#设备属性文件" class="headerlink" title="设备属性文件"></a>设备属性文件</h4><p>设备属性文件接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct device_attribute &#123;</span><br><span class="line">    struct attribute attr;</span><br><span class="line">    ssize_t (*show)(struct device *dev, struct device_attribute *attr,char *buf);</span><br><span class="line">    ssize_t (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">    const char *buf, size_t count);</span><br></pre></td></tr></table></figure><ul><li>attr：设备属性文件</li><li>show：属性文件接口，是cat命令的回调函数接口</li><li>store：属性文件接口，是echo命令的回调接口</li></ul><p>设备文件的创建：在挂载总线目录下面创建device文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int device_create_file(struct device *device,</span><br><span class="line">    const struct device_attribute *entry);</span><br></pre></td></tr></table></figure><p>设备文件的注销：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void de vice_remove_file(struct device *dev,  </span><br></pre></td></tr></table></figure><p>device是需要填充好的设备结构体，entry是自己定义的设备属性文件。</p><p>定义和填充device_attribute类型的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define DEVICE_ATTR(_name, _mode, _show, _store)\</span><br><span class="line">struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span><br></pre></td></tr></table></figure><ul><li>_name：设备结构体的文件名</li><li>_mode：文件权限（rwx）</li><li>_show：cat回调函数实现</li><li>_store：echo回调函数实现</li></ul><h4 id="驱动属性文件"><a href="#驱动属性文件" class="headerlink" title="驱动属性文件"></a>驱动属性文件</h4><p>驱动属性文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct driver_attribute &#123;</span><br><span class="line">    struct attribute attr;</span><br><span class="line">    ssize_t (*show)(struct device_driver *driver, char *buf);</span><br><span class="line">    ssize_t (*store)(struct device_driver *driver, const char *buf,size_t count);</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>结构体成员同上面设备文件结构体一样。</p><p>驱动文件的创建：在挂载总线目录下面创建driver文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int __must_check driver_create_file(struct device_driver *driver,</span><br><span class="line">    const struct driver_attribute *attr);</span><br></pre></td></tr></table></figure><p>驱动文件的注销：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern void driver_remove_file(struct device_driver *driver,</span><br><span class="line">    const struct driver_attribute *attr);</span><br></pre></td></tr></table></figure><p>driver是需要填充好的驱动结构体，attr是自己定义的驱动属性文件。</p><p>device是需要填充好的驱动结构体，attr是自己定义的设备属性文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define DRIVER_ATTR_RW(_name) \</span><br><span class="line">struct driver_attribute driver_attr_##_name = __ATTR_RW(_name)</span><br></pre></td></tr></table></figure><p>同上面设备结构体一样。</p><h4 id="BUS总线属性文件"><a href="#BUS总线属性文件" class="headerlink" title="BUS总线属性文件"></a>BUS总线属性文件</h4><p>bus总线结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct bus_attribute &#123;</span><br><span class="line">    struct attribute attr;</span><br><span class="line">    ssize_t (*show)(struct device_driver *driver, char *buf);</span><br><span class="line">    ssize_t (*store)(struct device_driver *driver, const char *buf,size_t count);</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>结构体成员同上面设备文件结构体一样。</p><p>bus总线的注册：在&#x2F;sys&#x2F;bus目录下面创建文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern int __must_check bus_create_file(struct bus_type *,</span><br><span class="line">struct bus_attribute *);</span><br></pre></td></tr></table></figure><p>bus总线的注销：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern void bus_remove_file(struct bus_type *, struct bus_attribute *);</span><br></pre></td></tr></table></figure><p>创建bus结构体和填充该结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define BUS_ATTR(_name, _mode, _show, _store) \</span><br><span class="line">struct bus_attribute bus_attr_##_name = __ATTR(_name, _mode, _show,_store)</span><br></pre></td></tr></table></figure><h3 id="创建BUS，device，driver文件"><a href="#创建BUS，device，driver文件" class="headerlink" title="创建BUS，device，driver文件"></a>创建BUS，device，driver文件</h3><h4 id="bus总线的创建步骤："><a href="#bus总线的创建步骤：" class="headerlink" title="bus总线的创建步骤："></a>bus总线的创建步骤：</h4><p>bus_type类型结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct bus_type &#123;</span><br><span class="line">    const char      *name;</span><br><span class="line">    const char      *dev_name;</span><br><span class="line">    struct device       *dev_root;</span><br><span class="line">    const struct attribute_group **bus_groups;</span><br><span class="line">    const struct attribute_group **dev_groups;</span><br><span class="line">    const struct attribute_group **drv_groups;</span><br><span class="line"></span><br><span class="line">    int (*match)(struct device *dev, struct device_driver *drv);</span><br><span class="line">    int (*uevent)(struct device *dev, struct kobj_uevent_env *env);</span><br><span class="line">    int (*probe)(struct device *dev);</span><br><span class="line">    int (*remove)(struct device *dev);</span><br><span class="line">    void (*shutdown)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    int (*online)(struct device *dev);</span><br><span class="line">    int (*offline)(struct device *dev);</span><br><span class="line"></span><br><span class="line">    int (*suspend)(struct device *dev, pm_message_t state);</span><br><span class="line">    int (*resume)(struct device *dev);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>1、主要实现match匹配函数的回调函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int (*match)(struct device *dev, struct device_driver *drv);</span><br></pre></td></tr></table></figure><p>2、填充bus_type结构体的name,match等成员（用于总线注册），并将总线导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct bus_type xbus = &#123;</span><br><span class="line">.name = &quot;xbus&quot;,</span><br><span class="line">.match = xbus_match,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(xbus);</span><br></pre></td></tr></table></figure><p>3、实现属性文件的store,show的回调函数实现，并且创建填充bus_attribute结构体，并且导出到用户空间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssize_t (*show)(struct bus_type *bus, char *buf);</span><br><span class="line">ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);</span><br><span class="line"></span><br><span class="line">BUS_ATTR(xbus_test, S_IRUSR, show, store);</span><br></pre></td></tr></table></figure><p>4、使用bus_register注册总线和使用bus_create_file创建总线文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bus_register(&amp;xbus);</span><br><span class="line">bus_create_file(&amp;xbus, &amp;bus_attr_xbus_test);</span><br></pre></td></tr></table></figure><h4 id="设备文件的创建步骤："><a href="#设备文件的创建步骤：" class="headerlink" title="设备文件的创建步骤："></a>设备文件的创建步骤：</h4><p>创建成功后会在&#x2F;sys&#x2F;bus&#x2F;xbus&#x2F;devices&#x2F;目录下创建xdev设备文件</p><p>1、release回调函数的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void    (*release)(struct device *dev);</span><br></pre></td></tr></table></figure><p>2、定义设备，并且填充结构体成员，挂载在（xbus）某个总线上面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern struct bus_type xbus;</span><br><span class="line"></span><br><span class="line">static struct device xdev = &#123;</span><br><span class="line">    .init_name = &quot;xdev&quot;, /*device file name*/</span><br><span class="line">    .bus = &amp;xbus, /*xdev belong to xbus*/</span><br><span class="line">    .release = xdevice_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、定义设备属性（device_attribute），实现show,store属性回调函数，并填充到结构体</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssize_t (*show)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">            char *buf);</span><br><span class="line">ssize_t (*store)(struct device *dev, struct device_attribute *attr,</span><br><span class="line">             const char *buf, size_t count);</span><br><span class="line">DEVICE_ATTR(xdev_id, S_IRUSR|S_IWUSR, show, store);</span><br></pre></td></tr></table></figure><p>4、使用device_rigister和device_create_file将设备结构体和属性文件注册到内核。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">device_register(&amp;xdev);</span><br><span class="line">device_create_file(&amp;xdev, &amp;dev_attr_xdev_id);</span><br></pre></td></tr></table></figure><h4 id="驱动属性文件的创建"><a href="#驱动属性文件的创建" class="headerlink" title="驱动属性文件的创建"></a>驱动属性文件的创建</h4><p>创建成功后会在&#x2F;sys&#x2F;bus&#x2F;xbus&#x2F;driver&#x2F;目录下创建xdev驱动文件</p><p>1、实现probe和remove函数的回调</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int (*probe) (struct device *dev);</span><br><span class="line">int (*remove) (struct device *dev);</span><br></pre></td></tr></table></figure><p>2、创建xdriver对象，并且为xdriver对象填充数据。并且初始化挂载在那个总线上面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static struct device_driver xdriver = &#123;</span><br><span class="line">    .name = &quot;xdev&quot;,</span><br><span class="line">    .probe = probe,</span><br><span class="line">    .bus = &amp;xbus,</span><br><span class="line">    .remove = remove,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、创建属性文件对象，并且实现show,store回调函数，和填充对象数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssize_t (*show)(struct device_driver *driver, char *buf);</span><br><span class="line">ssize_t (*store)(struct device_driver *driver, const char *buf, size_t count);</span><br><span class="line"></span><br><span class="line">DEVICE_ATTR(xdev,S_IRUSR|S_IWUSR,show,store);</span><br></pre></td></tr></table></figure><p>4、驱动的注册（driver_register  ）和属性文件的注册（driver_create_file  ）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver_register(&amp;xdrv);</span><br><span class="line">driver_create_file(&amp;xdriver, &amp;driver_attr_drvname);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux-设备模型&quot;&gt;&lt;a href=&quot;#Linux-设备模型&quot; class=&quot;headerlink&quot; title=&quot;Linux 设备模型&quot;&gt;&lt;/a&gt;Linux 设备模型&lt;/h2&gt;&lt;h3 id=&quot;设备模型概念&quot;&gt;&lt;a href=&quot;#设备模型概念&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="Linux设备驱动" scheme="http://example.com/tags/Linux%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-共享内存</title>
    <link href="http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/"/>
    <id>http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</id>
    <published>2022-10-28T13:34:34.000Z</published>
    <updated>2023-09-13T01:49:59.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用开发-共享内存"><a href="#Linux应用开发-共享内存" class="headerlink" title="Linux应用开发-共享内存"></a>Linux应用开发-共享内存</h2><h4 id="共享内存的概念"><a href="#共享内存的概念" class="headerlink" title="共享内存的概念"></a>共享内存的概念</h4><h5 id="共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。"><a href="#共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。" class="headerlink" title="共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。"></a>共享内存是将多个进程的虚拟地址映射到一块物理地址上面，让互不通信的进程之间进行通信。</h5><p><img src="/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/image-20221028214119485.png" alt="image-20221028214119485"></p><p>1、共享内存由以下特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 共享内存是进程间通信中效率最高的方式之一。</span><br><span class="line">- 共享内存是系统出于多个进程之间通讯的考虑，而预留的的一块内存区，因此共享内存是以传输数据为目的的。</span><br><span class="line">- 共享内存允许两个或更多进程访问同一块内存，当一个进程改变了这块地址中的内容的时候，其它进程都会察觉到这个更改。</span><br><span class="line">- 共享内存无同步无互斥。</span><br></pre></td></tr></table></figure><p>2、共享内存的优缺点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 优点：使用共享内存进行进程间的通信非常方便，而且函数的接口也简单，数据的共享使</span><br><span class="line">进程间的数据不用传送，而是直接访问内存，加快了程序的效率。任意进程之间都可以对共享内存做读写操作。</span><br><span class="line">- 缺点：共享内存没有提供同步的机制，这使得我们在使用共享内存进行进程间通信时，往</span><br><span class="line">往要借助其他的手段（如信号量、互斥量等）来进行进程间的同步工作。</span><br></pre></td></tr></table></figure><h4 id="共享内存API函数"><a href="#共享内存API函数" class="headerlink" title="共享内存API函数"></a>共享内存API函数</h4><h5 id="创建共享内存函数"><a href="#创建共享内存函数" class="headerlink" title="创建共享内存函数"></a>创建共享内存函数</h5><p>shmget() 函数的创建或获取一个共享内存对象，并返回共享内存标识符。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">int shmget(key_t key, size_t size, int shmflg);</span><br><span class="line">- key：标识共享内存的键值</span><br><span class="line">- size：共享内存大小，所有的内存分配操作都是以页为单位的，所以即使只申请只有一个字节的内存，内存也会分配整整一页。</span><br><span class="line">- shmflg：创建的共享内存的模式标志参数</span><br><span class="line">* IPC_CREAT：如果内核中不存在关键字与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符。</span><br><span class="line">* IPC_EXCL：如果内核中不存在键值与 key 相等的共享内存，则新建一个共享内存；如果存在这样的共享内存则报错。</span><br><span class="line">* SHM_HUGETLB：使用“大页面”来分配共享内存，所谓的“大页面”指的是内核为了提高程序性能，对内存实行分页管理时，采用比默认尺寸（4KB）更大的分页，以减少缺页中断。</span><br><span class="line">* SHM_NORESERVE：不在交换分区中为这块共享内存保留空间。</span><br><span class="line">返回值： shmget() 函数的返回值是共享内存的 ID。创建失败返回-1。</span><br><span class="line">错误代码：</span><br><span class="line">- EACCES：指定的消息队列已存在，但调用进程没有权限访问它</span><br><span class="line">- EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL 标志</span><br><span class="line">- EINVAL：创建共享内存时参数 size 小于 SHMMIN 或大于 SHMMAX。</span><br><span class="line">- ENFILE：已达到系统范围内打开文件总数的限制。</span><br><span class="line">- ENOENT：给定的 key 不存在任何共享内存，并且未指定 IPC_CREAT。</span><br><span class="line">- ENOMEM：内存不足，无法为共享内存分配内存。</span><br><span class="line">- EACCES：没有权限。</span><br></pre></td></tr></table></figure><h5 id="内存映射函数"><a href="#内存映射函数" class="headerlink" title="内存映射函数"></a>内存映射函数</h5><p>shmat() 映射函数  ，共享内存区对象映射到调用进程的地址空间  。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void *shmat(int shmid, const void *shmaddr, int shmflg);</span><br><span class="line">- shmid：共享内存 ID，通常是由 shmget() 函数返回的。</span><br><span class="line">- shmaddr：如果不为 NULL，则系统会根据 shmaddr 来选择一个合适的内存区域，如果为NULL，则系统会自动选择一个合适的虚拟内存空间地址去映射共享内存。</span><br><span class="line">- shmflg：操作共享内存的方式：</span><br><span class="line">* 0：可读可写</span><br><span class="line">    * SHM_RDONLY：以只读方式映射共享内存。</span><br><span class="line">    * SHM_REMAP：重新映射，此时 shmaddr 不能为 NULL。</span><br><span class="line">    * NULLSHM：自动选择比 shmaddr 小的最大页对齐地址。</span><br><span class="line">shmat() 函数调用成功后返回共享内存的起始地址。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">- 共享内存只能以只读或者可读写方式映射，无法以只写方式映射。</span><br><span class="line">- shmat() 第二个参数 shmaddr 一般都设为 NULL，让系统自动找寻合适的地址。但当其确实</span><br><span class="line">不为空时，那么要求 SHM_RND 在 shmflg 必须被设置，这样的话系统将会选择比 shmaddr</span><br><span class="line">小而又最大的页对齐地址（即为 SHMLBA 的整数倍）作为共享内存区域的起始地址。如果</span><br><span class="line">没有设置 SHM_RND，那么 shmaddr 必须是严格的页对齐地址。</span><br></pre></td></tr></table></figure><h5 id="解除内存映射函数"><a href="#解除内存映射函数" class="headerlink" title="解除内存映射函数"></a>解除内存映射函数</h5><p>shmdt() 函数是用来解除进程与共享内存之间的映射的，在解除映射后，该进程不能再访问这个共享内存  。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int shmdt(const void *shmaddr);</span><br><span class="line">- shmaddr：映射的共享内存的起始地址。</span><br><span class="line"></span><br><span class="line">注意：该函数并不删除所指定的共享内存区，而只是将先前用 shmat() 函数映射好的共享内存脱离当前进程，共享内存还是存在于物理内存中。</span><br></pre></td></tr></table></figure><h5 id="获取或设置属性函数"><a href="#获取或设置属性函数" class="headerlink" title="获取或设置属性函数"></a>获取或设置属性函数</h5><p>shmctl() 用于获取或者设置共享内存的相关属性。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int shmctl(int shmid, int cmd, struct shmid_ds *buf);</span><br><span class="line">- shmid：共享内存标识符。</span><br><span class="line">- cmd：函数功能的控制命令，其取值如下：</span><br><span class="line">    * IPC_STAT：获取属性信息，放置到 buf 中。</span><br><span class="line">    * IPC_SET：设置属性信息为 buf 指向的内容。</span><br><span class="line">    * IPC_RMID：删除这该共享内存。</span><br><span class="line">    * IPC_INFO：获得关于共享内存的系统限制值信息。</span><br><span class="line">    * SHM_INFO：获得系统为共享内存消耗的资源信息。</span><br><span class="line">    * SHM_STAT：与 IPC_STAT 具有相同的功能，但 shmid 为该 SHM 在内核中记录所有SHM 信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有 SHM 的相关信息。</span><br><span class="line">    * SHM_LOCK：禁止系统将该 SHM 交换至 swap 分区。</span><br><span class="line">    * SHM_UNLOCK：允许系统将该 SHM 交换至 swap 分。</span><br><span class="line">- 共享内存属性信息结构体指针（属性缓冲区）一般设为NULL</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用开发-共享内存&quot;&gt;&lt;a href=&quot;#Linux应用开发-共享内存&quot; class=&quot;headerlink&quot; title=&quot;Linux应用开发-共享内存&quot;&gt;&lt;/a&gt;Linux应用开发-共享内存&lt;/h2&gt;&lt;h4 id=&quot;共享内存的概念&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-IPC信号量</title>
    <link href="http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-IPC%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    <id>http://example.com/2022/10/28/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-IPC%E4%BF%A1%E5%8F%B7%E9%87%8F/</id>
    <published>2022-10-28T12:30:16.000Z</published>
    <updated>2023-09-13T01:49:59.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-信号量"><a href="#Linux应用编程-信号量" class="headerlink" title="Linux应用编程-信号量"></a>Linux应用编程-信号量</h2><h4 id="信号量的工作原理"><a href="#信号量的工作原理" class="headerlink" title="信号量的工作原理"></a>信号量的工作原理</h4><h5 id="信号量的PV操作"><a href="#信号量的PV操作" class="headerlink" title="信号量的PV操作"></a>信号量的PV操作</h5><p>信号量只能进行两种操作：等待和发送信号，即 P 操作和 V 操作，锁行为就是 P 操作，解锁就是 V 操作，可以直接理解为 P 操作是申请资源， V 操作是释放资源。   </p><p>ipcs -l  查看ipc信息</p><p>信号量的P操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P 操作：如果有可用的资源（信号量值大于 0），则占用一个资源（给信号量值减去一，进</span><br><span class="line">入临界区代码） ; 如果没有可用的资源（信号量值等于 0），则阻塞，直到系统将资源分配</span><br><span class="line">给该进程（进入等待队列，一直等到资源轮到该进程）。</span><br></pre></td></tr></table></figure><p>信号量的V操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">V 操作：如果在该信号量的等待队列中有进程在等待资源，则唤醒一个阻塞的进程。如果</span><br><span class="line">没有进程等待它，则释放一个资源（给信号量值加一）。</span><br></pre></td></tr></table></figure><p>在信号量进行 PV 操作时都为原子操作（因为它需要保护临界资源）。  </p><p>原子操作：单指令的操作称为原子的，单条指令的执行是不会被打断的  </p><h4 id="IPC信号量函数"><a href="#IPC信号量函数" class="headerlink" title="IPC信号量函数"></a>IPC信号量函数</h4><h5 id="创建或获取一个信号量"><a href="#创建或获取一个信号量" class="headerlink" title="创建或获取一个信号量"></a>创建或获取一个信号量</h5><p>semget 函数的功能是创建或者获取一个已经创建的信号量，如果成功则返回对应的信号量标识符，失败则返回-1。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int semget(key_t key, int nsems, int semflg);</span><br><span class="line">- key：参数 key 用来标识系统内的信号量可以使用ftok函数创建或者是类似（key_t）123</span><br><span class="line">- nsems：参数用于在创建信号量的时候，表示可用的信号量数目。</span><br><span class="line">- semflg：参数用来指定标志位</span><br><span class="line">* PC_CREAT：IPC_CREAT 标志创建新的信号量，即使该信号量已经存在（具有同一个键值的信号量已在系统中存在），也不会出错。</span><br><span class="line">* IPC_EXCL：同时使用 IPC_EXCL 标志可以创建一个新的唯一的信号量，此时如果该信号量已经存在，该函数会返回出错。</span><br><span class="line">* mode：创建文件模式 0666</span><br><span class="line"></span><br><span class="line">创建信号量时，还受到以下系统信息的影响:</span><br><span class="line">• SEMMNI：系统中信号量总数的最大值。</span><br><span class="line">• SEMMSL：每个信号量中信号量元素个数的最大值。</span><br><span class="line">• SEMMNS：系统中所有信号量中的信号量元素总数的最大值。</span><br></pre></td></tr></table></figure><h4 id="信号量PV操作"><a href="#信号量PV操作" class="headerlink" title="信号量PV操作"></a>信号量PV操作</h4><h5 id="信号量的PV操作-1"><a href="#信号量的PV操作-1" class="headerlink" title="信号量的PV操作"></a>信号量的PV操作</h5><p>semop() 函数对信号量进行 PV 操作 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int semop(int semid, struct sembuf *sops, size_t nsops);</span><br><span class="line">- semid： System V 信号量的标识符，用来标识一个信号量</span><br><span class="line">- sops：指向一个 struct sembuf 结构体数组的指针，该数组是一个信号量操作数组</span><br><span class="line">struct sembuf</span><br><span class="line">    &#123;</span><br><span class="line">        unsigned short int sem_num; /* 信号量的序号从 0 ~ nsems-1 */</span><br><span class="line">        short int sem_op; /* 对信号量的操作， &gt;0, 0, &lt;0 */</span><br><span class="line">        short int sem_flg; /* 操作标识： 0， IPC_WAIT, SEM_UNDO */</span><br><span class="line">    &#125;;</span><br><span class="line">    * set_num：用于标识信号量中的第几个信号量， 0 表示第 1 个， 1 表示第 2 个， nsems -1表示最后一个。</span><br><span class="line">    * sem_op：sem_op 标识对信号量的所进行的操作类型</span><br><span class="line">    ~ sem_op &gt; 0 表示进程未使用或者使用完毕交回资源，表示信号量V(释放操作)，sem_op 的值加到该信号量的信号量当前值 semval</span><br><span class="line">    ~ sem_op &lt; 0 表示进程需要使用资源，表示信号量P操作（获取资源），当信号量当前值 semval 大于或者等于 -sem_op 时， semval 减掉 sem_op 的绝对值，为该进程分配对应数目的资源。</span><br><span class="line">    ~ sem_op = 0 表示进程要阻塞等待，直至信号量当前值 semval 变为 0</span><br><span class="line">    * sem_flg，信号量操作的属性标志</span><br><span class="line">        ~ IPC_NOWAIT 使对信号量的操作是非阻塞的，即指定了该标志，调用进程在信号量的值不满足条件的情况下不会被阻塞，而是直接返回-1，并将 errno 设置为 EAGAIN。</span><br><span class="line">        ~ SEM_UNDO 维护进程对信号量的调整值，进程退出的时候会自动还原它对信号量的操作</span><br><span class="line">        ~ 0 表示正常操作</span><br><span class="line">- nsops：表示上面 sops 数组的数量，如只有一个 sops 数组， nsops 就设置为 1</span><br></pre></td></tr></table></figure><h5 id="semctl属性函数"><a href="#semctl属性函数" class="headerlink" title="semctl属性函数"></a>semctl属性函数</h5><p>semctl 函数主要是对信号量集的一系列控制操作，根据操作命令 cmd 的不同，执行不同的操作，<br>第四个参数是可选的。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int semctl(int semid, int semnum, int cmd, ...);</span><br><span class="line">- semid： System V 信号量的标识符；</span><br><span class="line">- semnum：表示信号量集中的第 semnum 个信号量。它的取值范围： 0 ~ nsems-1 。</span><br><span class="line">- cmd：操作命令，主要有以下命令：</span><br><span class="line">    * IPC_STAT：获取此信号量集合的 semid_ds 结构，存放在第四个参数的 buf 中。</span><br><span class="line">    * IPC_SET：通过第四个参数的 buf 来设定信号量集相关联的 semid_ds 中信号量集合权限为 sem_perm 中的 uid， gid， mode。</span><br><span class="line">    * IPC_RMID：从系统中删除该信号量集合。</span><br><span class="line">    * GETVAL：返回第 semnum 个信号量的值。</span><br><span class="line">    * SETVAL：设置第 semnum 个信号量的值，该值由第四个参数中的 val 指定。</span><br><span class="line">    * GETPID：返回第 semnum 个信号量的 sempid，最后一个操作的 pid。</span><br><span class="line">    * GETNCNT：返回第 semnum 个信号量的 semncnt。等待 semval 变为大于当前值的线程数。</span><br><span class="line">    * GETZCNT：返回第 semnum 个信号量的 semzcnt。等待 semval 变为 0 的线程数。</span><br><span class="line">    * GETALL：去信号量集合中所有信号量的值，将结果存放到的 array 所指向的数组。</span><br><span class="line">    * SETALL：按 arg.array 所指向的数组中的值，设置集合中所有信号量的值。</span><br><span class="line">- 第四个参数是可选的：如果使用该参数，该参数的类型为 union semun，它是多个特定命令的联合体</span><br><span class="line">union semun &#123;</span><br><span class="line">        int val; /* Value for SETVAL */</span><br><span class="line">        struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */</span><br><span class="line">        unsigned short *array; /* Array for GETALL, SETALL */</span><br><span class="line">        struct seminfo *__buf; /* Buffer for IPC_INFO</span><br><span class="line">        (Linux-specific) */</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-信号量&quot;&gt;&lt;a href=&quot;#Linux应用编程-信号量&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-信号量&quot;&gt;&lt;/a&gt;Linux应用编程-信号量&lt;/h2&gt;&lt;h4 id=&quot;信号量的工作原理&quot;&gt;&lt;a href=&quot;#信</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-消息队列</title>
    <link href="http://example.com/2022/10/27/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <id>http://example.com/2022/10/27/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</id>
    <published>2022-10-27T13:54:25.000Z</published>
    <updated>2023-09-13T01:49:59.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-消息队列"><a href="#Linux应用编程-消息队列" class="headerlink" title="Linux应用编程-消息队列"></a>Linux应用编程-消息队列</h2><h5 id="消息队列的基本概念"><a href="#消息队列的基本概念" class="headerlink" title="消息队列的基本概念"></a>消息队列的基本概念</h5><p>消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。  </p><p>消息队列特点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 在消息队列中，发送数据用 msgsnd()，接收数据用msgrcv()，消息队列对每个数据都有一个最大长度的限制。</span><br><span class="line">- 消息队列也可以独立于发送和接收进程而存在，在进程终止时，消息队列及其内容并不会被删除。</span><br><span class="line">- 消息队列提供有格式的字节流。</span><br><span class="line">- 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级，接收程序可以通过消息类型有选择地接收数据</span><br><span class="line">- 消息队列可以实现消息的随机查询，消息不一定要以先进先出的顺序接收，也可以按消息的类型接收。</span><br></pre></td></tr></table></figure><h5 id="消息队列API函数"><a href="#消息队列API函数" class="headerlink" title="消息队列API函数"></a>消息队列API函数</h5><ul><li><p>创建或打开消息队列API函数msgget()  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msgget() 函数创建的消息队列的数量会受到系统可支持的消息队列数量的限制；</span><br><span class="line">msgget() 函数的作用是创建或获取一个消息队列对象，并返回消息队列标识符。</span><br><span class="line">int msgget(key_t key, int msgflg);</span><br><span class="line">- key：消息队列的关键字值，多个进程可以通过它访问同一个消息队列。可通过ftok函数创建</span><br><span class="line">• key_t ftok(const char *pathname, int proj_id);</span><br><span class="line">* path：合法路径</span><br><span class="line">* proj_id：一个整数</span><br><span class="line">- msgflg：表示创建的消息队列的标志参数</span><br><span class="line">•  IPC_CREAT</span><br><span class="line">•  IPC_EXCL</span><br><span class="line">•  mode</span><br><span class="line">这些参数是可以通过“｜”运算符联合起来的，因为它始终是 int 类型的参数。如 msgflag使用参数 IPC_CREAT | 0666 时表示，创建或返回已经存在的消息队列的标识符，且该消息队列的存取权限为0666。</span><br><span class="line">如果是 IPC_CREAT 为真表示：如果内核中不存在关键字与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列，返回此消息队列的标识符。</span><br><span class="line">而如果为 IPC_CREAT | IPC_EXCL 表示如果内核中不存在键值与 key 相等的消息队列，则新建一个消息队列；如果存在这样的消息队列则报错。</span><br><span class="line">mode 指 IPC 对象存取权限，它使用 Linux 文件的数字权限表示方式，如 0600， 0666等。</span><br><span class="line"></span><br><span class="line">返回值： 成功返回队列表示符，失败返回 -1</span><br><span class="line">记录在error中的错误代码：</span><br><span class="line">– EACCES：指定的消息队列已存在，但调用进程没有权限访问它</span><br><span class="line">– EEXIST： key 指定的消息队列已存在，而 msgflg 中同时指定 IPC_CREAT 和 IPC_EXCL标志</span><br><span class="line">– ENOENT： key 指定的消息队列不存在同时 msgflg 中没有指定 IPC_CREAT 标志</span><br><span class="line">– ENOMEM：需要建立消息队列，但内存不足</span><br><span class="line">– ENOSPC：需要建立消息队列，但已达到系统的限制</span><br><span class="line"></span><br><span class="line">注意：当 key 被指定为 IPC_PRIVATE 时，系统会自动产生一个未用的 key 来对应一个新的消息队列对象，这个消息队列一般用于进程内部间的通信。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>发送消息使用的API函数是 msgsnd() </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">msgsnd() 函数把消息发送到已打开的消息队列末尾;  </span><br><span class="line">int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);</span><br><span class="line">- msqid：消息队列标识符。</span><br><span class="line">- msgp：消息队列结构体，msgp 可以是任何类型的结构体，但第一个字段必须为 long 类型。</span><br><span class="line">• struct s_msg&#123;</span><br><span class="line">        long type; /* 必须大于 0, 消息类型 */</span><br><span class="line">        char mtext[１ ]; /* 消息正文，可以是其他任何类型 */</span><br><span class="line">      &#125; msgp;</span><br><span class="line">– msgsz：要发送消息的大小，不包含消息类型占用的 4 个字节，即 mtext 的长度。</span><br><span class="line">- msgflg：消息队列标志位参数</span><br><span class="line">• 0：当消息队列满时， msgsnd() 函数将会阻塞，直到消息能写进消息队列；</span><br><span class="line">• IPC_NOWAIT：当消息队列已满的时候， msgsnd() 函数不等待立即返回；</span><br><span class="line">• IPC_NOERROR：若发送的消息大于 size 字节，则把该消息截断，截断部分将被丢弃，且不通知发送进程。</span><br><span class="line">返回值：成功返回0，失败返回-1</span><br><span class="line">记录在error中的错误代码：</span><br><span class="line">– EAGAIN：参数 msgflg 设为 IPC_NOWAIT，而消息队列已满。</span><br><span class="line">– EIDRM：标识符为 msqid 的消息队列已被删除。</span><br><span class="line">– EACCESS：无权限写入消息队列。</span><br><span class="line">– EFAULT：参数 msgp 指向无效的内存地址。</span><br><span class="line">– EINTR：队列已满而处于等待情况下被信号中断。</span><br><span class="line">– EINVAL：无效的参数 msqid、 msgsz 或参数消息类型 type 小于 0。</span><br><span class="line"></span><br><span class="line">msgsnd() 解除阻塞的条件有以下三个条件：</span><br><span class="line">- 消息队列中有容纳该消息的空间。</span><br><span class="line">- msqid 代表的消息队列被删除。</span><br><span class="line">- 调用 msgsnd 函数的进程被信号中断。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>接收消息使用的API函数是 msgrcv()  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">msgrcv() 函数是从标识符为 msqid 的消息队列读取消息并将消息存储到 msgp 中，读取后把此消息从消息队列中删除.</span><br><span class="line">ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int␣,msgflg);</span><br><span class="line">msqid：消息队列标识符。</span><br><span class="line">- msgp：存放消息的结构体，结构体类型要与 msgsnd() 函数发送的类型相同。</span><br><span class="line">- msgsz：要接收消息的大小，不包含消息类型占用的 4 个字节。</span><br><span class="line">- msgtyp 有多个可选的值：如果为 0 则表示接收第一个消息，如果大于 0 则表示接收类型等于 msgtyp 的第一个消息，而如果小于 0 则表示接收类型等于或者小于 msgtyp 绝对值的第一个消息。</span><br><span class="line">- msgflg 用于设置接收的处理方式，取值情况如下：</span><br><span class="line">    • IPC_EXCEPT：与 msgtype 配合使用返回队列中第一个类型不为 msgtype 的消息</span><br><span class="line">    • IPC_NOWAIT：若在消息队列中并没有相应类型的消息可以接收，则函数立即返回，此时错误码为 ENOMSG</span><br><span class="line">    • 0: 阻塞式接收消息，没有该类型的消息 msgrcv 函数一直阻塞等待</span><br><span class="line">    • IPC_NOERROR：如果队列中满足条件的消息内容大于所请求的 size 字节，则把该消息截断，截断部分将被丢弃</span><br><span class="line">返回值： msgrcv() 函数如果接收消息成功则返回实际读取到的消息数据长度，否则返回-1</span><br><span class="line">错误代码：存放在error中</span><br><span class="line">– E2BIG：消息数据长度大于 msgsz 而 msgflag 没有设置 IPC_NOERROR</span><br><span class="line">– EIDRM：标识符为 msqid 的消息队列已被删除</span><br><span class="line">– EACCESS：无权限读取该消息队列</span><br><span class="line">– EFAULT：参数 msgp 指向无效的内存地址</span><br><span class="line">– ENOMSG：参数 msgflg 设为 IPC_NOWAIT，而消息队列中无消息可读</span><br><span class="line">– EINTR：等待读取队列内的消息情况下被信号中断</span><br><span class="line"></span><br><span class="line">msgrcv() 函数解除阻塞的条件也有三个：</span><br><span class="line">- 消息队列中有了满足条件的消息。</span><br><span class="line">- msqid 代表的消息队列被删除。</span><br><span class="line">- 调用 msgrcv() 函数的进程被信号中断。</span><br></pre></td></tr></table></figure></li><li><p>控制消息队列使用的APIs函数是 msgctl()  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">消息队列是可以被用户操作的，比如设置或者获取消息队列的相关属性，那么可以通过 msgctl()函数去处理它。</span><br><span class="line">int msgctl(int msqid, int cmd, struct msqid_ds *buf);</span><br><span class="line">- msqid：消息队列标识符。</span><br><span class="line">- cmd 用于设置使用什么操作命令</span><br><span class="line">    • IPC_SET 设置消息队列的属性，要设置的属性需先存储在结构体 msqid_ds 类型的 buf中，可设置的属性包括： msg_perm.uid、 msg_perm.gid、 msg_perm.mode 以及 msg_qbytes，储存在结构msqid_ds 中。</span><br><span class="line">    • IPC_RMID 立即删除该 MSG，并且唤醒所有阻塞在该 MSG 上的进程，同时忽略第三个参数。</span><br><span class="line">    • IPC_STAT 获取该 MSG 的信息，获取到的信息会储存在结构体 msqid_ds 类型的 buf 中。</span><br><span class="line">    • IPC_INFO 获得关于当前系统中 MSG 的限制值信息。</span><br><span class="line">    • MSG_INFO 获得关于当前系统中 MSG 的相关资源消耗信息。</span><br><span class="line">    • MSG_STAT 同 IPC_STAT，但 msgid 为该消息队列在内核中记录所有消息队列信息的数组的下标，因此通过迭代所有的下标可以获得系统中所有消息队列的相关信息。</span><br><span class="line">- buf：相关信息结构体缓冲区。</span><br><span class="line">    • 返回值：</span><br><span class="line">    • 成功： 0</span><br><span class="line">    • 出错： -1</span><br><span class="line">错误代码：</span><br><span class="line">- EACCESS：参数 cmd 为 IPC_STAT，确无权限读取该消息队列。</span><br><span class="line">- EFAULT：参数 buf 指向无效的内存地址。</span><br><span class="line">- EIDRM：标识符为 msqid 的消息队列已被删除。</span><br><span class="line">- EINVAL：无效的参数 cmd 或 msqid。</span><br><span class="line">- EPERM：参数 cmd 为 IPC_SET 或 IPC_RMID，却无足够的权限执行。</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-消息队列&quot;&gt;&lt;a href=&quot;#Linux应用编程-消息队列&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-消息队列&quot;&gt;&lt;/a&gt;Linux应用编程-消息队列&lt;/h2&gt;&lt;h5 id=&quot;消息队列的基本概念&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-管道</title>
    <link href="http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E7%AE%A1%E9%81%93/"/>
    <id>http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E7%AE%A1%E9%81%93/</id>
    <published>2022-10-26T15:39:05.000Z</published>
    <updated>2023-09-13T01:49:59.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-管道"><a href="#Linux应用编程-管道" class="headerlink" title="Linux应用编程-管道"></a>Linux应用编程-管道</h2><h4 id="管道分类"><a href="#管道分类" class="headerlink" title="管道分类"></a>管道分类</h4><h5 id="匿名管道（父子之间进行通信）"><a href="#匿名管道（父子之间进行通信）" class="headerlink" title="匿名管道（父子之间进行通信）"></a>匿名管道（父子之间进行通信）</h5><p>匿名管道：特点是只能在父子进程中使用，父进程在产生子进程前必须打开一个管道文件，然后 fork 产生子进程，这样子进程通过拷贝父进程的进程地址空间获得同一个管道文件的描述符，以达到使用同一个管道通信的目的. 匿名管道没有名字，一般进程无法使用 open() 来获取他的描述符  ，所以匿名管道只能用于亲缘关系进程间通信  。</p><p>匿名管道有以下特征：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">• 没有名字，因此不能使用 open() 函数打开，但可以使用 close() 函数关闭。</span><br><span class="line">• 只提供单向通信（半双工），也就是说，两个进程都能访问这个文件，假设进程 1 往文件内写东西，那么进程 2 就只能读取文件的内容。</span><br><span class="line">• 只能用于具有血缘关系的进程间通信，通常用于父子进程建通信。</span><br><span class="line">• 管道是基于字节流来通信的。</span><br><span class="line">• 依赖于文件系统，它的生命周期随进程的结束而结束。</span><br><span class="line">• 写入操作不具有原子性，因此只能用于一对一的简单通信情形。</span><br><span class="line">• 管道也可以看成是一种特殊的文件，对于它的读写也可以使用普通的 read() 和 write() 等函数。但是它又不是普通的文件，并不属于其他任何文件系统，并且只存在于内核的内存空间中，因此不能使用 lseek() 来定位。</span><br></pre></td></tr></table></figure><h5 id="pipe函数（所有进程间通信）"><a href="#pipe函数（所有进程间通信）" class="headerlink" title="pipe函数（所有进程间通信）"></a>pipe函数（所有进程间通信）</h5><p>pipe() 函数用于创建一个匿名管道，一个可用于进程间通信的单向数据通道。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pipe(int pipefd[2]);</span><br><span class="line">pipefd[0] 指管道的读取端， pipefd[1]指向管道的写端</span><br><span class="line">pipe函数返回 0 表示创建匿名管道成功 返回 -1 创建失败</span><br></pre></td></tr></table></figure><p>创建匿名管道需要一下步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• 父进程调用 pipe() 函数创建匿名管道，得到两个文件描述符 pipefd[0]、 pipefd[1]，分别指向管道的读取端和写入端。</span><br><span class="line">• 父进程调用 fork() 函数启动（创建）一个子进程，那么子进程将从父进程中继承这两个文件描述符 pipefd[0]、 pipefd[1]，它们指向同一匿名管道的读取端与写入端。</span><br><span class="line">• 由于匿名管道是利用环形队列实现的，数据将从写入端流入管道，从读取端流出，这样子就实现了进程间通信，但是这个匿名管道此时有两个读取端与两个写入端，因此需要进行接下来的操作。</span><br><span class="line">• 如果想要从父进程将数据传递给子进程，则父进程需要关闭读取端，子进程关闭写入端，如图数据从父进程流向子进程 所示。</span><br><span class="line">• 如果想要从子进程将数据传递给父进程，则父进程需要关闭写入端，子进程关闭读取端，如图数据从子进程流向父进程 所示。</span><br><span class="line">• 当不需要管道的时候，就在进程中将未关闭的一端关闭即可。</span><br></pre></td></tr></table></figure><h5 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h5><p>命名管道：</p><p>命名管道可以在多个无关的进程中交换数据（通信） .</p><p>命名管道一下特征：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">• 有名字，存储于普通文件系统之中。</span><br><span class="line">• 任何具有相应权限的进程都可以使用 open() 来获取命名管道的文件描述符。</span><br><span class="line">• 跟普通文件一样：使用统一的 read()/write() 来读写。</span><br><span class="line">• 跟普通文件不同：不能使用 lseek() 来定位，原因是数据存储于内存中。</span><br><span class="line">• 具有写入原子性，支持多写者同时进行写操作而数据不会互相践踏。</span><br><span class="line">• 遵循先进先出（First In First Out）原则，最先被写入 FIFO 的数据，最先被读出来。</span><br></pre></td></tr></table></figure><p>mkfifo函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int mkfifo(const char * pathname,mode_t mode);</span><br><span class="line">- pathname 需要创建的FIFO文件名</span><br><span class="line">- mode mode模式及权限参数说明</span><br><span class="line">    • O_WRONLY：写管道。</span><br><span class="line">    • O_RDONLY：读管道。</span><br><span class="line">    • O_RDWR：读写管道。</span><br><span class="line">    • O_NONBLOCK：非阻塞。</span><br><span class="line">    • O_CREAT：如果该文件不存在，那么就创建一个新的文件，并用第三个参数为其设置权限。</span><br><span class="line">    • O_EXCL：如果使用 O_CREAT 时文件存在，那么可返回错误消息。这一参数可测试文件是否存在。</span><br><span class="line">返回值说明如下：</span><br><span class="line">    • 0：成功</span><br><span class="line">    • EACCESS：参数 filename 所指定的目录路径无可执行的权限。</span><br><span class="line">    • EEXIST：参数 filename 所指定的文件已存在。</span><br><span class="line">    • ENAMETOOLONG：参数 filename 的路径名称太长。</span><br><span class="line">    • ENOENT：参数 filename 包含的目录不存在。</span><br><span class="line">    • ENOSPC：文件系统的剩余空间不足。</span><br><span class="line">    • ENOTDIR：参数 filename 路径中的目录存在但却非真正的目录。</span><br><span class="line">    • EROFS：参数 filename 指定的文件存在于只读文件系统内。</span><br><span class="line">mkfifo() 会根据参数 pathname 建立特殊的 FIFO 文件，而参数 mode 为该文件的模式与权限。</span><br><span class="line">对FIFO进行读操作：</span><br><span class="line">-阻塞类型的管道 管道内有数据就读取，没有数据就阻塞在那里</span><br><span class="line">-非阻塞类型的管道 不论 FIFO 内是否有数据，读进程都会立即执行读操作，管道内没有数据返回0</span><br><span class="line">对FIFO进行写操作：</span><br><span class="line">-阻塞类型的管道 写操作将一直阻塞到数据可以被写入。</span><br><span class="line">-非阻塞类型的管道 不能写入全部数据，则写操作进行部分写入或者调用失败。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>access函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">检查调用进程是否可以对指定的文件执行某种操作。</span><br><span class="line">int access(const char* pathname, int mode);</span><br><span class="line">- pathname 是文件的路径名+文件名</span><br><span class="line">- mode：指定access的作用，取值如下</span><br><span class="line">    • F_OK 值为0，判断文件是否存在 </span><br><span class="line">    • X_OK 值为1，判断对文件是可执行权限 </span><br><span class="line">    • W_OK 值为2，判断对文件是否有写权限 </span><br><span class="line">    • R_OK 值为4，判断对文件是否有读权限</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-管道&quot;&gt;&lt;a href=&quot;#Linux应用编程-管道&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-管道&quot;&gt;&lt;/a&gt;Linux应用编程-管道&lt;/h2&gt;&lt;h4 id=&quot;管道分类&quot;&gt;&lt;a href=&quot;#管道分类&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-信号</title>
    <link href="http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/"/>
    <id>http://example.com/2022/10/26/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/</id>
    <published>2022-10-26T12:54:06.000Z</published>
    <updated>2023-09-13T01:49:59.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-信号"><a href="#Linux应用编程-信号" class="headerlink" title="Linux应用编程-信号"></a>Linux应用编程-信号</h2><h5 id="Linux系统支持的信号"><a href="#Linux系统支持的信号" class="headerlink" title="Linux系统支持的信号"></a>Linux系统支持的信号</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">使用kill -l查看信号</span><br><span class="line">信号分类：</span><br><span class="line">- 信号值为1-31的信号属于非实时信号（不可靠信号）（不支持排队处理）</span><br><span class="line">- 信号值为34-64的信号为实时信号 （可靠信号）（支持排队处理）</span><br><span class="line"></span><br><span class="line">以下是常用的一些信号：</span><br><span class="line">SIGHUP 1 关闭终端 终止 </span><br><span class="line">SIGINT 2 ctrl+c 终止 </span><br><span class="line">SIGQUIT 3 ctrl+\ 终止+转储 </span><br><span class="line">SIGABRT 6 abort() 停止+转储 </span><br><span class="line">SIGPE 8 算术错误 终止 </span><br><span class="line">SIGKILL 9 kill -9 pid 终止，不可捕获/忽略 </span><br><span class="line">SIGUSR1 10 自定义 忽略 </span><br><span class="line">SIGSEGV 11 段错误 终止+转储 </span><br><span class="line">SIGUSR2 12 自定义 忽略 </span><br><span class="line">SIGALRM 14 alarm() 终止 </span><br><span class="line">SIGTERM 15 kill pid 终止 </span><br><span class="line">SIGCHLD 17 (子)状态变化 忽略 </span><br><span class="line">SIGTOP 19 ctrl+z 暂停，不可忽略/捕获</span><br><span class="line"></span><br><span class="line">使用kill或者是pkill可以杀死进程</span><br><span class="line">• kill + pid 或者 kill + -9 + pid</span><br><span class="line">• pkill + 需要杀死的进程名称</span><br></pre></td></tr></table></figure><h5 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h5><p>信号的处理方式（实时信号 非实时信号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 忽略信号</span><br><span class="line">- 捕捉信号</span><br><span class="line">- 让信号默认动作起作用</span><br></pre></td></tr></table></figure><h5 id="信号API函数"><a href="#信号API函数" class="headerlink" title="信号API函数"></a>信号API函数</h5><p>捕获信号API函数：</p><ul><li>signal函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//signal函数</span><br><span class="line">typedef void (*sighandler_t)(int); //信号处理函数</span><br><span class="line">sighandler_t signal(int signum, sighandler_t handler); //signal 捕获函数</span><br><span class="line">- signum 指定捕获的信号</span><br><span class="line">- handler 用户处理信号的方式</span><br><span class="line">• SIG_IGN 忽略该信号</span><br><span class="line">• SIG_DFL 采用系统默认方式处理信号</span><br><span class="line">• 使用信号处理函数void sighandler_t(int);</span><br><span class="line">返回值：成功 上一次设置的handler 失败SIG_ERR</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>sigaction函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//sigaction函数</span><br><span class="line">struct sigaction &#123;</span><br><span class="line">    void (*sa_handler)(int); 是捕获信号后的处理函数</span><br><span class="line">    void (*sa_sigaction)(int, siginfo_t *, void *); 是扩展信号处理函数</span><br><span class="line">    sigset_t sa_mask; 是信号掩码 它指定了在执行信号处理函数期间阻塞的信号的掩码，被设置</span><br><span class="line">                      在该掩码中的信号，在进程响应信号期间被临时阻塞。除非使用 SA_NODEFER 标志</span><br><span class="line">                      否则即使是当前正在处理的响应的信号再次到来的时候也会被阻塞。</span><br><span class="line">    int sa_flags; 系列用于修改信号处理过程行为的标志</span><br><span class="line">    void (*sa_restorer)(void);</span><br><span class="line">&#125;;</span><br><span class="line">sa_flags：</span><br><span class="line">- SA_NOCLDSTOP 如果 signum 是 SIGCHLD，则在子进程停止或恢复时，不会传信号给调用 sigaction() 函数的进程。</span><br><span class="line">- SA_NOCLDWAIT 它表示父进程在它的子进程终止时不会收到 SIGCHLD 信号，这时子进程终止则不会成为僵尸进程。</span><br><span class="line">- SA_NODEFER 不要阻止从其自身的信号处理程序中接收信号，使进程对信号的屏蔽无效，即在信号处理函数执行期间仍能接收这个信号</span><br><span class="line">- SA_RESETHAND 信号处理之后重新设置为默认的处理方式。</span><br><span class="line">- SA_SIGINFO 指示使用 sa_sigaction 成员而不是使用 sa_handler 成员作为信号处理函数</span><br><span class="line"></span><br><span class="line">int sigaction(int signum, const struct sigaction *act,struct sigaction *oldact);</span><br><span class="line">- signum :指定捕获的信号</span><br><span class="line">- act :struct sigaction类型的结构体</span><br><span class="line">- oldact :返回原有的信号处理参数，一般设置为 NULL 即可。</span><br></pre></td></tr></table></figure><p>发送信号API函数：</p><ul><li>kill函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kill函数向包括它本身在内的其他进程发送一个信号</span><br><span class="line">int kill(pid_t pid,int sig);</span><br><span class="line">- pid :pid取值</span><br><span class="line">    • pid &gt; 1：将信号 sig 发送到进程 ID 值为 pid 指定的进程。</span><br><span class="line">    • pid = 0：信号被发送到所有和当前进程在同一个进程组的进程。</span><br><span class="line">    • pid = -1：将 sig 发送到系统中所有的进程，但进程 1（init）除外。</span><br><span class="line">    • pid &lt; -1：将信号 sig 发送给进程组号为-pid （pid 绝对值）的每一个进程。</span><br><span class="line">- sig :发送的信号值</span><br><span class="line">-函数返回值：0 成功 1失败</span><br></pre></td></tr></table></figure><ul><li>raise函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">raise() 函数只是进程向自身发送信号的，而没有向其他进程发送信号.给当前进程发送指定信号（自己给自己发信号）</span><br><span class="line">kill(getpid(),sig) 等同于 raise(sig)</span><br><span class="line">int raise(int sig);</span><br><span class="line">函数只有一个参数 sig，它代表着发送的信号值，如果发送成功则返回 0，发送失败则返回-1</span><br></pre></td></tr></table></figure><ul><li>alarm函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alarm() 也称为闹钟函数，它可以在进程中设置一个定时器，当定时器指定的时间 seconds 到时，它就向进程发送 SIGALRM 信号。</span><br><span class="line">unsigned int alarm(unsigned int seconds);</span><br><span class="line">如果在 seconds 秒内再次调用了 alarm() 函数设置了新的闹钟，则新的设置将覆盖前面的设置，即之前设置的秒数被新的闹钟时间取代。它的返回值是之前闹钟的剩余秒数，如果之前未设闹钟则返回 0。</span><br></pre></td></tr></table></figure><h5 id="信号集处理函数"><a href="#信号集处理函数" class="headerlink" title="信号集处理函数"></a>信号集处理函数</h5><ul><li><p>屏蔽信号集：屏蔽某些信号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 手动去调用信号集函数</span><br><span class="line">- 某些场景系统自动取设置信号集</span><br></pre></td></tr></table></figure></li><li><p>未处理信号集：如果信号集被屏蔽，则记录在未处理信号集中，直到屏蔽信号集解除对信号的屏蔽才会去处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 非实时信号（1-31）：不排队，只留一个（不管来多少信号，只保留最近的一个信号，其他信号全部丢掉）</span><br><span class="line">- 实时信号（34-64）：排队，保留全部信号</span><br></pre></td></tr></table></figure></li><li><p>信号集相关API</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sigemptyset(sigset_t *set); //将信号集合初始化为0函数 不屏蔽信号</span><br><span class="line">int sigfillset(sigset_t *set); //将信号集合初始化为1函数 屏蔽信号</span><br><span class="line">int sigaddset(sigset_t *set); //将信号集合某一位设置为1</span><br><span class="line">int sigdelset(sigset_t *set); //将信号集合某一位设置为0</span><br><span class="line">int sigismember(const sigset_t *set, int signum); //判断某信号是否在屏蔽信号集里面</span><br><span class="line">//该函数可以根据参数指定的方法修改进程的信号屏蔽字</span><br><span class="line">//将屏蔽信号赋值给屏蔽信号集</span><br><span class="line">int sigprocmask(int how, const old_kernel_sigset_t *set,old_kernel_sigset_t *oldset);</span><br><span class="line">- how：</span><br><span class="line">    •  SIG_BLOCK:屏蔽某个信号，添加的信号屏蔽字不覆盖之前的，这是一个并集的关系（屏蔽集 |set ）</span><br><span class="line">    •  SIG_UNBLOCK:希望解除BLOCK的信号集合。解除信号集的屏蔽（屏蔽集 &amp;~ set）</span><br><span class="line">    •  SIG_SETMASK:该进程的信号屏蔽是set指向的值。（直接等于我们设置的信号集合）</span><br><span class="line">- set：需要传入的屏蔽信号集</span><br><span class="line">- oldset：保存旧的屏蔽集的值，NULL表示不保存</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-信号&quot;&gt;&lt;a href=&quot;#Linux应用编程-信号&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-信号&quot;&gt;&lt;/a&gt;Linux应用编程-信号&lt;/h2&gt;&lt;h5 id=&quot;Linux系统支持的信号&quot;&gt;&lt;a href=&quot;#L</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux应用编程-进程</title>
    <link href="http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
    <id>http://example.com/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/</id>
    <published>2022-10-25T14:48:47.000Z</published>
    <updated>2023-09-13T01:49:59.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux应用编程-进程"><a href="#Linux应用编程-进程" class="headerlink" title="Linux应用编程-进程"></a>Linux应用编程-进程</h2><h5 id="fork-进程函数："><a href="#fork-进程函数：" class="headerlink" title="fork()进程函数："></a>fork()进程函数：</h5><p>fork()进程函数用于从一个已存在的进程中去启动一个新进程，新进程成为子进程，原来的进程称为父进程。fork()函数的本质是直接将父进程的内容复制一份，但是子进程与父进程也有不一样的地方。</p><p>子进程与父进程相同的内容：</p><ul><li>进程的地址空间</li><li>进程上下文，代码段</li><li>进程的堆栈空间，和内存信息</li><li>进程的环境变量，标准的IO缓冲区</li><li>打开的文件描述符，信号响应函数，当前的工作路劲</li></ul><p>子进程独有的内容：</p><ul><li>子进程的进程号PID，PID是进程的唯一的标识符</li><li>记录锁，父进程对某文件加锁，子进程不会继承这把锁</li><li>挂起信号，父进程的响应但未处理的信号，子进程不会继承</li></ul><p><img src="/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20221025225022643.png" alt="image-20221025225022643"></p><p>fork函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pid_t fork(void);</span><br><span class="line"></span><br><span class="line">fork函数启动成功：父进程会返回子进程的pid,子进程返回0，</span><br><span class="line">启动失败：返回-1</span><br><span class="line"></span><br><span class="line">pid_t getpid(void);函数会返回当前进程pid</span><br><span class="line">pid_t getppid(void);函数会返回当前进程的父进程pid</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="exec系列进程替换函数"><a href="#exec系列进程替换函数" class="headerlink" title="exec系列进程替换函数"></a>exec系列进程替换函数</h5><p>exec系列函数用于替换进程的执行程序，它可以根据指定的文件名或目录名找到可执行文件，并用它来取代原调用进程的数据段、代码段和堆栈段，在执行完之后，原调用进程的内容除了进程号外，其他全部被新程序的内容替换  </p><p>exec系列函数介绍：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ...)</span><br><span class="line">int execlp(const char *file, const char *arg, ...)</span><br><span class="line">int execle(const char *path, const char *arg, ..., char *const envp[])</span><br><span class="line">int execv(const char *path, char *const argv[])</span><br><span class="line">int execvp(const char *file, char *const argv[])</span><br><span class="line">int execve(const char *path, char *const argv[], char *const envp[])</span><br><span class="line"></span><br><span class="line">这些函数可以分为两大类execl、execlp和execle传递给子程序的参数个数是可变的。 execv、 execvp 和 execve 通过数组去装载子程序的参数，无论那种形式，参数都以一个空指针 NULL 结束.</span><br><span class="line">l----list 列表</span><br><span class="line">v----vector 数组</span><br><span class="line"></span><br><span class="line">参数介绍：</span><br><span class="line">const char *path:该参数需要输入文件路径，例如：&quot;/bin/ls&quot; &quot;/bin/pwd&quot;</span><br><span class="line">const char *file:该参数需要输入需要执行的应用程序名字，例如：&quot;ls&quot; &quot;pwd&quot;</span><br><span class="line">const char *arg:该参数需要输入对应字符，例如：&quot;ls&quot;,&quot;-al&quot;,NULL &quot;pwd&quot;,NULL</span><br><span class="line">const char *agrv[]:该参数需要输入对应数组指针：例如：char *argv[]=&#123;&quot;pwd&quot;,NULL&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">！！注意：exec 系列函数是直接将当前进程给替换掉的，当调用 exec 系列函数后，当前进程将不会</span><br><span class="line">再继续执行，</span><br></pre></td></tr></table></figure><p>execl函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int execl(const char *path, const char *arg, ... )</span><br><span class="line">path:指定文件路径</span><br><span class="line">arg：执行文件所传递的参数 arg[0],arg[1]...arg[n],最后一个参数必须是NULL做结束标志</span><br><span class="line"></span><br><span class="line">该函数一般不会返回，除非遇到错误会返回-1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>execv函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int execv(const char *path, char *const argv[])</span><br><span class="line">path:指定文件路径</span><br><span class="line">argv：执行文件所传递的参数是一个数组指针,最后一个参数必须是NULL做结束标志</span><br><span class="line"></span><br><span class="line">该函数一般不会返回，除非遇到错误会返回-1</span><br></pre></td></tr></table></figure><h5 id="进程的生老病死"><a href="#进程的生老病死" class="headerlink" title="进程的生老病死"></a>进程的生老病死</h5><p><img src="/2022/10/25/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20221025230037584.png" alt="image-20221025230037584"></p><h5 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h5><ul><li><p>正常终止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-main 函数返回</span><br><span class="line">-调用_exit()函数终止</span><br><span class="line">-调用exit()函数终止</span><br></pre></td></tr></table></figure></li><li><p>异常终止</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-调用abort()函数异常终止</span><br><span class="line">-又系统信号终止 </span><br></pre></td></tr></table></figure></li></ul><p>exit函数和_exit()函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void _exit(int status);</span><br><span class="line">void exit(int status);</span><br><span class="line">传入一个status保存进程终止时的状态码</span><br></pre></td></tr></table></figure><p>exit()函数和_exit()函数的异同：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">exit() 和 _exit() 函数都是用来终止进程的，当程序执行到 exit() 或 _exit() 函数时，进程会无条件地停止剩下的所有操作，清除包括 PCB 在内的各种数据结构，并终止当前进程的运行。</span><br><span class="line"></span><br><span class="line">_exit() 函数:直接通过系统调用使进程终止运行,清除这个进程使用的内存空间，并销毁它在内核中的各种数据结构.</span><br><span class="line">exit() 函数是_exit()函数包装来的。在执行_exit()函数之前，需要清除&quot;IO缓冲区&quot;，有效的保存数据的完整性。</span><br><span class="line">清清除&quot;IO缓冲区&quot;是检查文件的打开情况，把文件缓冲区中的内容写回文件</span><br></pre></td></tr></table></figure><h5 id="等待进程"><a href="#等待进程" class="headerlink" title="等待进程"></a>等待进程</h5><p>当一个进程调用了exit()函数之后，该进程并不会直接消失，而是会变成僵尸进程。需要等待其父进程去回收僵尸进程，需要调用waitpid()或者wait()函数去回收僵尸进程并且，释放僵尸进程占有的内存空间，和了解进程终止的状态信息。调用wait函数会阻塞父进程。</p><p>wait函数和waitpid函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//wait函数</span><br><span class="line">pid_t wait(int *wstatus);</span><br><span class="line">调用wait函数之后 调用成功：返回子进程pid，和进程退出状态</span><br><span class="line">失败:返回-1</span><br><span class="line"></span><br><span class="line">pid_t waitpid(pid_t pid, int *wstatus, int options);</span><br><span class="line">pid: 欲等待的子进程的识别码。</span><br><span class="line">• pid&lt;-1等待进程组号为pid绝对值的任何子进程。</span><br><span class="line">• pid&gt;0等待进程号为pid的子进程。</span><br><span class="line">• pid=-1等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。</span><br><span class="line">• pid=0等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。</span><br><span class="line">wstatus：返回的状态值</span><br><span class="line">options：控制waitpid()函数的行为，如果不想使用这些选项，则可以把这个参数设为0。</span><br><span class="line">• WNOHANG如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这个函数上等待；如果结束了，则返回该子进程的进程号。</span><br><span class="line">• WUNTRACED如果子进程进入暂停状态，则马上返回。</span><br><span class="line"></span><br><span class="line">调用wait函数之后 调用成功：返回子进程pid，和进程退出状态</span><br><span class="line">失败:返回-1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//waitpid函数</span><br><span class="line">如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；</span><br><span class="line">但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。</span><br><span class="line"></span><br><span class="line">waitpid(-1,&amp;status,0) = wait(&amp;status)</span><br><span class="line"></span><br><span class="line">//wait和waitpid函数调用之后返回 wstatus 的值</span><br><span class="line">• WIFEXITED(status) ：如果子进程正常结束，返回一个非零值</span><br><span class="line">• WEXITSTATUS(status)：如果 WIFEXITED 非零，返回子进程退出码</span><br><span class="line">• WIFSIGNALED(status) ：子进程因为捕获信号而终止，返回非零值</span><br><span class="line">• WTERMSIG(status) ：如果 WIFSIGNALED 非零，返回信号代码</span><br><span class="line">• WIFSTOPPED(status)：如果子进程被暂停，返回一个非零值</span><br><span class="line">• WSTOPSIG(status)：如果 WIFSTOPPED 非零，返回一个信号代码</span><br></pre></td></tr></table></figure><h5 id="进程组，会话，终端"><a href="#进程组，会话，终端" class="headerlink" title="进程组，会话，终端"></a>进程组，会话，终端</h5><ul><li>进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">进程组：</span><br><span class="line">• 对相同的类型的进程进行管理</span><br><span class="line">进程组的诞生：</span><br><span class="line">• 在shell里面直接执行一个应用程序，对于大部分应用程序，自己就是进程组的首进程。进程组只有一个进程</span><br><span class="line">• 如果进程调用了fork函数，那么父子进程同属一个进程组，父进程为首进程</span><br><span class="line">• shell中通过管道执行连接起来的应用程序，两个程序同属一个进程组，第一个程序为进程组的首进程</span><br><span class="line"></span><br><span class="line">进程组id:pgid,由首进程pid决定 </span><br><span class="line">pgid：进程组所在的id号</span><br></pre></td></tr></table></figure><ul><li>会话（一般关联着一个终端）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">会话：管理前后台进程组</span><br><span class="line">会话的诞生：</span><br><span class="line">• 调用调用setsid函数，新建一个会话，应用程序作为会话的第一个进程，称为会话首进程</span><br><span class="line">• 用户在终端正确登录之后，启动shell时linux系统会创建一个新的会话，shell进程作为会话首进程。</span><br><span class="line">会话id:sid</span><br><span class="line">sid:会话首进程id</span><br></pre></td></tr></table></figure><ul><li>前台进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">前台进程组：</span><br><span class="line">shell进程启动时，默认是前台进程组的首进程</span><br><span class="line">前台进程组的首进程会占用绘画所关联的终端来运行，shell启动其他应用程序时，其他程序成为首进程</span><br></pre></td></tr></table></figure><ul><li>后台进程组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">后台进程组的程序是不会占用终端的。</span><br><span class="line">在shell终端运行程序时，在后面加上&amp;的符号，可以指定程序运行在后台进程组里面。</span><br><span class="line">例：sleep 10 &amp;</span><br><span class="line"></span><br><span class="line">ctrl+z：会使进程进入后台，同时停止执行。返回终端</span><br><span class="line">jobs:查看有哪些后台进程组，和jobs id</span><br><span class="line">fg +job id可以把后台进程组切换为前台进程组</span><br></pre></td></tr></table></figure><ul><li>终端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">物理终端</span><br><span class="line">• 串口终端</span><br><span class="line">• lcd终端</span><br><span class="line">伪终端（不依赖物理设备）</span><br><span class="line">• SSH远程连接产生的终端</span><br><span class="line">• 桌面系统产生的终端</span><br><span class="line">虚拟终端</span><br><span class="line">• linux内核自带的 ctrl+alt+f0~f6来打开不同的终端</span><br><span class="line"></span><br><span class="line">终端被关闭之后，会话中的所有进程都会被关掉</span><br></pre></td></tr></table></figure><h5 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h5><p>守护进程不受终端影响的，终端退出，而也可以继续在后台运行，</p><p>写守护进程步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">• 创建一个子进程，父进程直接退出，</span><br><span class="line">- 使用fork()函数创建,</span><br><span class="line">• 创建一个新的会话</span><br><span class="line">- 子进程使用setsid()函数创建一个新的会话，没有关联任何终端</span><br><span class="line">• 改变守护进程的当前工作目录，改为&quot;/&quot;。因为子进程会继承父进程的工作目录的。所以需要改变工作目录。</span><br><span class="line">- 子进程使用chdir()函数实现</span><br><span class="line">• 重设文件权限的掩码（umask可以查看文件权限掩码 0022 -- 只写）</span><br><span class="line">新建文件的权限默认使0666,需要与掩码进行与非(&amp;~)的运算才是实际的文件权限</span><br><span class="line">-子进程使用umask()函数实现 umask直接设置为0</span><br><span class="line">• 关闭不需要的文件描述符</span><br><span class="line">- 子进程使用close()函数实现</span><br><span class="line">    - 0，1，2文件描述符，分别对应终端的标准输入，输出，出错。不需要与终端相关联所以需要关闭这些文件描述符。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Linux应用编程-进程&quot;&gt;&lt;a href=&quot;#Linux应用编程-进程&quot; class=&quot;headerlink&quot; title=&quot;Linux应用编程-进程&quot;&gt;&lt;/a&gt;Linux应用编程-进程&lt;/h2&gt;&lt;h5 id=&quot;fork-进程函数：&quot;&gt;&lt;a href=&quot;#for</summary>
      
    
    
    
    <category term="Linux" scheme="http://example.com/categories/Linux/"/>
    
    
    <category term="Linux应用开发" scheme="http://example.com/tags/Linux%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>函数返回二维数组地址</title>
    <link href="http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/"/>
    <id>http://example.com/2022/10/22/%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%9C%B0%E5%9D%80/</id>
    <published>2022-10-22T13:37:41.000Z</published>
    <updated>2023-09-13T01:49:59.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回二维数组地址"><a href="#返回二维数组地址" class="headerlink" title="返回二维数组地址"></a>返回二维数组地址</h2><h5 id="int-p-int-3-说明："><a href="#int-p-int-3-说明：" class="headerlink" title="int *(*p(int))[3]说明："></a><em>int</em> *(*p(<em>int</em>))[3]说明：</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,</span><br><span class="line">//说明函数有一个整型变量参数,然后再与外面的*结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,</span><br><span class="line">//说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.</span><br><span class="line">//所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.</span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址方法1"><a href="#返回二维数组地址方法1" class="headerlink" title="返回二维数组地址方法1"></a>返回二维数组地址方法1</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;</span><br><span class="line">int (*ptraar)[4];</span><br><span class="line"></span><br><span class="line">int (*vfunc(void))[4]</span><br><span class="line">&#123;</span><br><span class="line">  return parr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">ptraar = vfunc();</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,(*(*ptraar ) + 1)); //ptrarr[0][1]</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,ptrarr[0][1]); //ptrarr[0][1]</span><br><span class="line">&#125;</span><br><span class="line">//解析</span><br><span class="line">ptraar = 二维数组首地址</span><br><span class="line">(*ptraar ) = 二维数组元素首地址</span><br><span class="line">(*(*ptraar ) = 一维数组元素首地址</span><br><span class="line">(*(*ptraar ) + 1) = ptrarr[0][1]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址方法2"><a href="#返回二维数组地址方法2" class="headerlink" title="返回二维数组地址方法2"></a>返回二维数组地址方法2</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int prrs[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;9,10,11,12&#125;&#125;;</span><br><span class="line"></span><br><span class="line">void * func(void)</span><br><span class="line">&#123;</span><br><span class="line">  return prrs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *ins;</span><br><span class="line">ins = func();</span><br><span class="line">ptraar = (int (*)[4])ins;</span><br><span class="line">printf(&quot;ptrarr %d\r\n&quot;,*(*(ptraar + 1) + 2 ));</span><br></pre></td></tr></table></figure><h5 id="返回二维数组地址指针"><a href="#返回二维数组地址指针" class="headerlink" title="返回二维数组地址指针"></a>返回二维数组地址指针</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int parr[3][4]=&#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;0,4,8,9&#125;&#125;;</span><br><span class="line">int *ptesarr[3][4]=&#123;&#123;&amp;arrss[0],&amp;arrss[1],&amp;arrss[2],&amp;arrss[3]&#125;,</span><br><span class="line">                    &#123;&amp;arrss[4],&amp;arrss[5],&amp;arrss[6],&amp;arrss[7]&#125;,</span><br><span class="line">                    &#123;&amp;arrss[8],&amp;arrss[9],&amp;arrss[10],&amp;arrss[11]&#125;&#125;;</span><br><span class="line">                    </span><br><span class="line">int *(*psst)[4];</span><br><span class="line">int *(*functions(void))[4]</span><br><span class="line">&#123;</span><br><span class="line">  return ptesarr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">psst = functions();</span><br><span class="line">printf(&quot;psst ptr = %d\r\n&quot;,*(*(*(psst+0)) + 3));//*psst[0][3]</span><br><span class="line">printf(&quot;psst ptr arr= %d\r\n&quot;,*(psst[1][3]));//*psst[1][3]</span><br><span class="line">&#125;</span><br><span class="line">//解析</span><br><span class="line">*psst[2][3] = *(psst[2][3])  </span><br><span class="line">*(pstt[2][3]) = *((*(pstt+2)+3))</span><br><span class="line">pstt二维数组首地址</span><br><span class="line">*(pstt) = [二维数组元素首地址]</span><br><span class="line">*(*(pstt)) = [一维数组元素首地址]</span><br><span class="line">*(*(*(pstt + 2)) + 3) = [二维数组首地址 + 2][一维数组元素首地址 + 3]</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;返回二维数组地址&quot;&gt;&lt;a href=&quot;#返回二维数组地址&quot; class=&quot;headerlink&quot; title=&quot;返回二维数组地址&quot;&gt;&lt;/a&gt;返回二维数组地址&lt;/h2&gt;&lt;h5 id=&quot;int-p-int-3-说明：&quot;&gt;&lt;a href=&quot;#int-p-int-3-说明</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>单链表头插法</title>
    <link href="http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/"/>
    <id>http://example.com/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/</id>
    <published>2022-10-22T13:31:29.000Z</published>
    <updated>2023-09-13T01:49:59.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单链表头插法"><a href="#单链表头插法" class="headerlink" title="单链表头插法"></a>单链表头插法</h2><h5 id="单链表数据结构定义"><a href="#单链表数据结构定义" class="headerlink" title="单链表数据结构定义"></a>单链表数据结构定义</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct timer</span><br><span class="line">&#123;</span><br><span class="line">  int value; //数据</span><br><span class="line">  struct timer *next;//节点</span><br><span class="line">&#125;timer;</span><br><span class="line"></span><br><span class="line">//定义头指针head_handle</span><br><span class="line">static struct timer *head_handle;</span><br></pre></td></tr></table></figure><h5 id="链表初始化"><a href="#链表初始化" class="headerlink" title="链表初始化"></a>链表初始化</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void timer_init(struct timer *handle,int value)</span><br><span class="line">&#123;</span><br><span class="line">  memset(handle,0,sizeof(struct timer));</span><br><span class="line">  handle-&gt;buff = NULL;</span><br><span class="line">  handle-&gt;value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建链表（头插法）"><a href="#创建链表（头插法）" class="headerlink" title="创建链表（头插法）"></a>创建链表（头插法）</h5><p><img src="/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/image-20221022213426409.png" alt="image-20221022213426409"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int start_timer(struct timer *handle)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer *target = head_handle;</span><br><span class="line">  while(target)</span><br><span class="line">  &#123;</span><br><span class="line">    if(target == handle) //判断新创建的节点是否和以前创建的是否相同</span><br><span class="line">    &#123;</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    target = target-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  handle-&gt;next = head_handle;</span><br><span class="line">  head_handle = handle;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//new_node1节点创建之前头节点 head_handle == NULL</span><br><span class="line">//new_node1节点创建之后头节点 head_handle == new_node1</span><br><span class="line">//当前链表链接顺序：new_node1-&gt;head_handle</span><br><span class="line">//new_node2节点创建之后头节点 head_handle == new_node2</span><br><span class="line">//当前链表链接顺序：new_node2-&gt;new_node1-&gt;head_handle</span><br></pre></td></tr></table></figure><h5 id="删除链表"><a href="#删除链表" class="headerlink" title="删除链表"></a>删除链表</h5><p><img src="/2022/10/22/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%A4%B4%E6%8F%92%E6%B3%95/image-20221022213453323.png" alt="image-20221022213453323"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void timer_stop(struct timer *handle)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer **curr;</span><br><span class="line">  for(curr = &amp;head_handle;*curr;)</span><br><span class="line">  &#123;</span><br><span class="line">    struct timer *entry = *curr;</span><br><span class="line">    if(entry == handle)</span><br><span class="line">    &#123;</span><br><span class="line">      *curr = entry-&gt;next;</span><br><span class="line">      return ;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      curr = &amp;entry-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链表遍历"><a href="#链表遍历" class="headerlink" title="链表遍历"></a>链表遍历</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void timer_traverse(void)</span><br><span class="line">&#123;</span><br><span class="line">  struct timer *target;</span><br><span class="line">  //根据链表头节点遍历整个链表</span><br><span class="line">  for(target = head_handle;target;target = target-&gt;next)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;timer value : %d\r\n&quot;,target-&gt;value);</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;\r\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;单链表头插法&quot;&gt;&lt;a href=&quot;#单链表头插法&quot; class=&quot;headerlink&quot; title=&quot;单链表头插法&quot;&gt;&lt;/a&gt;单链表头插法&lt;/h2&gt;&lt;h5 id=&quot;单链表数据结构定义&quot;&gt;&lt;a href=&quot;#单链表数据结构定义&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
