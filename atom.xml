<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>Siwat</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-03-23T13:21:21.449Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Napat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>位置式PID和增量式PID详解</title>
    <link href="http://example.com/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-23T13:12:04.000Z</published>
    <updated>2025-03-23T13:21:21.449Z</updated>
    
    <content type="html"><![CDATA[<h3 id="由浅入深总结PID控制器：从基础到应用"><a href="#由浅入深总结PID控制器：从基础到应用" class="headerlink" title="由浅入深总结PID控制器：从基础到应用"></a><strong>由浅入深总结PID控制器：从基础到应用</strong></h3><hr><h4 id="一、PID控制器的基本概念"><a href="#一、PID控制器的基本概念" class="headerlink" title="一、PID控制器的基本概念"></a><strong>一、PID控制器的基本概念</strong></h4><p><strong>1. 核心思想</strong><br>PID（比例-积分-微分）控制器通过动态调整系统输出，使实际值快速、稳定地跟踪目标值。其核心是<strong>误差驱动</strong>：</p><ul><li>**误差（e(t))**：目标值与实际值的差值。</li><li><strong>控制目标</strong>：最小化误差的瞬时值、累积值及变化趋势。</li></ul><p><strong>2. 三大组成部分</strong></p><ul><li><strong>比例（P）</strong>：根据当前误差调整输出，误差越大，响应越强。<ul><li><strong>公式</strong>：<img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211746971.png" alt="image-20250323211746971"></li><li><strong>作用</strong>：快速响应，但可能导致稳态误差或振荡。</li></ul></li><li><strong>积分（I）</strong>：累积历史误差，消除稳态误差。<ul><li><strong>公式</strong>：<img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211807881.png" alt="image-20250323211807881"></li><li><strong>作用</strong>：长期纠偏，但积分过强会导致超调或积分饱和。</li></ul></li><li><strong>微分（D）</strong>：预测误差变化趋势，抑制超调。<ul><li><strong>公式</strong>：<img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211823887.png" alt="image-20250323211823887"></li><li><strong>作用</strong>：提升稳定性，但对噪声敏感。</li></ul></li></ul><p><strong>3. 总输出公式</strong><img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211722143.png" alt="image-20250323211722143"></p><hr><h4 id="二、位置式PID：直接控制绝对值"><a href="#二、位置式PID：直接控制绝对值" class="headerlink" title="二、位置式PID：直接控制绝对值"></a><strong>二、位置式PID：直接控制绝对值</strong></h4><p><strong>1. 核心特点</strong></p><ul><li><strong>输出形式</strong>：直接输出控制量的绝对值（如设定电机转速为1000rpm）。</li><li><strong>积分处理</strong>：累加历史所有误差，长期记忆性强。</li><li><strong>公式（离散化）</strong>：<br><img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211903021.png" alt="image-20250323211903021"></li></ul><p><strong>2. 优点与缺点</strong></p><ul><li><strong>优点</strong>：响应快，适合需要直接设定绝对值的场景（如温度控制）。</li><li><strong>缺点</strong>：<ul><li><strong>积分饱和</strong>：执行机构受限时（如阀门全开），积分项持续累积，导致控制滞后。</li><li><strong>噪声敏感</strong>：微分项依赖单次差分，易放大高频噪声。</li></ul></li></ul><p><strong>3. 典型应用</strong></p><ul><li>恒温箱加热功率控制</li><li>阀门开度调节</li><li>机械臂关节角度控制</li></ul><p><strong>4. 改进技巧</strong></p><ul><li><strong>积分抗饱和</strong>：当执行机构达到极限时，冻结积分项累加。</li><li><strong>滤波处理</strong>：对微分项加入低通滤波器，抑制噪声。</li></ul><hr><h4 id="三、增量式PID：逐步调整变化量"><a href="#三、增量式PID：逐步调整变化量" class="headerlink" title="三、增量式PID：逐步调整变化量"></a><strong>三、增量式PID：逐步调整变化量</strong></h4><p><strong>1. 核心特点</strong></p><ul><li><p><strong>输出形式</strong>：输出控制量的增量（如“电机转速增加50rpm”）。</p></li><li><p><strong>积分处理</strong>：仅依赖当前误差，天然抗积分饱和。</p></li><li><p><strong>公式（离散化）</strong>：<br><img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211936553.png" alt="image-20250323211936553"></p><ul><li><strong>总控制量</strong>：<img src="/2025/03/23/%E4%BD%8D%E7%BD%AE%E5%BC%8FPID%E5%92%8C%E5%A2%9E%E9%87%8F%E5%BC%8FPID%E8%AF%A6%E8%A7%A3/image-20250323211951260.png" alt="image-20250323211951260"></li></ul></li><li><p><strong>优点</strong>：</p><ul><li><strong>抗饱和</strong>：无需长期累积误差，适合执行机构受限的场景。</li><li><strong>噪声抑制</strong>：微分项通过两次差分等效滤波，减少噪声影响。</li><li><strong>平滑输出</strong>：增量调整避免突变，适合步进电机等设备。</li></ul></li><li><p><strong>缺点</strong>：</p><ul><li>响应速度稍慢于位置式（需逐步累加）。</li><li>对参数变化敏感，需精细调参。</li></ul></li></ul><p><strong>3. 典型应用</strong></p><ul><li>步进电机位置控制</li><li>无人机舵面角度调节</li><li>电池充电电流平滑调整</li></ul><p><strong>4. 改进技巧</strong></p><ul><li><strong>增量限幅</strong>：限制单步增量幅度（如步进电机单步最多5个脉冲）。</li><li><strong>动态调参</strong>：根据误差大小调整参数（如接近目标时降低比例增益）。</li></ul><hr><h4 id="四、位置式-vs-增量式：核心对比"><a href="#四、位置式-vs-增量式：核心对比" class="headerlink" title="四、位置式 vs 增量式：核心对比"></a><strong>四、位置式 vs 增量式：核心对比</strong></h4><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>位置式PID</strong></th><th align="left"><strong>增量式PID</strong></th></tr></thead><tbody><tr><td align="left"><strong>输出形式</strong></td><td align="left">直接设定绝对值（如80%功率）</td><td align="left">输出增量（如+5%功率）</td></tr><tr><td align="left"><strong>积分处理</strong></td><td align="left">累加所有历史误差，易饱和</td><td align="left">仅依赖当前误差，抗饱和</td></tr><tr><td align="left"><strong>微分项噪声</strong></td><td align="left">敏感（单次差分）</td><td align="left">抑制（两次差分等效滤波）</td></tr><tr><td align="left"><strong>适用场景</strong></td><td align="left">温控、阀门等直接控制场景</td><td align="left">步进电机、舵机等需平滑调整场景</td></tr><tr><td align="left"><strong>代码复杂度</strong></td><td align="left">需存储积分累加值</td><td align="left">仅需存储最近2~3次误差</td></tr></tbody></table><hr><h4 id="五、如何选择PID形式？"><a href="#五、如何选择PID形式？" class="headerlink" title="五、如何选择PID形式？"></a><strong>五、如何选择PID形式？</strong></h4><ol><li><strong>选位置式PID</strong>：<ul><li>执行机构需直接设定绝对值（如加热器功率、阀门开度）。</li><li>系统允许输出突变，且需快速响应。</li><li><strong>示例</strong>：工业烤箱温度控制。</li></ul></li><li><strong>选增量式PID</strong>：<ul><li>执行机构需逐步调整（如步进电机、无人机舵机）。</li><li>系统对突变敏感，需抑制积分饱和或噪声。</li><li><strong>示例</strong>：3D打印机步进电机控制。</li></ul></li><li><strong>混合应用</strong>：<ul><li>在复杂系统中结合两者优势（如主控制用位置式，辅以增量式抗饱和）。</li></ul></li></ol><hr><h4 id="六、进阶技巧与注意事项"><a href="#六、进阶技巧与注意事项" class="headerlink" title="六、进阶技巧与注意事项"></a><strong>六、进阶技巧与注意事项</strong></h4><ol><li><strong>参数整定方法</strong>：<ul><li><strong>试凑法</strong>：手动调整参数，观察系统响应曲线。</li><li><strong>齐格勒-尼科尔斯法</strong>：通过临界振荡周期确定参数。</li><li><strong>仿真工具</strong>：使用MATLAB&#x2F;Simulink优化参数。</li></ul></li><li><strong>抗积分饱和策略</strong>：<ul><li><strong>Clamping法</strong>：当执行机构达到极限时，停止积分累加。</li><li><strong>Back-calculation</strong>：反向计算积分项，避免超调。</li></ul></li><li><strong>噪声处理</strong>：<ul><li>对传感器信号进行滤波（如移动平均滤波）。</li><li>在微分项中引入一阶低通滤波器。</li></ul></li><li><strong>动态适应</strong>：<ul><li>根据系统状态实时调整PID参数（如误差大时增大 Kp，接近目标时增大 Kd）。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;由浅入深总结PID控制器：从基础到应用&quot;&gt;&lt;a href=&quot;#由浅入深总结PID控制器：从基础到应用&quot; class=&quot;headerlink&quot; title=&quot;由浅入深总结PID控制器：从基础到应用&quot;&gt;&lt;/a&gt;&lt;strong&gt;由浅入深总结PID控制器：从基础到应用&lt;/</summary>
      
    
    
    
    
    <category term="PID" scheme="http://example.com/tags/PID/"/>
    
  </entry>
  
  <entry>
    <title>modbus详解</title>
    <link href="http://example.com/2025/03/23/modbus%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/23/modbus%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-23T06:54:36.000Z</published>
    <updated>2025-03-23T06:55:45.174Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Modbus-RTU-常用功能码详解（发送-amp-接收）"><a href="#Modbus-RTU-常用功能码详解（发送-amp-接收）" class="headerlink" title="Modbus RTU 常用功能码详解（发送 &amp; 接收）"></a><strong>Modbus RTU 常用功能码详解（发送 &amp; 接收）</strong></h2><p>Modbus RTU 采用主从架构（Master-Slave），主机（Master）发送请求，从机（Slave）响应数据。数据通过串口（RS-485&#x2F;RS-232）以 <strong>二进制格式</strong> 传输，并采用 <strong>CRC16</strong> 校验。</p><hr><h2 id="1-Modbus-RTU-通信格式"><a href="#1-Modbus-RTU-通信格式" class="headerlink" title="1. Modbus RTU 通信格式"></a><strong>1. Modbus RTU 通信格式</strong></h2><p>一个标准的 Modbus RTU 数据帧结构如下：</p><table><thead><tr><th>字节</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><strong>从机地址（Slave ID）</strong></td><td>1~247（0 号用于广播）</td></tr><tr><td>2</td><td><strong>功能码（Function Code）</strong></td><td>指定操作（读&#x2F;写寄存器等）</td></tr><tr><td>3~x</td><td><strong>数据字段（Data Field）</strong></td><td>读&#x2F;写的地址、数量、数据等</td></tr><tr><td>x+1, x+2</td><td><strong>CRC 校验（CRC Check）</strong></td><td>16 位 CRC-16 校验，低字节在前</td></tr></tbody></table><hr><h2 id="2-常用功能码"><a href="#2-常用功能码" class="headerlink" title="2. 常用功能码"></a><strong>2. 常用功能码</strong></h2><h3 id="📌-功能码-0x01-读线圈状态（Read-Coils）"><a href="#📌-功能码-0x01-读线圈状态（Read-Coils）" class="headerlink" title="📌 功能码 0x01 - 读线圈状态（Read Coils）"></a><strong>📌 功能码 0x01 - 读线圈状态（Read Coils）</strong></h3><blockquote><p>读取多个 <strong>开关量输出（DO）</strong> 的状态，每个线圈 1bit。</p></blockquote><h4 id="📤-发送请求"><a href="#📤-发送请求" class="headerlink" title="📤 发送请求"></a><strong>📤 发送请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  起始地址  线圈数量  CRC校验</span><br><span class="line">01       01    00 13    00 0A    0CD1</span><br></pre></td></tr></table></figure><ul><li><code>01</code> —— 从机地址 1</li><li><code>01</code> —— 功能码 0x01（读取线圈状态）</li><li><code>00 13</code> —— 起始地址 0x0013（第 19 号线圈）</li><li><code>00 0A</code> —— 读取 10 个线圈状态</li><li><code>0C D1</code> —— CRC 校验（低字节在前）</li></ul><h4 id="📥-响应数据"><a href="#📥-响应数据" class="headerlink" title="📥 响应数据"></a><strong>📥 响应数据</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  字节数  数据   CRC校验</span><br><span class="line">01       01    02    CD  6B   A1E3</span><br></pre></td></tr></table></figure><ul><li><code>02</code> —— 返回字节数 2（10 位线圈状态，按 8 位对齐）</li><li><code>CD</code>（11001101）—— 低 8 位（线圈 19-26）</li><li><code>6B</code>（01101011）—— 高 8 位（线圈 27-28，其余填 0）</li><li><code>A1 E3</code> —— CRC 校验</li></ul><hr><h3 id="📌-功能码-0x03-读保持寄存器（Read-Holding-Registers）"><a href="#📌-功能码-0x03-读保持寄存器（Read-Holding-Registers）" class="headerlink" title="📌 功能码 0x03 - 读保持寄存器（Read Holding Registers）"></a><strong>📌 功能码 0x03 - 读保持寄存器（Read Holding Registers）</strong></h3><blockquote><p>读取多个 <strong>保持寄存器（AO）</strong>，每个寄存器 16bit。</p></blockquote><h4 id="📤-发送请求-1"><a href="#📤-发送请求-1" class="headerlink" title="📤 发送请求"></a><strong>📤 发送请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  起始地址  寄存器数量  CRC校验</span><br><span class="line">01       03    00 10    00 02    C5 CD</span><br></pre></td></tr></table></figure><ul><li><code>01</code> —— 从机地址 1</li><li><code>03</code> —— 读取保持寄存器</li><li><code>00 10</code> —— 起始地址 0x0010（第 16 号寄存器）</li><li><code>00 02</code> —— 读取 2 个寄存器</li><li><code>C5 CD</code> —— CRC 校验</li></ul><h4 id="📥-响应数据-1"><a href="#📥-响应数据-1" class="headerlink" title="📥 响应数据"></a><strong>📥 响应数据</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  字节数  数据1  数据2  CRC校验</span><br><span class="line">01       03    04    00 64  27 10   72 30</span><br></pre></td></tr></table></figure><ul><li><code>04</code> —— 返回字节数 4（2 个寄存器，每个 2 字节）</li><li><code>00 64</code>（十进制 100）—— 第 16 号寄存器数据</li><li><code>27 10</code>（十进制 10000）—— 第 17 号寄存器数据</li><li><code>72 30</code> —— CRC 校验</li></ul><hr><h3 id="📌-功能码-0x06-写单个保持寄存器（Write-Single-Register）"><a href="#📌-功能码-0x06-写单个保持寄存器（Write-Single-Register）" class="headerlink" title="📌 功能码 0x06 - 写单个保持寄存器（Write Single Register）"></a><strong>📌 功能码 0x06 - 写单个保持寄存器（Write Single Register）</strong></h3><blockquote><p>设置 <strong>一个</strong> 保持寄存器的值。</p></blockquote><h4 id="📤-发送请求-2"><a href="#📤-发送请求-2" class="headerlink" title="📤 发送请求"></a><strong>📤 发送请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  寄存器地址  数据值   CRC校验</span><br><span class="line">01       06    00 20    00 64    09 E9</span><br></pre></td></tr></table></figure><ul><li><code>01</code> —— 从机地址 1</li><li><code>06</code> —— 写单个寄存器</li><li><code>00 20</code> —— 寄存器地址 0x0020（第 32 号寄存器）</li><li><code>00 64</code>（十进制 100）—— 要写入的数据</li><li><code>09 E9</code> —— CRC 校验</li></ul><h4 id="📥-响应数据-2"><a href="#📥-响应数据-2" class="headerlink" title="📥 响应数据"></a><strong>📥 响应数据</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  寄存器地址  数据值   CRC校验</span><br><span class="line">01       06    00 20    00 64    09 E9</span><br></pre></td></tr></table></figure><blockquote><p><strong>响应数据与请求相同，表示写入成功</strong></p></blockquote><hr><h3 id="📌-功能码-0x0F-写多个线圈（Write-Multiple-Coils）"><a href="#📌-功能码-0x0F-写多个线圈（Write-Multiple-Coils）" class="headerlink" title="📌 功能码 0x0F - 写多个线圈（Write Multiple Coils）"></a><strong>📌 功能码 0x0F - 写多个线圈（Write Multiple Coils）</strong></h3><blockquote><p>设置 <strong>多个</strong> 开关量输出（DO）。</p></blockquote><h4 id="📤-发送请求-3"><a href="#📤-发送请求-3" class="headerlink" title="📤 发送请求"></a><strong>📤 发送请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r复制编辑从机地址  功能码  起始地址  线圈数量  字节数  数据   CRC校验</span><br><span class="line">01       0F    00 13    00 0A    02    CD  01   5B  99</span><br></pre></td></tr></table></figure><ul><li><code>0F</code> —— 写多个线圈</li><li><code>00 13</code> —— 起始地址 0x0013（第 19 号线圈）</li><li><code>00 0A</code> —— 写入 10 个线圈</li><li><code>02</code> —— 数据字节数（10bit 需 2 字节存储）</li><li><code>CD 01</code> —— 线圈数据（11001101 00000001）</li><li><code>5B 99</code> —— CRC 校验</li></ul><h4 id="📥-响应数据-3"><a href="#📥-响应数据-3" class="headerlink" title="📥 响应数据"></a><strong>📥 响应数据</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r复制编辑从机地址  功能码  起始地址  线圈数量  CRC校验</span><br><span class="line">01       0F    00 13    00 0A    C4 4E</span><br></pre></td></tr></table></figure><blockquote><p><strong>表示从机确认已写入数据</strong></p></blockquote><hr><h3 id="📌-功能码-0x10-写多个保持寄存器（Write-Multiple-Registers）"><a href="#📌-功能码-0x10-写多个保持寄存器（Write-Multiple-Registers）" class="headerlink" title="📌 功能码 0x10 - 写多个保持寄存器（Write Multiple Registers）"></a><strong>📌 功能码 0x10 - 写多个保持寄存器（Write Multiple Registers）</strong></h3><blockquote><p>写入 <strong>多个</strong> 寄存器（AO）。</p></blockquote><h4 id="📤-发送请求-4"><a href="#📤-发送请求-4" class="headerlink" title="📤 发送请求"></a><strong>📤 发送请求</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  起始地址  寄存器数量  字节数  数据       CRC校验</span><br><span class="line">01       10    00 10    00 02    04    00 64  27 10   48 08</span><br></pre></td></tr></table></figure><ul><li><code>10</code> —— 写多个寄存器</li><li><code>00 10</code> —— 起始地址 0x0010（第 16 号寄存器）</li><li><code>00 02</code> —— 写入 2 个寄存器</li><li><code>04</code> —— 数据字节数 4</li><li><code>00 64 27 10</code> —— 数据（100、10000）</li><li><code>48 08</code> —— CRC 校验</li></ul><h4 id="📥-响应数据-4"><a href="#📥-响应数据-4" class="headerlink" title="📥 响应数据"></a><strong>📥 响应数据</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制编辑从机地址  功能码  起始地址  寄存器数量  CRC校验</span><br><span class="line">01       10    00 10    00 02    71 CB</span><br></pre></td></tr></table></figure><blockquote><p><strong>从机确认写入成功</strong></p></blockquote><hr><h2 id="3-Modbus-RTU-数据帧解析"><a href="#3-Modbus-RTU-数据帧解析" class="headerlink" title="3. Modbus RTU 数据帧解析"></a><strong>3. Modbus RTU 数据帧解析</strong></h2><p>Modbus RTU 采用 <strong>小端格式（Little Endian）</strong>：</p><ul><li><strong>CRC 校验</strong> 低字节在前</li><li><strong>多字节数据</strong> 高字节在前（Big Endian）</li></ul><p><strong>解析 Modbus 数据包的关键：</strong></p><ul><li>解析从机地址，判断是否匹配</li><li>解析功能码，决定操作类型</li><li>解析数据区，提取地址、值等信息</li><li>计算 CRC 校验，判断数据是否正确</li></ul><hr><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h2><table><thead><tr><th>功能码</th><th>作用</th><th>典型用途</th></tr></thead><tbody><tr><td>0x01</td><td>读线圈（DO）</td><td>读取开关状态</td></tr><tr><td>0x03</td><td>读保持寄存器（AO）</td><td>读取设备参数</td></tr><tr><td>0x06</td><td>写单个寄存器</td><td>修改设备设置</td></tr><tr><td>0x0F</td><td>写多个线圈</td><td>批量开关控制</td></tr><tr><td>0x10</td><td>写多个寄存器</td><td>批量参数修改</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Modbus-RTU-常用功能码详解（发送-amp-接收）&quot;&gt;&lt;a href=&quot;#Modbus-RTU-常用功能码详解（发送-amp-接收）&quot; class=&quot;headerlink&quot; title=&quot;Modbus RTU 常用功能码详解（发送 &amp;amp; 接收）&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="MODBUS" scheme="http://example.com/tags/MODBUS/"/>
    
  </entry>
  
  <entry>
    <title>RS485_RS232_RS422_TTL之间的区别</title>
    <link href="http://example.com/2025/03/23/RS485-RS232-RS422-TTL%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2025/03/23/RS485-RS232-RS422-TTL%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-03-23T06:21:04.000Z</published>
    <updated>2025-03-23T06:39:34.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RS-485、RS-232、RS-422和TTL的详解"><a href="#RS-485、RS-232、RS-422和TTL的详解" class="headerlink" title="RS-485、RS-232、RS-422和TTL的详解"></a>RS-485、RS-232、RS-422和TTL的详解</h2><p>以下是RS-485、RS-232、RS-422和TTL在表示二进制数据（0和1）时的详细对比：</p><hr><h3 id="1-TTL（Transistor-Transistor-Logic）"><a href="#1-TTL（Transistor-Transistor-Logic）" class="headerlink" title="1. TTL（Transistor-Transistor Logic）"></a><strong>1. TTL（Transistor-Transistor Logic）</strong></h3><h4 id="逻辑电平定义"><a href="#逻辑电平定义" class="headerlink" title="逻辑电平定义"></a><strong>逻辑电平定义</strong></h4><ul><li><strong>逻辑0（LOW）</strong>：<ul><li><strong>电压范围</strong>：0V ~ 0.8V（5V系统）或 0V ~ 0.4V（3.3V系统）</li><li><strong>典型场景</strong>：微控制器GPIO输出低电平，传感器信号接地。</li></ul></li><li><strong>逻辑1（HIGH）</strong>：<ul><li><strong>电压范围</strong>：2V ~ 5V（5V系统）或 1.7V ~ 3.3V（3.3V系统）</li><li><strong>典型场景</strong>：微控制器输出高电平，LED点亮信号。</li></ul></li></ul><h4 id="物理层特点"><a href="#物理层特点" class="headerlink" title="物理层特点"></a><strong>物理层特点</strong></h4><ul><li><p><strong>信号类型</strong>：单端电压信号（单线传输）</p></li><li><p><strong>传输方式</strong>：</p><ul><li><strong>单工</strong>：单向传输（如传感器到MCU）。</li><li><strong>半双工</strong>：同一线路分时双向传输（需协议控制方向）。</li></ul></li><li><p><strong>典型电路</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MCU_TX ----[电阻]----&gt; MCU_RX（直接连接，无电平转换）</span><br></pre></td></tr></table></figure></li><li><p><strong>关键问题</strong>：</p><ul><li><strong>电平兼容性</strong>：5V TTL与3.3V系统需电平转换（如分压电阻或缓冲器）。</li><li><strong>抗干扰差</strong>：长距离易受噪声影响，通常限制在1米以内。</li></ul></li></ul><hr><h3 id="2-RS-232"><a href="#2-RS-232" class="headerlink" title="2. RS-232"></a><strong>2. RS-232</strong></h3><h4 id="逻辑电平定义-1"><a href="#逻辑电平定义-1" class="headerlink" title="逻辑电平定义"></a><strong>逻辑电平定义</strong></h4><ul><li><strong>逻辑0（SPACE）</strong>：<ul><li><strong>电压范围</strong>：+3V ~ +15V（驱动端）</li><li><strong>接收阈值</strong>：&gt; +3V 识别为0。</li></ul></li><li><strong>逻辑1（MARK）</strong>：<ul><li><strong>电压范围</strong>：-3V ~ -15V（驱动端）</li><li><strong>接收阈值</strong>：&lt; -3V 识别为1。</li></ul></li></ul><h4 id="物理层特点-1"><a href="#物理层特点-1" class="headerlink" title="物理层特点"></a><strong>物理层特点</strong></h4><ul><li><p><strong>信号类型</strong>：单端负逻辑（高电压为0，低电压为1）。</p></li><li><p><strong>传输方式</strong>：</p><ul><li><strong>全双工</strong>：独立TX（发送）和RX（接收）线路。</li><li><strong>典型连接</strong>：DB9接口（如计算机串口）。</li></ul></li><li><p><strong>典型电路</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MCU_TX --[MAX232]--&gt; RS-232_TX  </span><br><span class="line">MCU_RX &lt;--[MAX232]-- RS-232_RX</span><br></pre></td></tr></table></figure></li><li><p><strong>关键问题</strong>：</p><ul><li><strong>电平转换</strong>：需专用芯片（如MAX232）转换TTL与RS-232电平。</li><li><strong>传输距离</strong>：最长15米（速率≤20kbps时）。</li></ul></li></ul><hr><h3 id="3-RS-422"><a href="#3-RS-422" class="headerlink" title="3. RS-422"></a><strong>3. RS-422</strong></h3><h4 id="逻辑电平定义-2"><a href="#逻辑电平定义-2" class="headerlink" title="逻辑电平定义"></a><strong>逻辑电平定义</strong></h4><ul><li><strong>逻辑1</strong>：<ul><li><strong>差分电压</strong>：B线电压 &gt; A线电压 +0.2V（典型差值±2V）。</li></ul></li><li><strong>逻辑0</strong>：<ul><li><strong>差分电压</strong>：A线电压 &gt; B线电压 +0.2V。</li></ul></li></ul><h4 id="物理层特点-2"><a href="#物理层特点-2" class="headerlink" title="物理层特点"></a><strong>物理层特点</strong></h4><ul><li><p><strong>信号类型</strong>：差分信号（两条线传输一个信号）。</p></li><li><p><strong>传输方式</strong>：</p><ul><li><strong>全双工</strong>：两对差分线（TX+&#x2F;- 和 RX+&#x2F;-）。</li><li><strong>拓扑结构</strong>：点对点或1发多收（最多10个接收器）。</li></ul></li><li><p><strong>典型电路</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Driver_A+ ---- 120Ω ---- Receiver_A+  </span><br><span class="line">Driver_A- ---- 120Ω ---- Receiver_A-</span><br></pre></td></tr></table></figure></li><li><p><strong>关键优势</strong>：</p><ul><li><strong>抗干扰</strong>：差分信号抵消共模噪声，适合工业环境。</li><li><strong>长距离</strong>：支持1200米（速率≤100kbps时）。</li></ul></li></ul><hr><h3 id="4-RS-485"><a href="#4-RS-485" class="headerlink" title="4. RS-485"></a><strong>4. RS-485</strong></h3><h4 id="逻辑电平定义-3"><a href="#逻辑电平定义-3" class="headerlink" title="逻辑电平定义"></a><strong>逻辑电平定义</strong></h4><ul><li><strong>逻辑1（Idle&#x2F;MARK）</strong>：<ul><li><strong>差分电压</strong>：B线电压 &gt; A线电压 +0.2V（典型差值±1.5V）。</li></ul></li><li><strong>逻辑0（Active&#x2F;SPACE）</strong>：<ul><li><strong>差分电压</strong>：A线电压 &gt; B线电压 +0.2V。</li></ul></li></ul><h4 id="物理层特点-3"><a href="#物理层特点-3" class="headerlink" title="物理层特点"></a><strong>物理层特点</strong></h4><ul><li><p><strong>信号类型</strong>：差分信号（半双工）或两对差分线（全双工）。</p></li><li><p><strong>传输方式</strong>：</p><ul><li><strong>半双工</strong>：单对差分线（A&#x2F;B），分时双向传输。</li><li><strong>全双工</strong>：两对差分线（需4线制）。</li></ul></li><li><p><strong>典型电路</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node1_A ----|  </span><br><span class="line">            |---- Bus_A ---- 120Ω终端电阻  </span><br><span class="line">Node1_B ----|  </span><br><span class="line">            |---- Bus_B ---- 120Ω终端电阻  </span><br><span class="line">Node2_A ----|  </span><br><span class="line">Node2_B ----|</span><br></pre></td></tr></table></figure></li><li><p><strong>关键配置</strong>：</p><ul><li><strong>终端电阻</strong>：总线两端需120Ω电阻，防止信号反射。</li><li><strong>偏置电阻</strong>：空闲时通过电阻拉高B线、拉低A线，避免总线悬空。</li></ul></li></ul><hr><h3 id="5-对比总结"><a href="#5-对比总结" class="headerlink" title="5. 对比总结"></a><strong>5. 对比总结</strong></h3><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>TTL</strong></th><th align="left"><strong>RS-232</strong></th><th align="left"><strong>RS-422</strong></th><th align="left"><strong>RS-485</strong></th></tr></thead><tbody><tr><td align="left"><strong>逻辑表示</strong></td><td align="left">单端电压</td><td align="left">单端负逻辑</td><td align="left">差分电压</td><td align="left">差分电压</td></tr><tr><td align="left"><strong>0的电压</strong></td><td align="left">0V~0.8V (5V)</td><td align="left">+3V~+15V</td><td align="left">A &gt; B +0.2V</td><td align="left">A &gt; B +0.2V</td></tr><tr><td align="left"><strong>1的电压</strong></td><td align="left">2V~5V (5V)</td><td align="left">-3V~-15V</td><td align="left">B &gt; A +0.2V</td><td align="left">B &gt; A +0.2V</td></tr><tr><td align="left"><strong>抗噪能力</strong></td><td align="left">弱</td><td align="left">中等</td><td align="left">强</td><td align="left">极强</td></tr><tr><td align="left"><strong>拓扑结构</strong></td><td align="left">点对点</td><td align="left">点对点</td><td align="left">1主多从</td><td align="left">多主多从总线</td></tr><tr><td align="left"><strong>最大节点数</strong></td><td align="left">1</td><td align="left">1</td><td align="left">10</td><td align="left">32~256</td></tr><tr><td align="left"><strong>典型应用</strong></td><td align="left">板级通信</td><td align="left">老式外设</td><td align="left">工业长距离点对点</td><td align="left">工业Modbus网络</td></tr></tbody></table><hr><h3 id="6-实际应用示例"><a href="#6-实际应用示例" class="headerlink" title="6. 实际应用示例"></a><strong>6. 实际应用示例</strong></h3><h4 id="TTL直接通信"><a href="#TTL直接通信" class="headerlink" title="TTL直接通信"></a><strong>TTL直接通信</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Arduino发送逻辑1（5V）</span><br><span class="line">digitalWrite(TX_PIN, HIGH);</span><br><span class="line">// 接收端检测</span><br><span class="line">if (digitalRead(RX_PIN) == HIGH) &#123; /* 处理逻辑1 */ &#125;</span><br></pre></td></tr></table></figure><h4 id="RS-485半双工控制"><a href="#RS-485半双工控制" class="headerlink" title="RS-485半双工控制"></a><strong>RS-485半双工控制</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 使用MAX485芯片控制收发</span><br><span class="line">void sendData(uint8_t *data, int len) &#123;</span><br><span class="line">    digitalWrite(DE_PIN, HIGH);  // 使能发送模式</span><br><span class="line">    delayMicroseconds(10);       // 等待芯片稳定</span><br><span class="line">    Serial.write(data, len);     // 发送数据</span><br><span class="line">    digitalWrite(DE_PIN, LOW);   // 切回接收模式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="RS-232电平转换"><a href="#RS-232电平转换" class="headerlink" title="RS-232电平转换"></a><strong>RS-232电平转换</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 使用MAX232芯片连接MCU与PC</span><br><span class="line">void setup() &#123;</span><br><span class="line">    Serial.begin(9600);         // MCU串口（TTL电平）</span><br><span class="line">    // MAX232自动转换电平到±10V</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-注意事项"><a href="#7-注意事项" class="headerlink" title="7. 注意事项"></a><strong>7. 注意事项</strong></h3><ul><li><strong>TTL电平兼容</strong>：<ul><li>5V TTL连接3.3V系统时，需串联330Ω电阻或使用电平转换器（如TXB0108）。</li></ul></li><li><strong>RS-485终端电阻</strong>：<ul><li>在总线两端并联120Ω电阻，位置尽量靠近线路末端。</li></ul></li><li><strong>RS-232地线</strong>：<ul><li>必须连接GND线，否则可能因共模电压损坏接口。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RS-485、RS-232、RS-422和TTL的详解&quot;&gt;&lt;a href=&quot;#RS-485、RS-232、RS-422和TTL的详解&quot; class=&quot;headerlink&quot; title=&quot;RS-485、RS-232、RS-422和TTL的详解&quot;&gt;&lt;/a&gt;RS-48</summary>
      
    
    
    
    
    <category term="RS485" scheme="http://example.com/tags/RS485/"/>
    
  </entry>
  
  <entry>
    <title>FreeRTOS锁机制实现互斥资源访问</title>
    <link href="http://example.com/2025/03/23/FreeRTOS%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/"/>
    <id>http://example.com/2025/03/23/FreeRTOS%E9%94%81%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE/</id>
    <published>2025-03-23T04:32:49.000Z</published>
    <updated>2025-03-23T04:34:01.301Z</updated>
    
    <content type="html"><![CDATA[<p>在FreeRTOS中实现锁机制（即互斥访问共享资源）主要通过<strong>互斥锁（Mutex）</strong> 和 <strong>信号量（Semaphore）</strong> 实现。以下是具体实现方法及示例：</p><hr><h3 id="一、使用互斥锁（Mutex）"><a href="#一、使用互斥锁（Mutex）" class="headerlink" title="一、使用互斥锁（Mutex）"></a>一、使用互斥锁（Mutex）</h3><p>互斥锁是专为资源互斥访问设计的机制，支持优先级继承（防止优先级反转问题），是保护共享资源的最佳选择。</p><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>创建互斥锁</strong><br>使用 <code>xSemaphoreCreateMutex()</code> 创建互斥锁句柄。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xMutex = xSemaphoreCreateMutex();</span><br></pre></td></tr></table></figure></li><li><p><strong>获取锁（在访问资源前）</strong><br>使用 <code>xSemaphoreTake()</code> 获取锁，若锁已被占用，任务将阻塞等待（可设置超时时间）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (xSemaphoreTake(xMutex, pdMS_TO_TICKS(100)) == pdTRUE) &#123;</span><br><span class="line">    // 成功获取锁，访问共享资源</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 超时处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>释放锁（在访问资源后）</strong><br>使用 <code>xSemaphoreGive()</code> 释放锁，允许其他任务获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreGive(xMutex);</span><br></pre></td></tr></table></figure></li></ol><h4 id="完整示例："><a href="#完整示例：" class="headerlink" title="完整示例："></a>完整示例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;FreeRTOS.h&quot;</span><br><span class="line">#include &quot;semphr.h&quot;</span><br><span class="line"></span><br><span class="line">SemaphoreHandle_t xMutex;</span><br><span class="line"></span><br><span class="line">void Task1(void *pvParam) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (xSemaphoreTake(xMutex, portMAX_DELAY)) &#123;</span><br><span class="line">            // 访问共享资源（如UART、全局变量等）</span><br><span class="line">            printf(&quot;Task1 is using the resource.\n&quot;);</span><br><span class="line">            xSemaphoreGive(xMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(1000));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Task2(void *pvParam) &#123;</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        if (xSemaphoreTake(xMutex, portMAX_DELAY)) &#123;</span><br><span class="line">            // 访问共享资源</span><br><span class="line">            printf(&quot;Task2 is using the resource.\n&quot;);</span><br><span class="line">            xSemaphoreGive(xMutex);</span><br><span class="line">        &#125;</span><br><span class="line">        vTaskDelay(pdMS_TO_TICKS(500));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    xMutex = xSemaphoreCreateMutex();</span><br><span class="line">    xTaskCreate(Task1, &quot;Task1&quot;, configMINIMAL_STACK_SIZE, NULL, 2, NULL);</span><br><span class="line">    xTaskCreate(Task2, &quot;Task2&quot;, configMINIMAL_STACK_SIZE, NULL, 1, NULL);</span><br><span class="line">    vTaskStartScheduler();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="二、使用二进制信号量（Binary-Semaphore）"><a href="#二、使用二进制信号量（Binary-Semaphore）" class="headerlink" title="二、使用二进制信号量（Binary Semaphore）"></a>二、使用二进制信号量（Binary Semaphore）</h3><p>二进制信号量也可用于互斥，但<strong>无优先级继承机制</strong>，可能导致优先级反转问题，仅适用于简单场景。</p><h4 id="实现步骤：-1"><a href="#实现步骤：-1" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>创建信号量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xSemaphore = xSemaphoreCreateBinary();</span><br><span class="line">xSemaphoreGive(xSemaphore); // 初始化为可用状态</span><br></pre></td></tr></table></figure></li><li><p><strong>获取与释放信号量</strong><br>类似互斥锁，使用 <code>xSemaphoreTake()</code> 和 <code>xSemaphoreGive()</code>。</p></li></ol><hr><h3 id="三、递归锁（Recursive-Mutex）"><a href="#三、递归锁（Recursive-Mutex）" class="headerlink" title="三、递归锁（Recursive Mutex）"></a>三、递归锁（Recursive Mutex）</h3><p>允许同一任务多次获取锁而不死锁，适用于递归函数或嵌套调用。</p><h4 id="实现步骤：-2"><a href="#实现步骤：-2" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>创建递归锁</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SemaphoreHandle_t xRecursiveMutex = xSemaphoreCreateRecursiveMutex();</span><br></pre></td></tr></table></figure></li><li><p><strong>递归获取与释放</strong><br>使用 <code>xSemaphoreTakeRecursive()</code> 和 <code>xSemaphoreGiveRecursive()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xSemaphoreTakeRecursive(xRecursiveMutex, portMAX_DELAY);</span><br><span class="line">// 嵌套调用中再次获取</span><br><span class="line">xSemaphoreTakeRecursive(xRecursiveMutex, portMAX_DELAY);</span><br><span class="line">xSemaphoreGiveRecursive(xRecursiveMutex);</span><br><span class="line">xSemaphoreGiveRecursive(xRecursiveMutex);</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="四、关键注意事项"><a href="#四、关键注意事项" class="headerlink" title="四、关键注意事项"></a>四、关键注意事项</h3><ol><li><strong>优先级继承</strong><br>互斥锁（Mutex）支持优先级继承，能自动提升低优先级任务的优先级以缩短阻塞时间，避免优先级反转。</li><li><strong>中断服务程序（ISR）中的锁</strong><br>在ISR中需使用 <code>xSemaphoreTakeFromISR()</code> 和 <code>xSemaphoreGiveFromISR()</code>，且不能阻塞。</li><li><strong>死锁预防</strong><ul><li>确保获取锁后一定会释放。</li><li>避免多锁嵌套（如先锁A再锁B，其他任务反之可能导致死锁）。</li></ul></li></ol><hr><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><ul><li><strong>推荐使用互斥锁（Mutex）</strong> 保护共享资源，因其支持优先级继承。</li><li>避免在中断中使用普通互斥锁，优先考虑信号量或任务通知。</li><li>递归锁适用于嵌套资源访问场景。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在FreeRTOS中实现锁机制（即互斥访问共享资源）主要通过&lt;strong&gt;互斥锁（Mutex）&lt;/strong&gt; 和 &lt;strong&gt;信号量（Semaphore）&lt;/strong&gt; 实现。以下是具体实现方法及示例：&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、使用互斥锁（Mut</summary>
      
    
    
    
    
    <category term="FreeRTOS" scheme="http://example.com/tags/FreeRTOS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_tls握手中证书验证与密钥交换详解</title>
    <link href="http://example.com/2025/03/19/esp32-tls%E6%8F%A1%E6%89%8B%E4%B8%AD%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/19/esp32-tls%E6%8F%A1%E6%89%8B%E4%B8%AD%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E4%B8%8E%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-19T14:44:17.000Z</published>
    <updated>2025-03-19T14:44:39.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESP32-TLS-握手中证书验证与密钥交换详解"><a href="#ESP32-TLS-握手中证书验证与密钥交换详解" class="headerlink" title="ESP32 TLS 握手中证书验证与密钥交换详解"></a><strong>ESP32 TLS 握手中证书验证与密钥交换详解</strong></h2><p>在 TLS（Transport Layer Security）握手中，<strong>证书验证</strong> 和 <strong>密钥交换</strong> 是确保通信安全的两个关键环节。以下将结合 <code>mbedTLS</code> 源码及 ESP32 实际应用，深入剖析这两个步骤的具体机制、代码实现以及关键点。</p><h1 id="证书传输与验证（Certificate-amp-Verify）"><a href="#证书传输与验证（Certificate-amp-Verify）" class="headerlink" title="证书传输与验证（Certificate &amp; Verify）"></a><strong>证书传输与验证（Certificate &amp; Verify）</strong></h1><p>服务器在 <code>ServerHello</code> 后发送 <code>Certificate</code> 消息，客户端（ESP32）需完成以下验证：</p><p> ✅ <strong>证书链完整性</strong>（是否存在缺失证书）<br> ✅ <strong>签名有效性</strong>（验证签名是否匹配）<br> ✅ <strong>证书有效期</strong>（检查过期时间）<br> ✅ <strong>域名匹配</strong>（确保证书的 CN 字段与服务器域名一致）<br> ✅ <strong>吊销检查</strong>（可选，通过 OCSP&#x2F;CRL 检查证书状态）</p><hr><h2 id="📋-Step-3-证书验证流程-mbedTLS"><a href="#📋-Step-3-证书验证流程-mbedTLS" class="headerlink" title="📋 Step 3 证书验证流程 (mbedTLS)"></a><strong>📋 Step 3 证书验证流程 (mbedTLS)</strong></h2><p>mbedTLS 内部的证书验证过程包括以下关键步骤：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 接收并解析 Certificate 消息</span><br><span class="line">2. 验证证书链完整性</span><br><span class="line">3. 验证证书签名 (RSA/ECDSA)</span><br><span class="line">4. 验证证书有效期</span><br><span class="line">5. 验证域名匹配 (Host Name)</span><br><span class="line">6. 生成验证结果 (成功/失败)</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-1-接收并解析-Certificate-消息"><a href="#🟢-1-接收并解析-Certificate-消息" class="headerlink" title="🟢 1. 接收并解析 Certificate 消息"></a><strong>🟢 1. 接收并解析 Certificate 消息</strong></h3><p>在 ESP32 的 <code>mbedtls_ssl_handshake()</code> 中，<code>Certificate</code> 消息解析由以下代码触发：</p><p>🔹 <strong><code>ssl_tls.c</code> 内部流程</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">if ( ( ret = mbedtls_ssl_parse_certificate( ssl ) ) != 0 )</span><br><span class="line">&#123;</span><br><span class="line">    MBEDTLS_SSL_DEBUG_RET( 1, &quot;mbedtls_ssl_parse_certificate&quot;, ret );</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>mbedtls_ssl_parse_certificate()</code> 接收服务器证书链</li><li>证书链将存储在 <code>mbedtls_x509_crt</code> 结构体中</li></ul><hr><h3 id="🟢-2-验证证书链完整性"><a href="#🟢-2-验证证书链完整性" class="headerlink" title="🟢 2. 验证证书链完整性"></a><strong>🟢 2. 验证证书链完整性</strong></h3><p><code>mbedtls_x509_crt_verify()</code> 用于验证服务器提供的证书链。其核心步骤包括：</p><p>✅ 检查证书是否被 CA 签名<br> ✅ 遍历证书链并检查每个证书的父子关系<br> ✅ 确保链条最终指向可信根证书</p><p><strong>代码示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">uint32_t flags;</span><br><span class="line">ret = mbedtls_x509_crt_verify(</span><br><span class="line">    &amp;crt,           // 服务器提供的证书链</span><br><span class="line">    &amp;cacert,        // 本地加载的根证书</span><br><span class="line">    NULL,           // CRL (可选)</span><br><span class="line">    &quot;example.com&quot;,  // 验证的服务器域名</span><br><span class="line">    &amp;flags,         // 验证结果标志</span><br><span class="line">    NULL, NULL      // 日志输出 (可选)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-3-验证签名-RSA-x2F-ECDSA"><a href="#🟢-3-验证签名-RSA-x2F-ECDSA" class="headerlink" title="🟢 3. 验证签名 (RSA&#x2F;ECDSA)"></a><strong>🟢 3. 验证签名 (RSA&#x2F;ECDSA)</strong></h3><p>在 <code>mbedtls_x509_crt_verify()</code> 中，签名验证的核心代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">ret = mbedtls_pk_verify(</span><br><span class="line">    &amp;crt-&gt;pk,            // 证书公钥</span><br><span class="line">    MBEDTLS_MD_SHA256,   // 签名使用的哈希算法</span><br><span class="line">    hash, hash_len,      // 待验证的哈希值</span><br><span class="line">    sig, sig_len         // 证书中的签名</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>mbedtls_pk_verify()</code> 确保服务器提供的签名与证书内容匹配</li><li>常见签名算法包括：<strong>RSA</strong>、<strong>ECDSA</strong></li></ul><hr><h3 id="🟢-4-验证证书有效期"><a href="#🟢-4-验证证书有效期" class="headerlink" title="🟢 4. 验证证书有效期"></a><strong>🟢 4. 验证证书有效期</strong></h3><p><code>mbedtls_x509_time_is_past()</code> 和 <code>mbedtls_x509_time_is_future()</code> 用于检查时间有效性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">if ( mbedtls_x509_time_is_past(&amp;crt-&gt;valid_to) ) &#123;</span><br><span class="line">    ESP_LOGE(TAG, &quot;证书已过期&quot;);</span><br><span class="line">    return MBEDTLS_ERR_X509_CERT_VERIFY_FAILED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ( mbedtls_x509_time_is_future(&amp;crt-&gt;valid_from) ) &#123;</span><br><span class="line">    ESP_LOGE(TAG, &quot;证书尚未生效&quot;);</span><br><span class="line">    return MBEDTLS_ERR_X509_CERT_VERIFY_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-5-验证域名匹配"><a href="#🟢-5-验证域名匹配" class="headerlink" title="🟢 5. 验证域名匹配"></a><strong>🟢 5. 验证域名匹配</strong></h3><p>ESP32 检查证书中的 <code>Common Name (CN)</code> 字段是否匹配：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">ret = mbedtls_ssl_set_hostname(&amp;ssl, &quot;example.com&quot;);  // 目标服务器域名</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-6-生成验证结果"><a href="#🟢-6-生成验证结果" class="headerlink" title="🟢 6. 生成验证结果"></a><strong>🟢 6. 生成验证结果</strong></h3><p>如果 <code>flags == 0</code>，表示验证成功；否则，验证失败。</p><hr><h2 id="🧩-证书验证失败的常见错误码"><a href="#🧩-证书验证失败的常见错误码" class="headerlink" title="🧩 证书验证失败的常见错误码"></a><strong>🧩 证书验证失败的常见错误码</strong></h2><table><thead><tr><th>错误码</th><th>含义</th></tr></thead><tbody><tr><td><code>MBEDTLS_ERR_X509_CERT_VERIFY_FAILED</code></td><td>证书链验证失败</td></tr><tr><td><code>MBEDTLS_ERR_X509_CERT_EXPIRED</code></td><td>证书已过期</td></tr><tr><td><code>MBEDTLS_ERR_X509_CERT_REVOKED</code></td><td>证书已吊销</td></tr><tr><td><code>MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT</code></td><td>证书格式错误</td></tr></tbody></table><hr><h1 id="🔹-Step-4：密钥交换（Key-Exchange）"><a href="#🔹-Step-4：密钥交换（Key-Exchange）" class="headerlink" title="🔹 Step 4：密钥交换（Key Exchange）"></a><strong>🔹 Step 4：密钥交换（Key Exchange）</strong></h1><p>密钥交换是 TLS 握手中最核心的安全机制，负责生成对称密钥，以便双方加密数据传输。mbedTLS 中支持以下几种密钥交换算法：</p><p>✅ <strong>RSA (最常见，较慢，适用于兼容性强的环境)</strong><br> ✅ <strong>ECDHE (更安全，性能更佳，推荐使用)</strong><br> ✅ <strong>PSK (预共享密钥，适用于 IoT 设备)</strong></p><hr><h2 id="📋-Step-4-密钥交换流程-mbedTLS"><a href="#📋-Step-4-密钥交换流程-mbedTLS" class="headerlink" title="📋 Step 4 密钥交换流程 (mbedTLS)"></a><strong>📋 Step 4 密钥交换流程 (mbedTLS)</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端生成随机数 Random_C</span><br><span class="line">2. 服务器生成随机数 Random_S</span><br><span class="line">3. 双方协商密钥交换算法 (如 ECDHE)</span><br><span class="line">4. 生成共享密钥 (Pre-Master Secret)</span><br><span class="line">5. 生成对称密钥 (Master Secret)</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-1-生成随机数-Random-C-amp-Random-S"><a href="#🟢-1-生成随机数-Random-C-amp-Random-S" class="headerlink" title="🟢 1. 生成随机数 (Random_C &amp; Random_S)"></a><strong>🟢 1. 生成随机数 (Random_C &amp; Random_S)</strong></h3><p>ESP32 在 <code>mbedtls_ssl_handshake()</code> 内部自动完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ssl_conf_rng(&amp;conf, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-2-协商密钥交换算法"><a href="#🟢-2-协商密钥交换算法" class="headerlink" title="🟢 2. 协商密钥交换算法"></a><strong>🟢 2. 协商密钥交换算法</strong></h3><p><code>mbedtls_ssl_handshake()</code> 根据服务器的 <code>ServerHello</code> 选择合适的加密套件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-3-生成共享密钥-Pre-Master-Secret"><a href="#🟢-3-生成共享密钥-Pre-Master-Secret" class="headerlink" title="🟢 3. 生成共享密钥 (Pre-Master Secret)"></a><strong>🟢 3. 生成共享密钥 (Pre-Master Secret)</strong></h3><p>若使用 ECDHE：</p><ul><li>客户端发送其公钥 (ClientKeyExchange)</li><li>服务器生成共享密钥 (Pre-Master Secret)</li></ul><p><strong>ECDHE 生成密钥示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_context ecdh;</span><br><span class="line">mbedtls_ecdh_gen_public(&amp;ecdh.grp, &amp;ecdh.d, &amp;ecdh.Q, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-4-生成对称密钥-Master-Secret"><a href="#🟢-4-生成对称密钥-Master-Secret" class="headerlink" title="🟢 4. 生成对称密钥 (Master Secret)"></a><strong>🟢 4. 生成对称密钥 (Master Secret)</strong></h3><p>客户端和服务器使用以下公式生成最终的 <code>Master Secret</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">Master Secret = PRF(Pre-Master Secret + Random_C + Random_S)</span><br></pre></td></tr></table></figure><p><code>PRF()</code> 通常使用 <code>HMAC-SHA256</code> 算法。</p><hr><h3 id="🟢-5-导出对称加密密钥"><a href="#🟢-5-导出对称加密密钥" class="headerlink" title="🟢 5. 导出对称加密密钥"></a><strong>🟢 5. 导出对称加密密钥</strong></h3><p>最终用于加密数据的密钥由 <code>mbedtls_ssl_derive_keys()</code> 生成。</p><hr><h2 id="🧩-密钥交换失败的常见错误码"><a href="#🧩-密钥交换失败的常见错误码" class="headerlink" title="🧩 密钥交换失败的常见错误码"></a><strong>🧩 密钥交换失败的常见错误码</strong></h2><table><thead><tr><th>错误码</th><th>含义</th></tr></thead><tbody><tr><td><code>MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE</code></td><td>握手失败</td></tr><tr><td><code>MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY</code></td><td>服务器主动断开连接</td></tr><tr><td><code>MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN</code></td><td>没有匹配的加密套件</td></tr></tbody></table><hr><h1 id="🔎-总结"><a href="#🔎-总结" class="headerlink" title="🔎 总结"></a><strong>🔎 总结</strong></h1><p>✅ <strong>Step 3：证书验证</strong></p><ul><li>验证证书链的完整性</li><li>验证证书签名的合法性</li><li>检查证书有效期和域名匹配</li></ul><p>✅ <strong>Step 4：密钥交换</strong></p><ul><li>协商密钥交换算法</li><li>生成共享密钥</li><li>使用 <code>Master Secret</code> 生成会话密钥，确保加密通信的安全性</li></ul><p>这两个步骤是 TLS 握手中最核心的环节，理解它们的机制有助于快速调试 ESP32 HTTPS 应用中的安全问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ESP32-TLS-握手中证书验证与密钥交换详解&quot;&gt;&lt;a href=&quot;#ESP32-TLS-握手中证书验证与密钥交换详解&quot; class=&quot;headerlink&quot; title=&quot;ESP32 TLS 握手中证书验证与密钥交换详解&quot;&gt;&lt;/a&gt;&lt;strong&gt;ESP32 </summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_tls密钥交换详解</title>
    <link href="http://example.com/2025/03/19/esp32-tls%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/19/esp32-tls%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-19T14:43:27.000Z</published>
    <updated>2025-03-19T14:44:04.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESP32-TLS-握手中的密钥交换机制详解"><a href="#ESP32-TLS-握手中的密钥交换机制详解" class="headerlink" title="ESP32 TLS 握手中的密钥交换机制详解"></a><strong>ESP32 TLS 握手中的密钥交换机制详解</strong></h2><p>在 TLS 握手过程中，密钥交换是最核心的环节之一，负责生成共享密钥以实现安全的加密通信。ESP32 使用 <code>mbedTLS</code> 来实现密钥交换，支持多种加密算法（如 RSA、ECDHE、PSK 等）。</p><p>本文将结合 TLS 1.2 标准，深入讲解 <strong>密钥交换机制</strong> 的原理、具体步骤及 <code>mbedTLS</code> 的代码实现。</p><h1 id="🔹-一、密钥交换的目标"><a href="#🔹-一、密钥交换的目标" class="headerlink" title="🔹 一、密钥交换的目标"></a><strong>🔹 一、密钥交换的目标</strong></h1><p>密钥交换的主要目的是在客户端和服务器之间安全地生成并共享一个 <strong>对称密钥</strong>，用于加密通信内容。</p><h3 id="🎯-关键目标"><a href="#🎯-关键目标" class="headerlink" title="🎯 关键目标"></a>🎯 <strong>关键目标</strong></h3><p>✅ 生成双方共享的密钥，确保数据机密性<br> ✅ 防止中间人攻击（MitM）<br> ✅ 支持前向安全性（Forward Secrecy）</p><h1 id="🔹-二、常见密钥交换算法"><a href="#🔹-二、常见密钥交换算法" class="headerlink" title="🔹 二、常见密钥交换算法"></a><strong>🔹 二、常见密钥交换算法</strong></h1><p><code>mbedTLS</code> 支持多种密钥交换算法，常见的包括：</p><table><thead><tr><th><strong>算法</strong></th><th><strong>说明</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><strong>RSA</strong></td><td>使用 RSA 公钥加密 Pre-Master Secret</td><td>性能较低，兼容性好</td></tr><tr><td><strong>ECDHE</strong></td><td>使用椭圆曲线 Diffie-Hellman（推荐）</td><td>安全性高，性能优越</td></tr><tr><td><strong>PSK</strong></td><td>预共享密钥 (Pre-Shared Key)</td><td>无需证书，适用于 IoT 设备</td></tr></tbody></table><blockquote><p>🔹 <strong>推荐使用 ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)</strong><br>相比 RSA，ECDHE 具有更好的性能和更强的安全性，ESP-IDF 默认推荐 ECDHE。</p></blockquote><h1 id="🔹-三、ECDHE-密钥交换原理详解"><a href="#🔹-三、ECDHE-密钥交换原理详解" class="headerlink" title="🔹 三、ECDHE 密钥交换原理详解"></a><strong>🔹 三、ECDHE 密钥交换原理详解</strong></h1><p>以 <strong>ECDHE (Elliptic Curve Diffie-Hellman Ephemeral)</strong> 为例，详细讲解密钥交换过程。</p><hr><h2 id="📋-ECDHE-密钥交换流程"><a href="#📋-ECDHE-密钥交换流程" class="headerlink" title="📋 ECDHE 密钥交换流程"></a><strong>📋 ECDHE 密钥交换流程</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 客户端生成临时密钥对 (ephemeral key pair)</span><br><span class="line">2. 服务器生成临时密钥对</span><br><span class="line">3. 客户端将其公钥发送至服务器</span><br><span class="line">4. 服务器将其公钥返回客户端</span><br><span class="line">5. 客户端和服务器分别计算共享密钥 (Pre-Master Secret)</span><br><span class="line">6. 双方使用 PRF (伪随机函数) 生成 Master Secret</span><br></pre></td></tr></table></figure><h2 id="🔹-Step-1：客户端生成临时密钥对"><a href="#🔹-Step-1：客户端生成临时密钥对" class="headerlink" title="🔹 Step 1：客户端生成临时密钥对"></a><strong>🔹 Step 1：客户端生成临时密钥对</strong></h2><p>客户端通过以下步骤生成临时密钥对：</p><ul><li>选择椭圆曲线参数 <code>G</code></li><li>随机生成私钥 <code>d_C</code></li><li>计算公钥 <code>Q_C = d_C * G</code></li></ul><p><strong>mbedTLS 代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_context ecdh;</span><br><span class="line">mbedtls_ecdh_init(&amp;ecdh);</span><br><span class="line"></span><br><span class="line">// 选择椭圆曲线 SECP256R1 (推荐)</span><br><span class="line">mbedtls_ecp_group_load(&amp;ecdh.grp, MBEDTLS_ECP_DP_SECP256R1);</span><br><span class="line"></span><br><span class="line">// 生成私钥 d_C 并计算公钥 Q_C</span><br><span class="line">mbedtls_ecdh_gen_public(&amp;ecdh.grp, &amp;ecdh.d, &amp;ecdh.Q,</span><br><span class="line">                        mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-Step-2：服务器生成临时密钥对"><a href="#🔹-Step-2：服务器生成临时密钥对" class="headerlink" title="🔹 Step 2：服务器生成临时密钥对"></a><strong>🔹 Step 2：服务器生成临时密钥对</strong></h2><p>服务器生成密钥对的步骤类似：</p><ul><li>选择相同的椭圆曲线参数 <code>G</code></li><li>随机生成私钥 <code>d_S</code></li><li>计算公钥 <code>Q_S = d_S * G</code></li></ul><p><strong>mbedTLS 代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_gen_public(&amp;ecdh.grp, &amp;ecdh.d, &amp;ecdh.Q,</span><br><span class="line">                        mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-Step-3：客户端发送公钥"><a href="#🔹-Step-3：客户端发送公钥" class="headerlink" title="🔹 Step 3：客户端发送公钥"></a><strong>🔹 Step 3：客户端发送公钥</strong></h2><p>客户端将 <code>Q_C</code> 发送至服务器（ClientKeyExchange 消息）。</p><p><strong>mbedTLS 内部实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">ret = mbedtls_ssl_write(&amp;ssl, client_public_key, key_len);</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-Step-4：服务器发送公钥"><a href="#🔹-Step-4：服务器发送公钥" class="headerlink" title="🔹 Step 4：服务器发送公钥"></a><strong>🔹 Step 4：服务器发送公钥</strong></h2><p>服务器将 <code>Q_S</code> 发送回客户端（ServerKeyExchange 消息）。</p><p><strong>mbedTLS 内部实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">ret = mbedtls_ssl_write(&amp;ssl, server_public_key, key_len);</span><br></pre></td></tr></table></figure><hr><h2 id="🔹-Step-5：生成共享密钥-Pre-Master-Secret"><a href="#🔹-Step-5：生成共享密钥-Pre-Master-Secret" class="headerlink" title="🔹 Step 5：生成共享密钥 (Pre-Master Secret)"></a><strong>🔹 Step 5：生成共享密钥 (Pre-Master Secret)</strong></h2><p>客户端与服务器使用对方的公钥及自己的私钥生成共享密钥：</p><h3 id="🔹-客户端计算共享密钥："><a href="#🔹-客户端计算共享密钥：" class="headerlink" title="🔹 客户端计算共享密钥："></a>🔹 <strong>客户端计算共享密钥：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">Z = d_C * Q_S</span><br></pre></td></tr></table></figure><h3 id="🔹-服务器计算共享密钥："><a href="#🔹-服务器计算共享密钥：" class="headerlink" title="🔹 服务器计算共享密钥："></a>🔹 <strong>服务器计算共享密钥：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ini</span><br><span class="line">Z = d_S * Q_C</span><br></pre></td></tr></table></figure><p><strong>mbedTLS 代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_compute_shared(</span><br><span class="line">    &amp;ecdh.grp,       // 椭圆曲线参数</span><br><span class="line">    &amp;ecdh.z,         // 共享密钥 (Pre-Master Secret)</span><br><span class="line">    &amp;ecdh.Qp,        // 对方公钥 (服务器公钥)</span><br><span class="line">    &amp;ecdh.d,         // 本地私钥 (客户端私钥)</span><br><span class="line">    mbedtls_ctr_drbg_random, &amp;ctr_drbg</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>🔹 根据椭圆曲线 Diffie-Hellman 的数学特性：<br><code>d_C * Q_S = d_S * Q_C = Z</code></p></blockquote><p>✅ 双方共享密钥 <code>Z</code> 一致<br> ✅ 外界无法从 <code>Q_C</code> 和 <code>Q_S</code> 反推 <code>Z</code>，确保安全性</p><hr><h2 id="🔹-Step-6：生成会话密钥-Master-Secret"><a href="#🔹-Step-6：生成会话密钥-Master-Secret" class="headerlink" title="🔹 Step 6：生成会话密钥 (Master Secret)"></a><strong>🔹 Step 6：生成会话密钥 (Master Secret)</strong></h2><p>共享密钥 <code>Z</code> 仅用于临时数据交换。ESP32 使用 <code>Z</code>、<code>Random_C</code>、<code>Random_S</code> 进一步生成 <code>Master Secret</code>。</p><p><strong>公式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java</span><br><span class="line">Master Secret = PRF(Pre-Master Secret + Random_C + Random_S)</span><br></pre></td></tr></table></figure><blockquote><p><code>PRF()</code> 通常使用 <code>HMAC-SHA256</code> 算法。</p></blockquote><p><strong>mbedTLS 代码实现：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ssl_derive_keys(&amp;ssl);</span><br></pre></td></tr></table></figure><hr><h1 id="🔹-四、密钥交换过程中的安全保障"><a href="#🔹-四、密钥交换过程中的安全保障" class="headerlink" title="🔹 四、密钥交换过程中的安全保障"></a><strong>🔹 四、密钥交换过程中的安全保障</strong></h1><h3 id="🔒-1-前向安全性-Forward-Secrecy"><a href="#🔒-1-前向安全性-Forward-Secrecy" class="headerlink" title="🔒 1. 前向安全性 (Forward Secrecy)"></a>🔒 <strong>1. 前向安全性 (Forward Secrecy)</strong></h3><ul><li>即便服务器的私钥泄露，攻击者也无法解密之前的通信数据。</li><li>ECDHE 使用临时密钥对，每次会话重新生成，确保前向安全性。</li></ul><h3 id="🔒-2-防止中间人攻击-MitM"><a href="#🔒-2-防止中间人攻击-MitM" class="headerlink" title="🔒 2. 防止中间人攻击 (MitM)"></a>🔒 <strong>2. 防止中间人攻击 (MitM)</strong></h3><ul><li>服务器使用证书签名其公钥，确保其身份的合法性。</li><li>客户端验证证书的有效性，以防止伪装。</li></ul><hr><h1 id="🔹-五、常见密钥交换相关问题及解决方案"><a href="#🔹-五、常见密钥交换相关问题及解决方案" class="headerlink" title="🔹 五、常见密钥交换相关问题及解决方案"></a><strong>🔹 五、常见密钥交换相关问题及解决方案</strong></h1><table><thead><tr><th><strong>问题</strong></th><th><strong>可能原因</strong></th><th><strong>解决方法</strong></th></tr></thead><tbody><tr><td><code>MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE</code></td><td>密钥交换失败</td><td>检查客户端和服务器支持的加密套件是否匹配</td></tr><tr><td><code>MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN</code></td><td>加密套件不兼容</td><td>启用双方兼容的加密算法（推荐 ECDHE）</td></tr><tr><td><code>MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY</code></td><td>服务器主动断开连接</td><td>检查证书、密钥交换算法是否正确</td></tr></tbody></table><hr><h1 id="🔹-六、完整流程示意图"><a href="#🔹-六、完整流程示意图" class="headerlink" title="🔹 六、完整流程示意图"></a><strong>🔹 六、完整流程示意图</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pgsql复制编辑Client                           Server</span><br><span class="line">  |--------&gt; ClientHello --------&gt;|</span><br><span class="line">  |&lt;------- ServerHello ----------|</span><br><span class="line">  |&lt;------- Certificate ----------|</span><br><span class="line">  |&lt;------- ServerKeyExchange ----|</span><br><span class="line">  |--------&gt; ClientKeyExchange ---&gt;|</span><br><span class="line">  |--------&gt; Finished ------------&gt;|</span><br><span class="line">  |&lt;------- Finished --------------|</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ESP32-TLS-握手中的密钥交换机制详解&quot;&gt;&lt;a href=&quot;#ESP32-TLS-握手中的密钥交换机制详解&quot; class=&quot;headerlink&quot; title=&quot;ESP32 TLS 握手中的密钥交换机制详解&quot;&gt;&lt;/a&gt;&lt;strong&gt;ESP32 TLS 握手</summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_tls单项认证和双向认证的区别</title>
    <link href="http://example.com/2025/03/19/esp32-tls%E5%8D%95%E9%A1%B9%E8%AE%A4%E8%AF%81%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2025/03/19/esp32-tls%E5%8D%95%E9%A1%B9%E8%AE%A4%E8%AF%81%E5%92%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2025-03-19T14:41:27.000Z</published>
    <updated>2025-03-19T14:43:12.736Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🔹-TLS-单向认证-vs-双向认证详解"><a href="#🔹-TLS-单向认证-vs-双向认证详解" class="headerlink" title="🔹 TLS 单向认证 vs 双向认证详解"></a><strong>🔹 TLS 单向认证 vs 双向认证详解</strong></h2><p>TLS（Transport Layer Security）是网络安全中最重要的加密协议之一。根据验证方式的不同，TLS 认证可分为：</p><p>✅ <strong>单向认证 (One-way Authentication)</strong><br> ✅ <strong>双向认证 (Mutual Authentication, mTLS)</strong></p><p>以下将从<strong>原理</strong>、<strong>流程</strong>、<strong>代码实现</strong>、<strong>使用场景</strong>等方面详细讲解两者的区别。</p><hr><h1 id="🔹-一、单向认证-One-way-Authentication"><a href="#🔹-一、单向认证-One-way-Authentication" class="headerlink" title="🔹 一、单向认证 (One-way Authentication)"></a><strong>🔹 一、单向认证 (One-way Authentication)</strong></h1><h3 id="🔍-原理"><a href="#🔍-原理" class="headerlink" title="🔍 原理"></a>🔍 <strong>原理</strong></h3><p>在 TLS 单向认证中，<strong>客户端验证服务器的身份</strong>，而服务器<strong>不验证客户端的身份</strong>。</p><p><strong>典型场景</strong>：</p><ul><li>HTTPS 网站（如访问百度、Google 等）</li><li>物联网设备通过 TLS 访问云服务器</li></ul><hr><h3 id="🟢-单向认证流程"><a href="#🟢-单向认证流程" class="headerlink" title="🟢 单向认证流程"></a><strong>🟢 单向认证流程</strong></h3><p>1️⃣ <strong>客户端发送 <code>ClientHello</code>，请求 TLS 连接</strong><br> 2️⃣ **服务器返回 <code>ServerHello</code> + <code>Certificate</code>**（携带服务器的证书）<br> 3️⃣ <strong>客户端验证服务器证书的有效性</strong>（验证 CA 签名、域名、有效期等）<br> 4️⃣ <strong>客户端和服务器完成密钥交换</strong><br> 5️⃣ <strong>开始安全的加密通信</strong></p><hr><h3 id="🟢-单向认证代码实现-ESP32-示例"><a href="#🟢-单向认证代码实现-ESP32-示例" class="headerlink" title="🟢 单向认证代码实现 (ESP32 示例)"></a><strong>🟢 单向认证代码实现 (ESP32 示例)</strong></h3><p>在 ESP32 中，单向认证只需加载服务器的根证书：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">esp_http_client_config_t config = &#123;</span><br><span class="line">    .url = &quot;https://example.com&quot;,</span><br><span class="line">    .cert_pem = server_cert_pem,  // 服务器的根证书 (Root CA)</span><br><span class="line">    .method = HTTP_METHOD_GET,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">esp_http_client_handle_t client = esp_http_client_init(&amp;config);</span><br><span class="line">esp_http_client_perform(client);</span><br><span class="line">esp_http_client_cleanup(client);</span><br></pre></td></tr></table></figure><hr><h3 id="✅-单向认证的优点"><a href="#✅-单向认证的优点" class="headerlink" title="✅ 单向认证的优点"></a><strong>✅ 单向认证的优点</strong></h3><ul><li>配置简单，仅需服务器的证书</li><li>适用于浏览器访问 HTTPS、普通 REST API 请求等场景</li></ul><h3 id="❗-单向认证的缺点"><a href="#❗-单向认证的缺点" class="headerlink" title="❗ 单向认证的缺点"></a><strong>❗ 单向认证的缺点</strong></h3><ul><li><strong>不验证客户端身份</strong>，容易被伪装客户端攻击</li><li>无法防止非法客户端访问服务器</li></ul><hr><h1 id="🔹-二、双向认证-Mutual-Authentication-x2F-mTLS"><a href="#🔹-二、双向认证-Mutual-Authentication-x2F-mTLS" class="headerlink" title="🔹 二、双向认证 (Mutual Authentication &#x2F; mTLS)"></a><strong>🔹 二、双向认证 (Mutual Authentication &#x2F; mTLS)</strong></h1><h3 id="🔍-原理-1"><a href="#🔍-原理-1" class="headerlink" title="🔍 原理"></a>🔍 <strong>原理</strong></h3><p>在 TLS 双向认证中，<strong>客户端和服务器互相验证身份</strong>，确保双方均为合法通信对象。</p><p><strong>典型场景</strong>：</p><ul><li>金融、支付系统</li><li>企业内网应用</li><li>高安全性 IoT (物联网) 设备</li></ul><hr><h3 id="🟢-双向认证流程"><a href="#🟢-双向认证流程" class="headerlink" title="🟢 双向认证流程"></a><strong>🟢 双向认证流程</strong></h3><p>1️⃣ **客户端发送 <code>ClientHello</code>**，请求 TLS 连接<br> 2️⃣ **服务器返回 <code>ServerHello</code> + <code>Certificate</code>**（携带服务器证书）<br> 3️⃣ <strong>客户端验证服务器证书</strong>（CA 签名、域名匹配等）<br> 4️⃣ **服务器发送 <code>CertificateRequest</code>**，要求客户端提供证书<br> 5️⃣ **客户端发送 <code>Certificate</code>**（携带客户端证书）<br> 6️⃣ <strong>服务器验证客户端证书</strong>（CA 签名、有效期、吊销检查等）<br> 7️⃣ <strong>双方完成密钥交换</strong>，开始安全通信</p><hr><h3 id="🟢-双向认证代码实现-ESP32-示例"><a href="#🟢-双向认证代码实现-ESP32-示例" class="headerlink" title="🟢 双向认证代码实现 (ESP32 示例)"></a><strong>🟢 双向认证代码实现 (ESP32 示例)</strong></h3><p>在 ESP32 中，双向认证需加载<strong>服务器证书</strong>和<strong>客户端证书&#x2F;私钥</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">esp_http_client_config_t config = &#123;</span><br><span class="line">    .url = &quot;https://example.com&quot;,</span><br><span class="line">    .cert_pem = server_cert_pem,  // 服务器的根证书 (Root CA)</span><br><span class="line">    .client_cert_pem = client_cert_pem,  // 客户端证书</span><br><span class="line">    .client_key_pem = client_key_pem,    // 客户端私钥</span><br><span class="line">    .method = HTTP_METHOD_GET,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">esp_http_client_handle_t client = esp_http_client_init(&amp;config);</span><br><span class="line">esp_http_client_perform(client);</span><br><span class="line">esp_http_client_cleanup(client);</span><br></pre></td></tr></table></figure><hr><h3 id="✅-双向认证的优点"><a href="#✅-双向认证的优点" class="headerlink" title="✅ 双向认证的优点"></a><strong>✅ 双向认证的优点</strong></h3><ul><li><strong>高安全性</strong>，确保客户端和服务器都是可信任方</li><li>防止伪装客户端攻击，适用于敏感数据传输</li></ul><h3 id="❗-双向认证的缺点"><a href="#❗-双向认证的缺点" class="headerlink" title="❗ 双向认证的缺点"></a><strong>❗ 双向认证的缺点</strong></h3><ul><li>配置较复杂，需在客户端和服务器双方配置证书</li><li>客户端证书管理较繁琐，需妥善保护私钥</li></ul><hr><h1 id="🔹-三、单向认证-vs-双向认证的区别"><a href="#🔹-三、单向认证-vs-双向认证的区别" class="headerlink" title="🔹 三、单向认证 vs 双向认证的区别"></a><strong>🔹 三、单向认证 vs 双向认证的区别</strong></h1><table><thead><tr><th>特点</th><th>单向认证</th><th>双向认证</th></tr></thead><tbody><tr><td><strong>验证过程</strong></td><td>客户端验证服务器证书</td><td>客户端验证服务器证书 + 服务器验证客户端证书</td></tr><tr><td><strong>安全性</strong></td><td>仅保证服务器合法性</td><td>确保客户端和服务器双向合法性</td></tr><tr><td><strong>复杂度</strong></td><td>配置简单</td><td>配置复杂，需为客户端配置证书</td></tr><tr><td><strong>典型应用场景</strong></td><td>HTTPS 网站、普通 API 请求</td><td>金融支付系统、企业内网、高安全 IoT 设备</td></tr><tr><td><strong>客户端证书要求</strong></td><td>不需要</td><td>必须提供客户端证书</td></tr><tr><td><strong>抗中间人攻击</strong></td><td>防御较弱（仅依赖 CA 证书）</td><td>防御更强，服务器会验证客户端身份</td></tr></tbody></table><hr><h1 id="🔹-四、使用场景推荐"><a href="#🔹-四、使用场景推荐" class="headerlink" title="🔹 四、使用场景推荐"></a><strong>🔹 四、使用场景推荐</strong></h1><table><thead><tr><th>应用场景</th><th>推荐使用模式</th></tr></thead><tbody><tr><td>HTTPS 网站访问</td><td>🔹 <strong>单向认证</strong></td></tr><tr><td>IoT 设备访问云平台</td><td>🔹 <strong>单向认证</strong></td></tr><tr><td>企业内网身份认证</td><td>🔹 <strong>双向认证</strong></td></tr><tr><td>银行、支付平台</td><td>🔹 <strong>双向认证</strong></td></tr><tr><td>设备对设备 (Device-to-Device) 通信</td><td>🔹 <strong>双向认证</strong></td></tr></tbody></table><hr><h1 id="🔹-五、示例分析：ESP32-IoT-设备访问-HTTPS-云服务"><a href="#🔹-五、示例分析：ESP32-IoT-设备访问-HTTPS-云服务" class="headerlink" title="🔹 五、示例分析：ESP32 IoT 设备访问 HTTPS 云服务"></a><strong>🔹 五、示例分析：ESP32 IoT 设备访问 HTTPS 云服务</strong></h1><h3 id="🔎-场景-1：ESP32-访问-REST-API-单向认证"><a href="#🔎-场景-1：ESP32-访问-REST-API-单向认证" class="headerlink" title="🔎 场景 1：ESP32 访问 REST API (单向认证)"></a><strong>🔎 场景 1：ESP32 访问 REST API (单向认证)</strong></h3><p>ESP32 仅需验证服务器证书，确保连接的是合法服务器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">esp_http_client_config_t config = &#123;</span><br><span class="line">    .url = &quot;https://iot-server.com&quot;,</span><br><span class="line">    .cert_pem = server_cert_pem,  // 服务器根证书</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="🔎-场景-2：ESP32-访问-MQTT-Broker-双向认证"><a href="#🔎-场景-2：ESP32-访问-MQTT-Broker-双向认证" class="headerlink" title="🔎 场景 2：ESP32 访问 MQTT Broker (双向认证)"></a><strong>🔎 场景 2：ESP32 访问 MQTT Broker (双向认证)</strong></h3><p>ESP32 需验证 MQTT Broker 的证书，同时提供客户端证书用于身份验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">esp_mqtt_client_config_t mqtt_cfg = &#123;</span><br><span class="line">    .uri = &quot;mqtts://mqtt-server.com&quot;,</span><br><span class="line">    .cert_pem = server_cert_pem,     // 服务器根证书</span><br><span class="line">    .client_cert_pem = client_cert_pem,  // ESP32 客户端证书</span><br><span class="line">    .client_key_pem = client_key_pem     // ESP32 客户端私钥</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="🔹-六、总结"><a href="#🔹-六、总结" class="headerlink" title="🔹 六、总结"></a><strong>🔹 六、总结</strong></h1><table><thead><tr><th>使用场景</th><th>推荐方案</th></tr></thead><tbody><tr><td>仅需验证服务器合法性</td><td>🔹 <strong>单向认证</strong></td></tr><tr><td>需防止非法客户端接入</td><td>🔹 <strong>双向认证</strong></td></tr><tr><td>IoT 设备访问 REST API</td><td>🔹 <strong>单向认证</strong></td></tr><tr><td>ESP32 访问 MQTT Broker</td><td>🔹 <strong>双向认证</strong></td></tr><tr><td>企业级 VPN &#x2F; 远程办公系统</td><td>🔹 <strong>双向认证</strong></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;🔹-TLS-单向认证-vs-双向认证详解&quot;&gt;&lt;a href=&quot;#🔹-TLS-单向认证-vs-双向认证详解&quot; class=&quot;headerlink&quot; title=&quot;🔹 TLS 单向认证 vs 双向认证详解&quot;&gt;&lt;/a&gt;&lt;strong&gt;🔹 TLS 单向认证 vs </summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_https证书验证握手流程简解</title>
    <link href="http://example.com/2025/03/19/esp32-https%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E7%AE%80%E8%A7%A3/"/>
    <id>http://example.com/2025/03/19/esp32-https%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B%E7%AE%80%E8%A7%A3/</id>
    <published>2025-03-19T14:40:11.000Z</published>
    <updated>2025-03-19T14:40:49.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ESP32-证书验证的详细过程-mbedTLS-内部机制"><a href="#ESP32-证书验证的详细过程-mbedTLS-内部机制" class="headerlink" title="ESP32 证书验证的详细过程 (mbedTLS 内部机制)"></a><strong>ESP32 证书验证的详细过程 (mbedTLS 内部机制)</strong></h3><p>ESP32 通过 <code>mbedTLS</code> 进行 TLS&#x2F;SSL 加密通信，证书验证是其中的关键环节。以下将结合 <code>mbedTLS</code> 代码深入讲解证书验证的内部机制，帮助理解其背后的原理和流程。</p><h2 id="一、mbedTLS-证书验证的核心模块"><a href="#一、mbedTLS-证书验证的核心模块" class="headerlink" title="一、mbedTLS 证书验证的核心模块"></a><strong>一、mbedTLS 证书验证的核心模块</strong></h2><p>在 <code>mbedTLS</code> 中，证书验证的核心模块包括以下几个组件：</p><table><thead><tr><th>模块</th><th>功能说明</th></tr></thead><tbody><tr><td><code>mbedtls_x509_crt</code></td><td>证书解析及存储结构</td></tr><tr><td><code>mbedtls_ssl_config</code></td><td>TLS&#x2F;SSL 配置，定义验证模式</td></tr><tr><td><code>mbedtls_ssl_set_authmode</code></td><td>设置证书验证模式</td></tr><tr><td><code>mbedtls_ssl_handshake</code></td><td>执行 TLS&#x2F;SSL 握手并触发证书验证</td></tr><tr><td><code>mbedtls_ssl_conf_verify</code></td><td>设置自定义回调，手动验证证书</td></tr></tbody></table><hr><h2 id="二、mbedTLS-证书验证的详细流程"><a href="#二、mbedTLS-证书验证的详细流程" class="headerlink" title="二、mbedTLS 证书验证的详细流程"></a><strong>二、mbedTLS 证书验证的详细流程</strong></h2><p>在 ESP-IDF 中，HTTPS 客户端的证书验证大致可分为以下 5 个步骤：</p><hr><h3 id="Step-1：初始化-mbedTLS-核心结构体"><a href="#Step-1：初始化-mbedTLS-核心结构体" class="headerlink" title="Step 1：初始化 mbedTLS 核心结构体"></a><strong>Step 1：初始化 mbedTLS 核心结构体</strong></h3><p>初始化 TLS&#x2F;SSL 相关的核心结构体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_context ssl;          // SSL 会话上下文</span><br><span class="line">mbedtls_ssl_config conf;          // SSL 配置结构体</span><br><span class="line">mbedtls_x509_crt cacert;          // CA 根证书</span><br><span class="line">mbedtls_ctr_drbg_context ctr_drbg; // 随机数生成器</span><br><span class="line">mbedtls_entropy_context entropy;   // 熵（Entropy）源</span><br></pre></td></tr></table></figure><p><strong>初始化结构体：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_init(&amp;ssl);</span><br><span class="line">mbedtls_ssl_config_init(&amp;conf);</span><br><span class="line">mbedtls_x509_crt_init(&amp;cacert);</span><br><span class="line">mbedtls_ctr_drbg_init(&amp;ctr_drbg);</span><br><span class="line">mbedtls_entropy_init(&amp;entropy);</span><br></pre></td></tr></table></figure><hr><h3 id="Step-2：加载根证书"><a href="#Step-2：加载根证书" class="headerlink" title="Step 2：加载根证书"></a><strong>Step 2：加载根证书</strong></h3><p>ESP32 使用 <code>.pem</code> 格式的根证书来校验服务器证书。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">extern const uint8_t root_ca_pem_start[] asm(&quot;_binary_root_cert_pem_start&quot;);</span><br><span class="line">extern const uint8_t root_ca_pem_end[] asm(&quot;_binary_root_cert_pem_end&quot;);</span><br><span class="line"></span><br><span class="line">mbedtls_x509_crt_parse(&amp;cacert, root_ca_pem_start,</span><br><span class="line">                       root_ca_pem_end - root_ca_pem_start);</span><br></pre></td></tr></table></figure><blockquote><p>✅ <code>mbedtls_x509_crt_parse()</code> 会解析证书链，包括根证书和中间证书。<br>❗ 若解析失败，返回 <code>MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT</code> 表示格式不正确。</p></blockquote><hr><h3 id="Step-3：配置-SSL-会话"><a href="#Step-3：配置-SSL-会话" class="headerlink" title="Step 3：配置 SSL 会话"></a><strong>Step 3：配置 SSL 会话</strong></h3><p>配置 TLS&#x2F;SSL 参数，包括证书链、验证模式等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_config_defaults(&amp;conf,</span><br><span class="line">   MBEDTLS_SSL_IS_CLIENT,     // 客户端模式</span><br><span class="line">   MBEDTLS_SSL_TRANSPORT_STREAM, // TCP 传输</span><br><span class="line">   MBEDTLS_SSL_PRESET_DEFAULT);  // 默认配置</span><br></pre></td></tr></table></figure><p>将根证书链与 SSL 配置结构体绑定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_ca_chain(&amp;conf, &amp;cacert, NULL);  // 设置 CA 证书链</span><br></pre></td></tr></table></figure><p>设置认证模式，确保启用强制验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_authmode(&amp;conf, MBEDTLS_SSL_VERIFY_REQUIRED);  // 强制验证</span><br></pre></td></tr></table></figure><hr><h3 id="Step-4：设置随机数生成器"><a href="#Step-4：设置随机数生成器" class="headerlink" title="Step 4：设置随机数生成器"></a><strong>Step 4：设置随机数生成器</strong></h3><p>TLS&#x2F;SSL 依赖加密算法，因此需要可靠的随机数源。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ctr_drbg_seed(&amp;ctr_drbg, mbedtls_entropy_func, &amp;entropy, NULL, 0);</span><br><span class="line">mbedtls_ssl_conf_rng(&amp;conf, mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h3 id="Step-5：绑定回调函数-可选，自定义验证"><a href="#Step-5：绑定回调函数-可选，自定义验证" class="headerlink" title="Step 5：绑定回调函数 (可选，自定义验证)"></a><strong>Step 5：绑定回调函数 (可选，自定义验证)</strong></h3><p>ESP-IDF 提供默认的验证机制，但也可通过 <code>mbedtls_ssl_conf_verify()</code> 添加自定义验证逻辑。</p><p>✅ <strong>回调函数示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">static int my_verify(void *data, mbedtls_x509_crt *crt, int depth, uint32_t *flags) </span><br><span class="line">&#123;</span><br><span class="line">    char buf[512];</span><br><span class="line">    mbedtls_x509_crt_info(buf, sizeof(buf) - 1, &quot;&quot;, crt);</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, &quot;证书深度: %d\n%s&quot;, depth, buf);</span><br><span class="line"></span><br><span class="line">    if (*flags) &#123;</span><br><span class="line">        ESP_LOGW(TAG, &quot;证书验证失败，错误码: %x&quot;, *flags);</span><br><span class="line">        return -1;  // 验证失败，终止连接</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, &quot;证书验证成功&quot;);</span><br><span class="line">    return 0;  // 验证通过</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册回调函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_conf_verify(&amp;conf, my_verify, NULL);</span><br></pre></td></tr></table></figure><hr><h3 id="Step-6：启动-TLS-x2F-SSL-握手"><a href="#Step-6：启动-TLS-x2F-SSL-握手" class="headerlink" title="Step 6：启动 TLS&#x2F;SSL 握手"></a><strong>Step 6：启动 TLS&#x2F;SSL 握手</strong></h3><p>通过 <code>mbedtls_ssl_handshake()</code> 触发证书验证。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((ret = mbedtls_ssl_handshake(&amp;ssl)) != 0) &#123;</span><br><span class="line">    ESP_LOGE(TAG, &quot;TLS/SSL 握手失败: -0x%x&quot;, -ret);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    ESP_LOGI(TAG, &quot;TLS/SSL 握手成功&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❗ 握手失败可能是证书无效、过期、或不匹配导致的，具体错误可参考 <code>ret</code> 的返回码。</p></blockquote><hr><h3 id="Step-7：关闭连接并释放资源"><a href="#Step-7：关闭连接并释放资源" class="headerlink" title="Step 7：关闭连接并释放资源"></a><strong>Step 7：关闭连接并释放资源</strong></h3><p>证书验证完成后，释放相关资源以避免内存泄漏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_free(&amp;ssl);</span><br><span class="line">mbedtls_ssl_config_free(&amp;conf);</span><br><span class="line">mbedtls_x509_crt_free(&amp;cacert);</span><br><span class="line">mbedtls_ctr_drbg_free(&amp;ctr_drbg);</span><br><span class="line">mbedtls_entropy_free(&amp;entropy);</span><br></pre></td></tr></table></figure><hr><h2 id="三、证书验证失败的常见错误码"><a href="#三、证书验证失败的常见错误码" class="headerlink" title="三、证书验证失败的常见错误码"></a><strong>三、证书验证失败的常见错误码</strong></h2><p><code>mbedTLS</code> 的证书验证错误信息较为具体，以下是一些常见错误及其原因：</p><table><thead><tr><th>错误码</th><th>错误信息</th><th>可能原因</th><th>解决方法</th></tr></thead><tbody><tr><td><code>-0x2700</code></td><td><code>MBEDTLS_ERR_X509_CERT_VERIFY_FAILED</code></td><td>证书链验证失败</td><td>确保使用正确的根证书</td></tr><tr><td><code>-0x270D</code></td><td><code>MBEDTLS_ERR_X509_CERT_EXPIRED</code></td><td>证书已过期</td><td>检查 ESP32 的系统时间是否准确</td></tr><tr><td><code>-0x270C</code></td><td><code>MBEDTLS_ERR_X509_CERT_REVOKED</code></td><td>证书已吊销</td><td>检查证书的吊销状态</td></tr><tr><td><code>-0x2708</code></td><td><code>MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT</code></td><td>证书格式错误</td><td>确认证书为 <code>.pem</code> 格式</td></tr><tr><td><code>-0x7100</code></td><td><code>MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY</code></td><td>服务器主动关闭连接</td><td>检查服务器端的配置和证书链完整性</td></tr></tbody></table><h2 id="四、调试技巧"><a href="#四、调试技巧" class="headerlink" title="四、调试技巧"></a><strong>四、调试技巧</strong></h2><ol><li><strong>启用详细日志</strong><br>在 <code>menuconfig</code> 中启用 mbedTLS 的调试日志：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Component config  ---&gt; </span><br><span class="line">    mbedTLS  ---&gt; </span><br><span class="line">        Enable mbedTLS debugging (最大等级为 4)</span><br></pre></td></tr></table></figure><ol><li><strong>输出证书信息</strong> 添加 <code>mbedtls_x509_crt_info()</code> 打印证书的详细信息：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char buf[1024];</span><br><span class="line">mbedtls_x509_crt_info(buf, sizeof(buf) - 1, &quot;&quot;, &amp;cacert);</span><br><span class="line">ESP_LOGI(TAG, &quot;证书信息:\n%s&quot;, buf);</span><br></pre></td></tr></table></figure><ol><li><strong>使用 <code>openssl</code> 检查证书链</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">openssl s_client -connect example.com:443</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;ESP32-证书验证的详细过程-mbedTLS-内部机制&quot;&gt;&lt;a href=&quot;#ESP32-证书验证的详细过程-mbedTLS-内部机制&quot; class=&quot;headerlink&quot; title=&quot;ESP32 证书验证的详细过程 (mbedTLS 内部机制)&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_https证书详解</title>
    <link href="http://example.com/2025/03/19/esp32-https%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/19/esp32-https%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-19T14:39:01.000Z</published>
    <updated>2025-03-19T14:39:27.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、HTTPS-证书验证机制概述"><a href="#一、HTTPS-证书验证机制概述" class="headerlink" title="一、HTTPS 证书验证机制概述"></a><strong>一、HTTPS 证书验证机制概述</strong></h2><p>在 HTTPS 通信中，服务器会向客户端提供一个<strong>服务器证书</strong>。客户端要验证该证书的合法性，确保它是由<strong>可信的证书颁发机构 (CA, Certificate Authority)</strong> 签发的。这个验证过程依赖于**证书链 (Certificate Chain)**。</p><h2 id="二、证书链-Certificate-Chain-结构"><a href="#二、证书链-Certificate-Chain-结构" class="headerlink" title="二、证书链 (Certificate Chain) 结构"></a><strong>二、证书链 (Certificate Chain) 结构</strong></h2><p>证书链通常包含以下几部分：</p><ol><li>服务器证书 (Server Certificate)<ul><li>由中间 CA 签发，包含服务器域名、有效期、公钥等信息。</li></ul></li><li>中间证书 (Intermediate Certificate)<ul><li>由根 CA 签发，专门用于签发服务器证书。</li></ul></li><li>根证书 (Root Certificate)<ul><li>最顶层的证书，由受信任的 CA 机构（如 Let’s Encrypt、DigiCert 等）签名。根证书是自签名的（即自己签发自己）。</li></ul></li></ol><h3 id="证书链验证过程"><a href="#证书链验证过程" class="headerlink" title="证书链验证过程"></a><strong>证书链验证过程</strong></h3><ol><li><strong>服务器发送其证书及中间证书给客户端。</strong></li><li><strong>客户端利用本地存储的根证书，验证中间证书的有效性。</strong></li><li><strong>中间证书验证成功后，再验证服务器证书。</strong></li><li>如果整个链条无误，则认为服务器的证书有效，通信可继续；否则连接会被终止。</li></ol><h2 id="三、ESP32-校验根证书的原因"><a href="#三、ESP32-校验根证书的原因" class="headerlink" title="三、ESP32 校验根证书的原因"></a><strong>三、ESP32 校验根证书的原因</strong></h2><p>ESP32 无法像常规 PC 或手机那样，内置完整的 CA 证书列表。因此，ESP32 需要手动提供可信任的<strong>根证书</strong>来验证服务器证书。</p><h3 id="为什么不能仅靠服务器证书？"><a href="#为什么不能仅靠服务器证书？" class="headerlink" title="为什么不能仅靠服务器证书？"></a><strong>为什么不能仅靠服务器证书？</strong></h3><ul><li>**防止中间人攻击 (MITM)**：攻击者可以伪造一个看似合法的证书，而没有根证书验证机制时，ESP32 可能无法识别该伪造证书。</li><li><strong>确保服务器身份</strong>：根证书属于权威 CA，并已通过严格的安全审计，因此可信度更高。</li></ul><h3 id="根证书的作用"><a href="#根证书的作用" class="headerlink" title="根证书的作用"></a><strong>根证书的作用</strong></h3><ul><li>确认证书签发者的合法性（防止假冒 CA）</li><li>验证服务器证书是否属于可信 CA 签发的证书</li><li>防止服务器使用过期、吊销或伪造的证书</li></ul><h2 id="四、根证书的获取方法"><a href="#四、根证书的获取方法" class="headerlink" title="四、根证书的获取方法"></a><strong>四、根证书的获取方法</strong></h2><ol><li><p><strong>浏览器导出</strong></p><ul><li>在 Chrome&#x2F;Firefox 打开目标 HTTPS 网站</li><li>点击 🔒（锁）图标 → <strong>证书 (Certificate)</strong></li><li>找到<strong>根证书</strong> → 导出为 <code>.pem</code> 格式</li></ul></li><li><p><strong>使用命令行工具 <code>openssl</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl s_client -showcerts -connect example.com:443</span><br></pre></td></tr></table></figure></li><li><p><strong>公共 CA 机构网站</strong></p><ul><li>例如 Let’s Encrypt、<a href="https://www.digicert.com/">DigiCert</a> 等提供根证书下载</li></ul></li></ol><h2 id="五、ESP32-根证书验证失败的常见问题"><a href="#五、ESP32-根证书验证失败的常见问题" class="headerlink" title="五、ESP32 根证书验证失败的常见问题"></a><strong>五、ESP32 根证书验证失败的常见问题</strong></h2><ol><li><p><strong>证书过期</strong>：根证书可能已过期，需要替换为最新的版本。</p></li><li><p><strong>证书链不完整</strong>：服务器未正确配置中间证书，导致验证失败。</p></li><li><p><strong>时钟未同步</strong>：ESP32 启动时未正确设置系统时间，导致证书有效期判断出错。</p></li><li><p>证书编码格式错误</p><p>：ESP32 要求根证书为 PEM 格式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.pem</span><br></pre></td></tr></table></figure><p>若为 DER 格式需转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -inform DER -in cert.der -out cert.pem</span><br></pre></td></tr></table></figure></li></ol><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a><strong>六、总结</strong></h2><p>ESP32 校验服务器证书时需要根证书，主要是为了确保服务器的可信度，防止中间人攻击及证书伪造。由于 ESP32 资源有限，ESP-IDF 默认未内置 CA 证书链，因此开发者需要手动提供根证书，确保 HTTPS 请求的安全性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、HTTPS-证书验证机制概述&quot;&gt;&lt;a href=&quot;#一、HTTPS-证书验证机制概述&quot; class=&quot;headerlink&quot; title=&quot;一、HTTPS 证书验证机制概述&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、HTTPS 证书验证机制概述&lt;/strong&gt;&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_https证书配置流程详解</title>
    <link href="http://example.com/2025/03/19/esp32-https%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/19/esp32-https%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-19T14:38:20.000Z</published>
    <updated>2025-03-19T14:38:42.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、ESP32-证书校验的原理"><a href="#一、ESP32-证书校验的原理" class="headerlink" title="一、ESP32 证书校验的原理"></a><strong>一、ESP32 证书校验的原理</strong></h2><p>ESP32 使用 <strong>mbedTLS</strong> 作为底层 TLS&#x2F;SSL 协议栈来实现 HTTPS 加密通信。其证书验证机制基于 X.509 标准，确保服务器的身份安全，防止中间人攻击 (MITM)。</p><h3 id="核心验证要点"><a href="#核心验证要点" class="headerlink" title="核心验证要点"></a><strong>核心验证要点</strong></h3><ul><li><strong>验证服务器证书的签名</strong>（确保该证书由受信任的 CA 签发）</li><li><strong>验证证书的有效期</strong>（证书是否已过期）</li><li><strong>验证证书的域名 (Common Name, CN) 是否匹配</strong></li><li><strong>检查证书吊销状态（可选）</strong></li></ul><h2 id="二、ESP32-证书校验流程"><a href="#二、ESP32-证书校验流程" class="headerlink" title="二、ESP32 证书校验流程"></a><strong>二、ESP32 证书校验流程</strong></h2><p>ESP32 在 HTTPS 请求中，完整的证书校验流程如下：</p><ol><li><strong>客户端初始化 TLS 会话</strong><ul><li>ESP32 使用 <code>esp_http_client</code> 作为 HTTP 客户端，并在配置中指定 <code>cert_pem</code> 字段。</li></ul></li><li><strong>服务器响应证书</strong><ul><li>服务器返回其 <strong>服务器证书</strong> 及（可能）<strong>中间证书</strong>。</li></ul></li><li><strong>mbedTLS 验证证书链</strong><ul><li>检查服务器证书的<strong>签名</strong>是否正确。</li><li>根据提供的根证书，验证<strong>中间证书</strong>的签名。</li><li>如果链条完整并通过验证，则该服务器是可信任的。</li></ul></li><li><strong>检查服务器证书的其他信息</strong><ul><li>验证域名 (Common Name, CN) 是否匹配。</li><li>验证证书的有效期。</li><li>检查吊销状态（如启用 CRL&#x2F;OCSP 时）。</li></ul></li><li><strong>完成握手，建立安全连接</strong></li></ol><h2 id="三、ESP32-证书配置"><a href="#三、ESP32-证书配置" class="headerlink" title="三、ESP32 证书配置"></a><strong>三、ESP32 证书配置</strong></h2><p>在 ESP-IDF 的 <code>esp_http_client_config_t</code> 配置结构中，以下字段与证书校验密切相关：</p><h3 id="1-指定根证书-Root-CA"><a href="#1-指定根证书-Root-CA" class="headerlink" title="1. 指定根证书 (Root CA)"></a><strong>1. 指定根证书 (Root CA)</strong></h3><p>根证书是校验链条中最关键的一环，ESP-IDF 提供了以下两种方法配置：</p><ul><li><strong>静态内嵌根证书</strong>（推荐）<br>使用编译时嵌入的 PEM 格式证书。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">extern const char server_cert_pem_start[] asm(&quot;_binary_root_cert_pem_start&quot;);</span><br><span class="line">extern const char server_cert_pem_end[] asm(&quot;_binary_root_cert_pem_end&quot;);</span><br><span class="line"></span><br><span class="line">esp_http_client_config_t config = &#123;</span><br><span class="line">    .url = &quot;https://example.com&quot;,</span><br><span class="line">    .cert_pem = server_cert_pem_start,   // 根证书</span><br><span class="line">    .event_handler = http_event_handler,</span><br><span class="line">    .method = HTTP_METHOD_GET,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>嵌入 PEM 文件步骤</strong></p><ul><li><p>将 <code>.pem</code> 证书放入 <code>main</code> 目录下</p></li><li><p>在 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMakeLists.txt</span><br></pre></td></tr></table></figure><p> 中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmake</span><br></pre></td></tr></table></figure><p>复制编辑<br>set(COMPONENT_EMBED_TXTFILES root_cert.pem)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul></blockquote><hr><ul><li><strong>动态加载根证书</strong>（适合证书更新场景）<br>通过 SPIFFS&#x2F;NVS 读取并传入 <code>cert_pem</code> 字段：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const char *cert_buf = NULL;</span><br><span class="line">load_cert_from_spiffs(&amp;cert_buf);  // 自定义加载函数</span><br><span class="line"></span><br><span class="line">esp_http_client_config_t config = &#123;</span><br><span class="line">    .url = &quot;https://example.com&quot;,</span><br><span class="line">    .cert_pem = cert_buf,  </span><br><span class="line">    .event_handler = http_event_handler,</span><br><span class="line">    .method = HTTP_METHOD_GET,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-跳过证书验证（不推荐）"><a href="#2-跳过证书验证（不推荐）" class="headerlink" title="2. 跳过证书验证（不推荐）"></a><strong>2. 跳过证书验证（不推荐）</strong></h3><p>仅用于调试目的，生产环境应避免使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">esp_http_client_config_t config = &#123;</span><br><span class="line">    .url = &quot;https://example.com&quot;,</span><br><span class="line">    .skip_cert_common_name_check = true,  // 跳过CN校验</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="四、证书验证的详细过程-mbedTLS-内部机制"><a href="#四、证书验证的详细过程-mbedTLS-内部机制" class="headerlink" title="四、证书验证的详细过程 (mbedTLS 内部机制)"></a><strong>四、证书验证的详细过程 (mbedTLS 内部机制)</strong></h2><p>ESP-IDF 基于 <code>mbedTLS</code> 的 <code>ssl</code> 模块来验证证书。内部流程大致如下：</p><ol><li><p><strong>根证书加载</strong></p><ul><li>ESP32 读取 <code>.pem</code> 格式的根证书，并初始化 <code>mbedtls_x509_crt</code> 结构体。</li><li>示例：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_x509_crt cert;</span><br><span class="line">mbedtls_x509_crt_init(&amp;cert);</span><br><span class="line">mbedtls_x509_crt_parse(&amp;cert, (const unsigned char *)root_ca, strlen(root_ca) + 1);</span><br></pre></td></tr></table></figure></li><li><p><strong>SSL&#x2F;TLS 会话初始化</strong></p><ul><li>&#96;&#96;&#96;<br>mbedtls_ssl_config<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      配置结构体初始化，并设置以下选项：</span><br><span class="line"></span><br><span class="line">     - 证书链</span><br><span class="line">     - 证书验证回调函数（自定义验证）</span><br><span class="line"></span><br><span class="line">3. **证书校验**</span><br><span class="line"></span><br><span class="line">   - 通过 </span><br><span class="line"></span><br></pre></td></tr></table></figure>mbedtls_ssl_set_authmode()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">      设置验证模式：</span><br><span class="line"></span><br><span class="line">     - `MBEDTLS_SSL_VERIFY_REQUIRED`（强制验证）</span><br><span class="line">     - `MBEDTLS_SSL_VERIFY_OPTIONAL`（可选验证）</span><br><span class="line">     - `MBEDTLS_SSL_VERIFY_NONE`（不验证，危险）</span><br><span class="line"></span><br><span class="line">4. **回调函数处理**</span><br><span class="line"></span><br><span class="line">   - ESP-IDF 默认的 `http_event_handler` 会捕获验证失败的事件，并输出详细日志。</span><br><span class="line"></span><br><span class="line">## **五、证书验证失败的常见原因及解决方案**</span><br><span class="line"></span><br><span class="line">### **1. 证书过期**</span><br><span class="line"></span><br><span class="line">- **原因**：ESP32 的时钟可能未同步，导致验证时误认为证书已过期。</span><br><span class="line">- **解决方法**：在启动时使用 NTP 进行时间同步。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ol><p>sntp_setoperatingmode(SNTP_OPMODE_POLL);<br>sntp_setservername(0, “pool.ntp.org”);<br>sntp_init();</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### **2. 根证书不匹配**</span><br><span class="line"></span><br><span class="line">- **原因**：根证书不匹配服务器的证书链。</span><br><span class="line">- **解决方法**：使用 `openssl` 检查证书链并替换根证书。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>openssl s_client -showcerts -connect example.com:443</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **3. PEM 格式错误**</span><br><span class="line"></span><br><span class="line">- **原因**：ESP32 要求使用 `.pem` 格式的证书。</span><br><span class="line">- **解决方法**：使用以下命令转换：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>openssl x509 -inform DER -in cert.der -out cert.pem</p><p>&#96;&#96;&#96;</p><h3 id="4-证书链不完整"><a href="#4-证书链不完整" class="headerlink" title="4. 证书链不完整"></a><strong>4. 证书链不完整</strong></h3><ul><li><strong>原因</strong>：服务器未正确配置中间证书。</li><li><strong>解决方法</strong>：联系服务器维护人员，确保完整证书链配置。</li></ul><hr><h3 id="5-CN-Common-Name-不匹配"><a href="#5-CN-Common-Name-不匹配" class="headerlink" title="5. CN (Common Name) 不匹配"></a><strong>5. CN (Common Name) 不匹配</strong></h3><ul><li><strong>原因</strong>：服务器证书的 CN 字段与请求 URL 不一致。</li><li><strong>解决方法</strong>：检查 URL 是否拼写正确，或通过 <code>skip_cert_common_name_check = true</code> 绕过 CN 校验（不推荐）。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、ESP32-证书校验的原理&quot;&gt;&lt;a href=&quot;#一、ESP32-证书校验的原理&quot; class=&quot;headerlink&quot; title=&quot;一、ESP32 证书校验的原理&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、ESP32 证书校验的原理&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;E</summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>esp32_https连接-证书验证-握手成功详解</title>
    <link href="http://example.com/2025/03/19/esp32-https%E8%BF%9E%E6%8E%A5-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81-%E6%8F%A1%E6%89%8B%E6%88%90%E5%8A%9F%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2025/03/19/esp32-https%E8%BF%9E%E6%8E%A5-%E8%AF%81%E4%B9%A6%E9%AA%8C%E8%AF%81-%E6%8F%A1%E6%89%8B%E6%88%90%E5%8A%9F%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-03-19T14:37:23.000Z</published>
    <updated>2025-03-19T14:37:49.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ESP32-HTTPS-通信中的-TLS-握手及证书验证详解"><a href="#ESP32-HTTPS-通信中的-TLS-握手及证书验证详解" class="headerlink" title="ESP32 HTTPS 通信中的 TLS 握手及证书验证详解"></a><strong>ESP32 HTTPS 通信中的 TLS 握手及证书验证详解</strong></h2><p>TLS（Transport Layer Security）协议在 ESP32 HTTPS 通信中至关重要。完整的 TLS 握手过程包含 <strong>TCP 连接建立</strong>、<strong>ServerHello</strong>、<strong>证书验证</strong> 和 <strong>密钥协商</strong> 等环节。以下将结合 <strong>ESP32 (mbedTLS)</strong> 的具体流程，详细解析 TLS 握手的内部机制。</p><h1 id="一、TLS-握手流程概览"><a href="#一、TLS-握手流程概览" class="headerlink" title="一、TLS 握手流程概览"></a><strong>一、TLS 握手流程概览</strong></h1><p>完整的 TLS 握手过程可分为以下几个阶段：</p><h3 id="🔹-阶段-1：TCP-连接建立"><a href="#🔹-阶段-1：TCP-连接建立" class="headerlink" title="🔹 阶段 1：TCP 连接建立"></a>🔹 <strong>阶段 1：TCP 连接建立</strong></h3><blockquote><p>➡️ ESP32 作为客户端发起 TCP 连接请求，完成三次握手。</p></blockquote><h3 id="🔹-阶段-2：TLS-握手阶段"><a href="#🔹-阶段-2：TLS-握手阶段" class="headerlink" title="🔹 阶段 2：TLS 握手阶段"></a>🔹 <strong>阶段 2：TLS 握手阶段</strong></h3><blockquote><p>➡️ 以 <code>mbedtls_ssl_handshake()</code> 为核心，包含以下步骤：</p></blockquote><ol><li>ClientHello</li><li>ServerHello</li><li>证书传输与验证</li><li>密钥交换 (Key Exchange)</li><li>Finished（握手完成）</li></ol><h3 id="🔹-阶段-3：加密通信阶段"><a href="#🔹-阶段-3：加密通信阶段" class="headerlink" title="🔹 阶段 3：加密通信阶段"></a>🔹 <strong>阶段 3：加密通信阶段</strong></h3><blockquote><p>➡️ 双方使用协商好的密钥进行加密数据传输。</p></blockquote><h1 id="二、TLS-握手的详细过程"><a href="#二、TLS-握手的详细过程" class="headerlink" title="二、TLS 握手的详细过程"></a><strong>二、TLS 握手的详细过程</strong></h1><h3 id="🟢-阶段-1：TCP-连接建立"><a href="#🟢-阶段-1：TCP-连接建立" class="headerlink" title="🟢 阶段 1：TCP 连接建立"></a><strong>🟢 阶段 1：TCP 连接建立</strong></h3><p>ESP32 发起 TCP 连接，使用 <code>mbedtls_net_connect()</code> 建立 Socket：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_net_context server_fd;</span><br><span class="line">mbedtls_net_init(&amp;server_fd);</span><br><span class="line"></span><br><span class="line">int ret = mbedtls_net_connect(&amp;server_fd, &quot;example.com&quot;, &quot;443&quot;, MBEDTLS_NET_PROTO_TCP);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">    ESP_LOGE(TAG, &quot;TCP 连接失败: -0x%x&quot;, -ret);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>example.com</code>：服务器域名</li><li><code>443</code>：HTTPS 标准端口</li></ul><p><strong>TCP 三次握手过程</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Client] SYN ----&gt; [Server]  </span><br><span class="line">[Server] SYN + ACK &lt;---- [Client]  </span><br><span class="line">[Client] ACK ----&gt; [Server]  </span><br></pre></td></tr></table></figure><blockquote><p>✅ 这一步完成后，TCP 连接已建立，TLS 握手将继续。</p></blockquote><hr><h3 id="🟢-阶段-2：TLS-握手过程"><a href="#🟢-阶段-2：TLS-握手过程" class="headerlink" title="🟢 阶段 2：TLS 握手过程"></a><strong>🟢 阶段 2：TLS 握手过程</strong></h3><p>ESP32 使用 <code>mbedtls_ssl_handshake()</code> 实现 TLS 握手，以下为详细步骤：</p><hr><h3 id="🔹-Step-1：ClientHello（客户端问候）"><a href="#🔹-Step-1：ClientHello（客户端问候）" class="headerlink" title="🔹 Step 1：ClientHello（客户端问候）"></a><strong>🔹 Step 1：ClientHello（客户端问候）</strong></h3><ul><li><p>客户端发送 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClientHello</span><br></pre></td></tr></table></figure><p> 消息，包含：</p><ul><li>支持的 TLS 版本</li><li>支持的加密算法（如 <code>ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>）</li><li>随机数 <code>Random_C</code>（用于密钥交换）</li></ul></li></ul><p><strong>示例代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mbedtls_ssl_context ssl;</span><br><span class="line">mbedtls_ssl_init(&amp;ssl);</span><br><span class="line"></span><br><span class="line">mbedtls_ssl_config_defaults(&amp;conf,</span><br><span class="line">    MBEDTLS_SSL_IS_CLIENT,             // 客户端模式</span><br><span class="line">    MBEDTLS_SSL_TRANSPORT_STREAM,      // 流式传输（TCP）</span><br><span class="line">    MBEDTLS_SSL_PRESET_DEFAULT);       // 默认配置</span><br><span class="line"></span><br><span class="line">mbedtls_ssl_setup(&amp;ssl, &amp;conf);</span><br><span class="line">mbedtls_ssl_set_hostname(&amp;ssl, &quot;example.com&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="🔹-Step-2：ServerHello（服务器问候）"><a href="#🔹-Step-2：ServerHello（服务器问候）" class="headerlink" title="🔹 Step 2：ServerHello（服务器问候）"></a><strong>🔹 Step 2：ServerHello（服务器问候）</strong></h3><ul><li><p>服务器响应 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerHello</span><br></pre></td></tr></table></figure><p> 消息，包含：</p><ul><li>选定的 TLS 版本</li><li>选定的加密算法</li><li>随机数 <code>Random_S</code>（用于密钥交换）</li><li>服务器证书</li></ul></li></ul><p><strong>示例日志输出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mbedTLS] ServerHello: TLS 1.2</span><br><span class="line">[mbedTLS] Cipher Suite: TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</span><br></pre></td></tr></table></figure><hr><h3 id="🔹-Step-3：证书传输与验证"><a href="#🔹-Step-3：证书传输与验证" class="headerlink" title="🔹 Step 3：证书传输与验证"></a><strong>🔹 Step 3：证书传输与验证</strong></h3><p>服务器通过 <code>Certificate</code> 消息发送其证书链（根证书 ➔ 中间证书 ➔ 服务器证书）。</p><p>ESP32 执行以下验证：</p><p>✅ 验证服务器证书的签名<br> ✅ 检查证书是否过期<br> ✅ 确认证书中的 CN（Common Name）与目标域名匹配</p><p><strong>示例代码：加载根证书</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">extern const uint8_t root_cert_pem_start[] asm(&quot;_binary_root_cert_pem_start&quot;);</span><br><span class="line">extern const uint8_t root_cert_pem_end[] asm(&quot;_binary_root_cert_pem_end&quot;);</span><br><span class="line"></span><br><span class="line">mbedtls_x509_crt cacert;</span><br><span class="line">mbedtls_x509_crt_init(&amp;cacert);</span><br><span class="line"></span><br><span class="line">mbedtls_x509_crt_parse(&amp;cacert, root_cert_pem_start,</span><br><span class="line">                      root_cert_pem_end - root_cert_pem_start);</span><br><span class="line"></span><br><span class="line">mbedtls_ssl_conf_ca_chain(&amp;conf, &amp;cacert, NULL);</span><br><span class="line">mbedtls_ssl_conf_authmode(&amp;conf, MBEDTLS_SSL_VERIFY_REQUIRED);  // 强制证书校验</span><br></pre></td></tr></table></figure><p><strong>证书验证回调（可选）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int my_verify(void *data, mbedtls_x509_crt *crt, int depth, uint32_t *flags)</span><br><span class="line">&#123;</span><br><span class="line">    if (*flags) &#123;</span><br><span class="line">        ESP_LOGW(TAG, &quot;证书验证失败，错误码: %x&quot;, *flags);</span><br><span class="line">        return -1;  // 验证失败</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, &quot;证书验证成功&quot;);</span><br><span class="line">    return 0;  // 验证通过</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mbedtls_ssl_conf_verify(&amp;conf, my_verify, NULL);</span><br></pre></td></tr></table></figure><hr><h3 id="🔹-Step-4：密钥交换-Key-Exchange"><a href="#🔹-Step-4：密钥交换-Key-Exchange" class="headerlink" title="🔹 Step 4：密钥交换 (Key Exchange)"></a><strong>🔹 Step 4：密钥交换 (Key Exchange)</strong></h3><p>客户端和服务器使用 <code>Random_C</code> 和 <code>Random_S</code> 生成共享密钥。</p><ul><li>支持的密钥交换算法包括：<ul><li><strong>ECDHE</strong>（椭圆曲线 Diffie-Hellman）</li><li><strong>RSA</strong>（更常用）</li></ul></li></ul><p>在 ESP-IDF 中，mbedTLS 自动完成此步骤。</p><hr><h3 id="🔹-Step-5：Finished（握手完成）"><a href="#🔹-Step-5：Finished（握手完成）" class="headerlink" title="🔹 Step 5：Finished（握手完成）"></a><strong>🔹 Step 5：Finished（握手完成）</strong></h3><ul><li>客户端发送 <code>Finished</code> 消息，确认握手完成。</li><li>服务器响应 <code>Finished</code> 消息，确认通信已加密。</li></ul><p><strong>示例代码：触发握手</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ret = mbedtls_ssl_handshake(&amp;ssl);</span><br><span class="line">if (ret != 0) &#123;</span><br><span class="line">    ESP_LOGE(TAG, &quot;TLS/SSL 握手失败: -0x%x&quot;, -ret);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">ESP_LOGI(TAG, &quot;TLS/SSL 握手成功&quot;);</span><br></pre></td></tr></table></figure><hr><h3 id="🟢-阶段-3：加密数据传输"><a href="#🟢-阶段-3：加密数据传输" class="headerlink" title="🟢 阶段 3：加密数据传输"></a><strong>🟢 阶段 3：加密数据传输</strong></h3><p>完成 TLS 握手后，ESP32 使用 <code>mbedtls_ssl_write()</code> 和 <code>mbedtls_ssl_read()</code> 发送和接收加密数据。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const char *request = &quot;GET / HTTP/1.1\r\nHost: example.com\r\n\r\n&quot;;</span><br><span class="line">mbedtls_ssl_write(&amp;ssl, (const unsigned char *)request, strlen(request));</span><br><span class="line"></span><br><span class="line">char response[1024];</span><br><span class="line">mbedtls_ssl_read(&amp;ssl, (unsigned char *)response, sizeof(response));</span><br><span class="line">ESP_LOGI(TAG, &quot;服务器响应:\n%s&quot;, response);</span><br></pre></td></tr></table></figure><hr><h1 id="三、TLS-握手失败的常见原因及解决方法"><a href="#三、TLS-握手失败的常见原因及解决方法" class="headerlink" title="三、TLS 握手失败的常见原因及解决方法"></a><strong>三、TLS 握手失败的常见原因及解决方法</strong></h1><table><thead><tr><th>错误码</th><th>错误信息</th><th>可能原因</th><th>解决方法</th></tr></thead><tbody><tr><td><code>-0x2700</code></td><td><code>MBEDTLS_ERR_X509_CERT_VERIFY_FAILED</code></td><td>证书验证失败</td><td>检查根证书是否正确</td></tr><tr><td><code>-0x4f00</code></td><td><code>MBEDTLS_ERR_SSL_CONN_EOF</code></td><td>服务器关闭连接</td><td>检查服务器配置</td></tr><tr><td><code>-0x7100</code></td><td><code>MBEDTLS_ERR_SSL_PEER_CLOSE_NOTIFY</code></td><td>服务器主动关闭连接</td><td>检查证书有效性及加密算法</td></tr><tr><td><code>-0x3f00</code></td><td><code>MBEDTLS_ERR_SSL_HANDSHAKE_FAILURE</code></td><td>握手失败</td><td>检查客户端和服务器的 TLS 版本及算法</td></tr></tbody></table><h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a><strong>四、总结</strong></h1><p>ESP32 TLS 握手流程由 <code>mbedtls_ssl_handshake()</code> 主导，涵盖：</p><p>✅ <strong>TCP 连接</strong><br> ✅ <strong>ClientHello &#x2F; ServerHello</strong><br> ✅ <strong>证书验证</strong><br> ✅ <strong>密钥交换</strong><br> ✅ <strong>Finished（握手完成）</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ESP32-HTTPS-通信中的-TLS-握手及证书验证详解&quot;&gt;&lt;a href=&quot;#ESP32-HTTPS-通信中的-TLS-握手及证书验证详解&quot; class=&quot;headerlink&quot; title=&quot;ESP32 HTTPS 通信中的 TLS 握手及证书验证详解&quot;&gt;</summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>ECDHE密钥交换的原理</title>
    <link href="http://example.com/2025/03/19/ECDHE%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2025/03/19/ECDHE%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2025-03-19T14:35:38.000Z</published>
    <updated>2025-03-19T14:36:59.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="🔹-ECDHE-密钥交换的原理-—-为什么客户端和服务器计算的密钥是一样的？"><a href="#🔹-ECDHE-密钥交换的原理-—-为什么客户端和服务器计算的密钥是一样的？" class="headerlink" title="🔹 ECDHE 密钥交换的原理 — 为什么客户端和服务器计算的密钥是一样的？"></a><strong>🔹 ECDHE 密钥交换的原理 — 为什么客户端和服务器计算的密钥是一样的？</strong></h2><p>密钥交换的核心在于：<strong>客户端和服务器通过不同的路径计算，最终能得到相同的共享密钥</strong>。这背后的原理来自于 <strong>椭圆曲线 Diffie-Hellman (ECDH)</strong> 算法的数学特性。</p><h1 id="🔹-一、ECDHE-核心数学原理"><a href="#🔹-一、ECDHE-核心数学原理" class="headerlink" title="🔹 一、ECDHE 核心数学原理"></a><strong>🔹 一、ECDHE 核心数学原理</strong></h1><p>ECDHE（Elliptic Curve Diffie-Hellman Ephemeral）基于椭圆曲线密码学 (ECC) 的数学性质。其核心依赖以下公式：</p><h3 id="🔢-公式推导"><a href="#🔢-公式推导" class="headerlink" title="🔢 公式推导"></a><strong>🔢 公式推导</strong></h3><ol><li><strong>选择公共参数</strong></li></ol><blockquote><p>🔹 双方协商并选择相同的椭圆曲线参数：</p></blockquote><ul><li><strong>椭圆曲线参数</strong> <code>G</code>（基点，已知的固定点）</li><li><strong>椭圆曲线的素数阶数</strong> <code>p</code>（模运算的模数，防止溢出）</li></ul><ol><li><strong>客户端生成密钥对</strong></li></ol><ul><li>随机生成私钥 <strong><code>d_C</code></strong></li><li>计算公钥 <strong><code>Q_C = d_C × G</code></strong></li></ul><ol><li><strong>服务器生成密钥对</strong></li></ol><ul><li>随机生成私钥 <strong><code>d_S</code></strong></li><li>计算公钥 <strong><code>Q_S = d_S × G</code></strong></li></ul><ol><li><strong>客户端和服务器交换公钥</strong></li></ol><ul><li>客户端发送 <code>Q_C</code></li><li>服务器发送 <code>Q_S</code></li></ul><ol><li><strong>双方计算共享密钥 (Z)</strong></li></ol><ul><li><strong>客户端计算</strong></li></ul><p>Z&#x3D;dC×QS&#x3D;dC×(dS×G)Z &#x3D; d_C \times Q_S &#x3D; d_C \times (d_S \times G)Z&#x3D;dC×QS&#x3D;dC×(dS×G)</p><ul><li><strong>服务器计算</strong></li></ul><p>Z&#x3D;dS×QC&#x3D;dS×(dC×G)Z &#x3D; d_S \times Q_C &#x3D; d_S \times (d_C \times G)Z&#x3D;dS×QC&#x3D;dS×(dC×G)</p><ol><li><strong>根据交换律 (交换群的性质)：</strong></li></ol><p>dC×dS×G&#x3D;dS×dC×Gd_C \times d_S \times G &#x3D; d_S \times d_C \times GdC×dS×G&#x3D;dS×dC×G</p><p>✅ <strong>最终，客户端和服务器得到相同的共享密钥 <code>Z</code></strong></p><hr><h1 id="🔹-二、为什么攻击者无法推导出密钥？"><a href="#🔹-二、为什么攻击者无法推导出密钥？" class="headerlink" title="🔹 二、为什么攻击者无法推导出密钥？"></a><strong>🔹 二、为什么攻击者无法推导出密钥？</strong></h1><p>ECDHE 的安全性来自于以下数学难题：</p><h3 id="🔒-椭圆曲线离散对数问题-ECDLP"><a href="#🔒-椭圆曲线离散对数问题-ECDLP" class="headerlink" title="🔒 椭圆曲线离散对数问题 (ECDLP)"></a>🔒 <strong>椭圆曲线离散对数问题 (ECDLP)</strong></h3><blockquote><p>已知公钥 <code>Q = d × G</code>，要反推出私钥 <code>d</code> 几乎不可能。</p></blockquote><p>🔹 椭圆曲线的点运算不支持传统加法&#x2F;乘法逆运算<br> 🔹 ECDHE 的私钥 <code>d</code> 具有非常高的熵值，随机性强<br> 🔹 即便攻击者拦截了 <code>Q_C</code> 和 <code>Q_S</code>，仍无法直接推算出 <code>d_C</code> 或 <code>d_S</code></p><hr><h1 id="🔹-三、ECDHE-密钥交换的安全性分析"><a href="#🔹-三、ECDHE-密钥交换的安全性分析" class="headerlink" title="🔹 三、ECDHE 密钥交换的安全性分析"></a><strong>🔹 三、ECDHE 密钥交换的安全性分析</strong></h1><p>✅ <strong>前向安全性 (Forward Secrecy)</strong></p><ul><li>即便服务器私钥泄露，历史通信数据依然安全。</li><li>每次握手使用随机的临时密钥对，确保加密数据独立。</li></ul><p>✅ <strong>抗中间人攻击 (MitM)</strong></p><ul><li>客户端会验证服务器的证书，确保 <code>Q_S</code> 来自合法服务器。</li><li>服务器也会验证客户端的公钥，防止非法客户端接入。</li></ul><p>✅ <strong>数学安全性</strong></p><ul><li>ECDHE 依赖于 ECDLP（椭圆曲线离散对数问题），比 RSA 更难破解。</li><li>常用的 <code>secp256r1</code> (NIST P-256) 提供 128 位安全性，满足现代加密需求。</li></ul><hr><h1 id="🔹-四、代码演示-—-ECDHE-密钥交换的完整实现"><a href="#🔹-四、代码演示-—-ECDHE-密钥交换的完整实现" class="headerlink" title="🔹 四、代码演示 — ECDHE 密钥交换的完整实现"></a><strong>🔹 四、代码演示 — ECDHE 密钥交换的完整实现</strong></h1><p>以下是 ESP32 使用 <code>mbedTLS</code> 进行 ECDHE 密钥交换的代码示例：</p><h3 id="🔹-客户端生成公私钥对"><a href="#🔹-客户端生成公私钥对" class="headerlink" title="🔹 客户端生成公私钥对"></a><strong>🔹 客户端生成公私钥对</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_context ecdh;</span><br><span class="line">mbedtls_ecdh_init(&amp;ecdh);</span><br><span class="line"></span><br><span class="line">// 选择椭圆曲线参数 (推荐 secp256r1)</span><br><span class="line">mbedtls_ecp_group_load(&amp;ecdh.grp, MBEDTLS_ECP_DP_SECP256R1);</span><br><span class="line"></span><br><span class="line">// 生成私钥 d_C，并计算公钥 Q_C</span><br><span class="line">mbedtls_ecdh_gen_public(&amp;ecdh.grp, &amp;ecdh.d, &amp;ecdh.Q,</span><br><span class="line">                        mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h3 id="🔹-服务器生成公私钥对"><a href="#🔹-服务器生成公私钥对" class="headerlink" title="🔹 服务器生成公私钥对"></a><strong>🔹 服务器生成公私钥对</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_gen_public(&amp;ecdh.grp, &amp;ecdh.d, &amp;ecdh.Q,</span><br><span class="line">                        mbedtls_ctr_drbg_random, &amp;ctr_drbg);</span><br></pre></td></tr></table></figure><hr><h3 id="🔹-共享密钥计算-Pre-Master-Secret"><a href="#🔹-共享密钥计算-Pre-Master-Secret" class="headerlink" title="🔹 共享密钥计算 (Pre-Master Secret)"></a><strong>🔹 共享密钥计算 (Pre-Master Secret)</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ecdh_compute_shared(</span><br><span class="line">    &amp;ecdh.grp,      // 椭圆曲线参数</span><br><span class="line">    &amp;ecdh.z,        // 输出的共享密钥 (Pre-Master Secret)</span><br><span class="line">    &amp;ecdh.Qp,       // 对方公钥</span><br><span class="line">    &amp;ecdh.d,        // 本地私钥</span><br><span class="line">    mbedtls_ctr_drbg_random, &amp;ctr_drbg</span><br><span class="line">);</span><br></pre></td></tr></table></figure><hr><h3 id="🔹-最终-Master-Secret-生成"><a href="#🔹-最终-Master-Secret-生成" class="headerlink" title="🔹 最终 Master Secret 生成"></a><strong>🔹 最终 Master Secret 生成</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c</span><br><span class="line">mbedtls_ssl_derive_keys(&amp;ssl);  // 将共享密钥转化为 Master Secret</span><br></pre></td></tr></table></figure><hr><h1 id="🔹-五、常见问题与解答"><a href="#🔹-五、常见问题与解答" class="headerlink" title="🔹 五、常见问题与解答"></a><strong>🔹 五、常见问题与解答</strong></h1><table><thead><tr><th><strong>问题</strong></th><th><strong>原因</strong></th><th><strong>解决方法</strong></th></tr></thead><tbody><tr><td><strong>密钥不一致</strong></td><td>双方选择了不同的椭圆曲线参数</td><td>确保 <code>G</code>、<code>p</code> 等参数相同</td></tr><tr><td><strong>握手失败 (Handshake Failure)</strong></td><td>证书验证失败</td><td>检查证书链完整性及域名匹配</td></tr><tr><td><strong>握手超时</strong></td><td>网络延迟或丢包</td><td>调整 <code>timeout</code> 设置并重试</td></tr><tr><td><strong><code>MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN</code></strong></td><td>加密套件不兼容</td><td>选择兼容的加密套件 (如 <code>TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256</code>)</td></tr></tbody></table><hr><h1 id="🔹-六、总结"><a href="#🔹-六、总结" class="headerlink" title="🔹 六、总结"></a><strong>🔹 六、总结</strong></h1><p>🔹 ECDHE 之所以能让客户端和服务器生成相同的密钥，依赖于：<br> ✅ <strong>椭圆曲线点乘的交换律</strong><br> ✅ <strong>公钥点无法反推出私钥的 ECDLP 数学难题</strong></p><p>🔹 ECDHE 结合 <code>TLS</code> 提供了强大的安全保障，ESP32 在使用 HTTPS、MQTT、WebSocket 等网络通信中广泛应用 ECDHE。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;🔹-ECDHE-密钥交换的原理-—-为什么客户端和服务器计算的密钥是一样的？&quot;&gt;&lt;a href=&quot;#🔹-ECDHE-密钥交换的原理-—-为什么客户端和服务器计算的密钥是一样的？&quot; class=&quot;headerlink&quot; title=&quot;🔹 ECDHE 密钥交换的</summary>
      
    
    
    
    
    <category term="ESP32_TLS" scheme="http://example.com/tags/ESP32-TLS/"/>
    
  </entry>
  
  <entry>
    <title>nr_micro_shell移植使用详解</title>
    <link href="http://example.com/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-12-02T09:32:24.000Z</published>
    <updated>2024-12-02T11:18:15.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nr-micro-shell的移植使用"><a href="#nr-micro-shell的移植使用" class="headerlink" title="nr_micro_shell的移植使用"></a>nr_micro_shell的移植使用</h2><h3 id="nr-micro-shell的移植"><a href="#nr-micro-shell的移植" class="headerlink" title="nr_micro_shell的移植"></a>nr_micro_shell的移植</h3><p>1、点击下载链接下载nr_micro_shell的源文件。</p><p><a href="https://github.com/Nrusher/nr_micro_shell">https://github.com/Nrusher/nr_micro_shell</a></p><p>2、下载完成之后获取nr_micro_shell_master文件夹，将文件夹nr_micro_shell_master文件夹拷贝到工程目录下。</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202173927722.png" alt="image-20241202173927722"></p><p>3、找到并打开nr_micro_shell_config.h文件，进行配置。</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202174724870.png" alt="image-20241202174724870"></p><ul><li><p>需要定义宏NR_MICRO_SHELL_SIMULATOR(使用裸机配置)</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202174920464.png" alt="image-20241202174920464"></p></li><li><p>修改NR_SHELL_END_OF_LINE的值为2(使用\r\n作为结束符)</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202175031888.png" alt="image-20241202175031888"></p></li></ul><p>4、定义static_cmd_st数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const static_cmd_st static_cmd[10] = &#123;0&#125;;</span><br></pre></td></tr></table></figure><p>5、初始化shell。</p><p>使用shell_init()函数初始shell解析器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell_init();</span><br></pre></td></tr></table></figure><p>6、实现UART数据交互接口，调用shell()进行数据解析。</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202175304113.png" alt="image-20241202175304113"></p><p>7、需要实现printf的串口重定向操作。</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202180326126.png" alt="image-20241202180326126"></p><p>8、如果需要实现回显功能需要在接收数据的时候发送接收的数据到发送端。</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202191754911.png" alt="image-20241202191754911"></p><h3 id="nr-micro-shell的注册使用"><a href="#nr-micro-shell的注册使用" class="headerlink" title="nr_micro_shell的注册使用"></a>nr_micro_shell的注册使用</h3><p>为了方便注册和使用，新建文件nr_shell.c和nr_shell.h用来管理shell命令的注册使用。</p><p>1、修改nr_shell数据结构，去掉const字段</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202183129024.png" alt="image-20241202183129024"></p><p>2、static_cmd_st去掉const字段</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202183334304.png" alt="image-20241202183334304"></p><p>3、注释掉nr_micro_shell.c下面的nr_shell</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202184233553.png" alt="image-20241202184233553"></p><p>4、添加nr_shell到nr_shell.c文件下面</p><p><img src="/2024/12/02/nr-micro-shell%E7%A7%BB%E6%A4%8D%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3/image-20241202184330837.png" alt="image-20241202184330837"></p><p>5、实现nr_shell_command_register，实现help显示和多参数示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdint.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;nr_shell.h&quot;</span><br><span class="line">#include &quot;nr_micro_shell.h&quot;</span><br><span class="line"></span><br><span class="line">#define SHELL_COMMAND_MAX_NUM(50)</span><br><span class="line">#define ARGV(a,b) (a + *(a + b))</span><br><span class="line"></span><br><span class="line">static static_cmd_st static_cmd[SHELL_COMMAND_MAX_NUM] = &#123;0&#125;;</span><br><span class="line">shell_st nr_shell = &#123;.user_name = NR_SHELL_USER_NAME,.static_cmd = nr_cmd_start_add,&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void nr_shell_help_command(char argc, char *argv)</span><br><span class="line">&#123;</span><br><span class="line">int16_t i = 0u;</span><br><span class="line"></span><br><span class="line">if (strcmp(&quot;help&quot;, ARGV(argv, 0)) == 0)</span><br><span class="line">&#123;</span><br><span class="line">for (i = 0u; nr_shell.static_cmd[i].fp != NULL; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;%-8s %s\r\n&quot;, (char *)nr_shell.static_cmd[i].cmd, nr_shell.static_cmd[i].description != NULL ? nr_shell.static_cmd[i].description : &quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void nr_shell_mul_param_command(char argc, char *argv)</span><br><span class="line">&#123;</span><br><span class="line">if (argv == NULL)</span><br><span class="line">&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;argc: %d\r\n&quot;,argc);</span><br><span class="line">for (int i = 1; i &lt; argc; i++)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;argv[%d]: %s\r\n&quot;,i,ARGV(argv, i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int nr_shell_command_register(char *name, shell_fun_t func, char *description)</span><br><span class="line">&#123;</span><br><span class="line">    uint32_t i, num;</span><br><span class="line"></span><br><span class="line">    if (strlen(name) &gt; NR_SHELL_CMD_NAME_MAX_LENGTH)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    num = sizeof(static_cmd) / sizeof(static_cmd[0]);</span><br><span class="line"></span><br><span class="line">    for (i = 0; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((strlen(static_cmd[i].cmd) == 0) &amp;&amp; (static_cmd[i].fp == NULL))</span><br><span class="line">        &#123;</span><br><span class="line">            (void)strcpy(static_cmd[i].cmd, name);</span><br><span class="line">            static_cmd[i].fp = func;</span><br><span class="line">            static_cmd[i].description = description;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if (i == num - 1)</span><br><span class="line">        &#123;</span><br><span class="line">            return -2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void nr_shell_init(void)</span><br><span class="line">&#123;</span><br><span class="line">nr_shell_command_register(&quot;help&quot;, nr_shell_help_command,&quot;帮助信息&quot;);</span><br><span class="line">nr_shell_command_register(&quot;param&quot;, nr_shell_mul_param_command, &quot;测试参数&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;nr-micro-shell的移植使用&quot;&gt;&lt;a href=&quot;#nr-micro-shell的移植使用&quot; class=&quot;headerlink&quot; title=&quot;nr_micro_shell的移植使用&quot;&gt;&lt;/a&gt;nr_micro_shell的移植使用&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
    <category term="NR_MICRO_SHELL" scheme="http://example.com/tags/NR-MICRO-SHELL/"/>
    
  </entry>
  
  <entry>
    <title>SFUD串行flash通用库的移植</title>
    <link href="http://example.com/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/"/>
    <id>http://example.com/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/</id>
    <published>2024-12-01T10:24:17.000Z</published>
    <updated>2024-12-01T11:10:27.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sfud移植使用"><a href="#sfud移植使用" class="headerlink" title="sfud移植使用"></a>sfud移植使用</h1><h3 id="sfud的移植"><a href="#sfud的移植" class="headerlink" title="sfud的移植"></a>sfud的移植</h3><p>1、点击链接下载sufd串行flash通用库。</p><p><a href="https://github.com/armink/SFUD">GitHub - armink&#x2F;SFUD: An using JEDEC’s SFDP standard serial (SPI) flash universal driver library | 一款使用 JEDEC SFDP 标准的串行 (SPI) Flash 通用驱动库</a></p><p>2、下载完成之后获取sfud文件夹，将sfud文件夹拷贝到工程目录下</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201183310406.png" alt="image-20241201183310406"></p><p>3、填充sfud_port.c接口文件</p><ul><li>找到sfud_port.c文件</li></ul><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201183510034.png" alt="image-20241201183510034"></p><ul><li>填充sfud_port.c文件里面的spi_write_read读写接口</li></ul><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201183549099.png" alt="image-20241201183549099"></p><p>4、移植完成之后可以进行测试</p><p>如果是sfud支持的flash库，调用sfud_init()函数初始化flash,可以打印如下日志。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_init();</span><br></pre></td></tr></table></figure><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201183918874.png" alt="image-20241201183918874"></p><h2 id="sfud的文件系统的移植"><a href="#sfud的文件系统的移植" class="headerlink" title="sfud的文件系统的移植"></a>sfud的文件系统的移植</h2><p>移植文件系统之前确保sufd正常工作。</p><p>1、找到并且打开FatFs&#x2F;src文件夹下面的discio.c文件。</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201184452157.png" alt="image-20241201184452157"></p><p>2、实现FATFS的读写操作函数。</p><ul><li><p>FATFS初始化函数的实现。</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201184941319.png" alt="image-20241201184941319"></p></li><li><p>FATFS读函数的实现</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201185007314.png" alt="image-20241201185007314"></p></li><li><p>FATFS写函数的实现</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201185041724.png" alt="image-20241201185041724"></p></li><li><p>FATFS函数功能函数的实现</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201185233495.png" alt="image-20241201185233495"></p></li></ul><p>3、完成上面几步，基本配置完成FATFS文件系统。</p><p>4、如果文件系统挂载不上的话（确保sfud是正常使用的情况下），可以判断一下FLASH是否格式化，如果没有的话使用f_mkfs（）函数格式化文件系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//格式化为FATFS格式，使用静态内存格式化，格式化磁盘编号为0</span><br><span class="line">static BYTE work[_MAX_SS];</span><br><span class="line">f_mkfs(&quot;0:&quot;,FM_FAT32, 0, work, sizeof(work));</span><br></pre></td></tr></table></figure><h2 id="SFUD的函数基本使用"><a href="#SFUD的函数基本使用" class="headerlink" title="SFUD的函数基本使用"></a>SFUD的函数基本使用</h2><p>1、SFUD的初始化函数</p><ul><li><p>初始化全部flash对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_init(void);</span><br></pre></td></tr></table></figure></li><li><p>初始化单个flash对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_device_init(sfud_flash *flash);</span><br><span class="line"></span><br><span class="line">sfud_flash sfud_norflash0 = &#123;</span><br><span class="line">        .name = &quot;norflash0&quot;,</span><br><span class="line">        .spi.name = &quot;SPI1&quot;,</span><br><span class="line">        .chip = &#123; &quot;W25Q64FV&quot;, SFUD_MF_ID_WINBOND, 0x40, 0x17, 8L * 1024L * 1024L, SFUD_WM_PAGE_256B, 4096, 0x20 &#125; &#125;;</span><br><span class="line">sfud_device_init(&amp;sfud_norflash0);</span><br></pre></td></tr></table></figure></li></ul><p>2、找到指定的flash对象函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_flash *sfud_get_device(size_t index);</span><br></pre></td></tr></table></figure><p>3、获取flash对象个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size_t sfud_get_device_num(void);</span><br></pre></td></tr></table></figure><p>4、获取flash初始化静态表</p><p>如果使用表的方式初始化，调用函数获取表的首地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const sfud_flash *sfud_get_device_table(void);</span><br></pre></td></tr></table></figure><p>5、sfud的读写擦除函数</p><ul><li><p>sfud读函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_read(const sfud_flash *flash, uint32_t addr, size_t size, uint8_t *data);</span><br></pre></td></tr></table></figure></li><li><p>sfud写函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_write(const sfud_flash *flash, uint32_t addr, size_t size, const uint8_t *data);</span><br></pre></td></tr></table></figure></li><li><p>sfud擦除函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_erase(const sfud_flash *flash, uint32_t addr, size_t size);</span><br></pre></td></tr></table></figure></li><li><p>sfud写擦除函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_erase_write(const sfud_flash *flash, uint32_t addr, size_t size, const uint8_t *data);</span><br></pre></td></tr></table></figure></li></ul><p>6、获取寄存器状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sfud_err sfud_read_status(const sfud_flash *flash, uint8_t *status);</span><br></pre></td></tr></table></figure><h2 id="SFUD的不支持的FLASH配置"><a href="#SFUD的不支持的FLASH配置" class="headerlink" title="SFUD的不支持的FLASH配置"></a>SFUD的不支持的FLASH配置</h2><p>如果sfud不支持的flash可以通过配置表来手动支持。</p><p>修改SFUD_FLASH_CHIP_TABLE和SFUD_MF_TABLE来支持。</p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201190856907.png" alt="image-20241201190856907"></p><p><img src="/2024/12/01/SFUD%E4%B8%B2%E8%A1%8Cflash%E9%80%9A%E7%94%A8%E5%BA%93%E7%9A%84%E7%A7%BB%E6%A4%8D/image-20241201190958333.png" alt="image-20241201190958333"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;sfud移植使用&quot;&gt;&lt;a href=&quot;#sfud移植使用&quot; class=&quot;headerlink&quot; title=&quot;sfud移植使用&quot;&gt;&lt;/a&gt;sfud移植使用&lt;/h1&gt;&lt;h3 id=&quot;sfud的移植&quot;&gt;&lt;a href=&quot;#sfud的移植&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="FLASH" scheme="http://example.com/tags/FLASH/"/>
    
  </entry>
  
  <entry>
    <title>TCP和UDP详解</title>
    <link href="http://example.com/2023/12/12/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://example.com/2023/12/12/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/</id>
    <published>2023-12-12T01:48:21.000Z</published>
    <updated>2023-12-12T05:44:56.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解TCP和UDP协议及两者的区别"><a href="#深入理解TCP和UDP协议及两者的区别" class="headerlink" title="深入理解TCP和UDP协议及两者的区别"></a>深入理解TCP和UDP协议及两者的区别</h1><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><pre><code> **位于传输层**， 提供**可靠的字节流服务**。所谓的字节流服务（Byte Stream Service） 是指， 为了方便传输， 将大块数据分割成以报文段（segment） 为单位的数据包进行管理。 而可靠的传输服务是指， 能够把数据准确可靠地传给对方。 即TCP 协议为了更容易传送大数据才把数据分割， 而且 TCP 协议能够确认数据最终是否送达到对方。所以，TCP连接相当于**两根管道**（一个用于服务器到客户端，一个用于客户端到服务器），管道里面数据传输是通过字节码传输，**传输是有序的**，每个字节都是一个一个来传输。</code></pre><h3 id="TCP协议的三次握手和四次挥手"><a href="#TCP协议的三次握手和四次挥手" class="headerlink" title="TCP协议的三次握手和四次挥手"></a>TCP协议的三次握手和四次挥手</h3><p><img src="/2023/12/12/TCP%E5%92%8CUDP%E8%AF%A6%E8%A7%A3/image-20231212111941571.png" alt="image-20231212111941571"></p><h4 id="1、三次握手"><a href="#1、三次握手" class="headerlink" title="1、三次握手"></a>1、三次握手</h4><p>​握手过程中使用了TCP标志（flag），SYN（synchronize），ACK（acknowledgement）。</p><ul><li>第一次握手：建立连接，客户端发送SYN包（SYN &#x3D; j）到服务器，并进入SYN_SEND（等待匹配的连接请求）状态，等待服务器确认。</li><li>第二次握手：服务器接收到SYN包，必须确认客户端的SYN（AKC &#x3D; j + 1），同时自己也发送一个SYN包（SYN &#x3D; k），即服务器发送一个SYN包和ACK包，此时服务器进入SYN_RECV（在收到和发送一个连接请求后等待确认）状态。</li><li>第三次握手：客户端接收到服务器的SYN + ACK包，向服务器发送ACK（AKC &#x3D; k + 1）包，此包发送完毕，完成三次握手。此时进入ESTABLISHED（代表一个打开的连接，可以进入数据传输）状态。</li></ul><h5 id="客户端的TCP状态迁移"><a href="#客户端的TCP状态迁移" class="headerlink" title="客户端的TCP状态迁移"></a>客户端的TCP状态迁移</h5><p>CLOSED —-&gt; SYN_SEND —–&gt; ESTABLISHED —–&gt; FIN_WAIT_1 —–&gt; FIN_WAIT_2 —–&gt; TIME_WAIT —–&gt; CLOSED</p><h5 id="服务器TCP状态迁移"><a href="#服务器TCP状态迁移" class="headerlink" title="服务器TCP状态迁移"></a>服务器TCP状态迁移</h5><p>CLOSED —–&gt; LISTEN —–&gt;  SYN收到 —–&gt; ESTABLISHED —–&gt; CLOSE_WAIT —–&gt; LAST_ACK —–&gt; CLOSED</p><p>​<strong>若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包</strong></p><h4 id="2-、-四次挥手"><a href="#2-、-四次挥手" class="headerlink" title="2 、 四次挥手"></a>2 、 四次挥手</h4><p>​TCP的连接是全双工的，因此每个方向必须单独进行关闭，这个原则是当一方完成他的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着一个方向上没有数据流动，一个TCP连接在收到一个FIN后仍然能发送数据。先进行关闭的一方将执行主动关闭，而另一方被动关闭。</p><ul><li>第一次挥手：客户端发送一个FIN包（M），用来关闭客户端到服务器的数据传输。</li><li>第二次挥手：服务器收到FIN包，向客户端发送一个ACK包（M + 1），确认序号为收到序号加一。</li><li>第三次挥手：服务器关闭与客户端的连接，发送一个FIN包给客户端（N）。</li><li>第四次挥手：客户端接收到FIN包，并返回ACK包（N + 1）给服务器，至此服务器和客户端双双断开连接。</li></ul><p>三次握手个四次挥手：在TCP连接过程中，服务端的SYN和ACK向客户端是一次性发送的，而在断开连接的过程中，服务器向客户端发送的ACK和FIN是分两次发送的。因为在服务器收到客户端的FIN后，服务器可能还有数据传输，所以服务器先向客户端发送ACK，等服务器处理完成自己的事后就可以向客户端发送FIN断开连接。</p><h4 id="3-、深入理解TCP连接"><a href="#3-、深入理解TCP连接" class="headerlink" title="3 、深入理解TCP连接"></a>3 、深入理解TCP连接</h4><p>​由于TCP是全双工的，因此在每一个方向都必须单独关闭。这原则是当一方完成他的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只是意味着这个方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。</p><p>​首先进行关闭的一方将执行主动关闭，而另一方则被动关闭。</p><p>​TCP协议的连接是全双工连接，一个TCP连接存在双向的读写通道。简单来说是 <strong>”先关读，在关写“</strong>，总共需要4个阶段。</p><p>以客户端发起关闭连接为例：</p><ul><li>服务器读通道关闭</li><li>客户端写通道关闭</li><li>客户端读通道关闭</li><li>服务器写通道关闭</li></ul><p>关闭行为是发起方数据发送完毕之后，给对方发出一个FIN的数据段，直到接收到对方发送的FIN，且对方收到了接收到了接收确认的ACK之后，双方的数据通信完全结束，<strong>过程中每次都需要返回确认数据段ACK</strong></p><h4 id="4、TCP使用滑动窗口机制来进行流量控制"><a href="#4、TCP使用滑动窗口机制来进行流量控制" class="headerlink" title="4、TCP使用滑动窗口机制来进行流量控制"></a>4、TCP使用滑动窗口机制来进行流量控制</h4><p>TCP建立连接时，各端分配一个缓冲用来存储接收数据，并将缓冲区的尺寸发送到另一端。<strong>接收方发送的确认消息中包含了自己剩余缓冲区尺寸</strong>。剩余缓冲区控件的数量交做窗口。其实就是建立练级的双方互相直到彼此剩余的缓冲区大小。</p><h4 id="5、阻塞控制"><a href="#5、阻塞控制" class="headerlink" title="5、阻塞控制"></a>5、阻塞控制</h4><p>阻塞控制：防止过多的数据注入到网络中，这样可以时网络中的路由器或链路不至于阻塞。阻塞控制是一个全局性的过程，和流量控制不同，流量控制是点对点的控制。</p><h5 id="1、-慢开始"><a href="#1、-慢开始" class="headerlink" title="1、 慢开始"></a>1、 慢开始</h5><p>​发送方维持一个叫做拥塞窗口cwnd的状态变量。<strong>拥塞窗口的大小取决于网络的拥塞程度，并且动态的变化。</strong>发送方让自己的发送窗口等于拥塞窗口，另外考虑到接收方的接收能力，发送窗口可能小于拥塞窗口。思路就是：<strong>不要一开始就发送大量的数据，先试探一下网络的拥塞程度，也就是说由小到大增加拥塞窗口的大小</strong>。为了防止cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量。 ssthresh的方法如下：<br>当cwnd &lt; ssthresh时，开始使用慢开始算法；当cwnd &gt; ssthresh, 改用拥塞避免算法；当cwnd &#x3D; ssthresh时，慢开始与拥塞算法任意。</p><h5 id="2、阻塞避免"><a href="#2、阻塞避免" class="headerlink" title="2、阻塞避免"></a>2、阻塞避免</h5><p>​拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按照线性规律缓慢增长。无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为⽆法判定，所以都当作拥塞处理），就把慢开始门限设置为出现拥塞时的发送窗口的一半，然后把拥塞窗口设置为1，执行慢开始算法：</p><h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>无连接协议，也称透明协议，位于传输层。</p><h4 id="UDP协议和TCP协议的区别"><a href="#UDP协议和TCP协议的区别" class="headerlink" title="UDP协议和TCP协议的区别"></a>UDP协议和TCP协议的区别</h4><ul><li>TCP提供面向面连接的传输，通信前要先建立连接（三次握手）。UDP提供无连接的传输，通信前不需要建立连接。</li><li>TCP提供可靠的传输（有序，无差错，不丢失，不重复）。UDP提供不可靠的传输。</li><li>TCP面向字节流的传输，因此它能将信息分割成组，并在接收端将其重组。UDP面向数据报的传输，没有分组开销。</li><li>TCP提供阻塞控制和流量控制。UDP不提供阻塞控制和流量控制机制。</li></ul><h2 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h2><p>​HTTP的长连接和短链接本质上是<strong>TCP的长连接和短连接</strong>。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。IP协议主要是解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序和发送顺序一致。TCP是可靠的，是面向连接的。</p><p>​<strong>在HTTP&#x2F;1.0中默认使用短连接</strong>。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>​<strong>从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性</strong>。使用长连接的HTTP协议，会在响应头加入这行代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>​在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;深入理解TCP和UDP协议及两者的区别&quot;&gt;&lt;a href=&quot;#深入理解TCP和UDP协议及两者的区别&quot; class=&quot;headerlink&quot; title=&quot;深入理解TCP和UDP协议及两者的区别&quot;&gt;&lt;/a&gt;深入理解TCP和UDP协议及两者的区别&lt;/h1&gt;&lt;h2 i</summary>
      
    
    
    
    
    <category term="网络通信" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>RS232_RS485_TTL电平标准</title>
    <link href="http://example.com/2023/10/10/RS232-RS485-TTL%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/"/>
    <id>http://example.com/2023/10/10/RS232-RS485-TTL%E7%94%B5%E5%B9%B3%E6%A0%87%E5%87%86/</id>
    <published>2023-10-10T01:55:34.000Z</published>
    <updated>2023-10-10T02:22:09.818Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RS232-RS485-TTL电平标准"><a href="#RS232-RS485-TTL电平标准" class="headerlink" title="RS232 RS485 TTL电平标准"></a>RS232 RS485 TTL电平标准</h2><h3 id="RS232电平标准"><a href="#RS232电平标准" class="headerlink" title="RS232电平标准"></a>RS232电平标准</h3><h4 id="RS232通信模式："><a href="#RS232通信模式：" class="headerlink" title="RS232通信模式："></a>RS232通信模式：</h4><p>RS232是全双工通信。</p><h4 id="RS232的逻辑电平"><a href="#RS232的逻辑电平" class="headerlink" title="RS232的逻辑电平"></a>RS232的逻辑电平</h4><ul><li>逻辑1：-15V–5V </li><li>逻辑0：+3V–+15V</li></ul><p>RS232 的逻辑电平和TTL 不一样但是协议是一样的。</p><h2 id="RS485电平标准"><a href="#RS485电平标准" class="headerlink" title="RS485电平标准"></a>RS485电平标准</h2><h3 id="RS485通信模式"><a href="#RS485通信模式" class="headerlink" title="RS485通信模式"></a>RS485通信模式</h3><p>RS485是半双工通信</p><h3 id="RS485的逻辑电平"><a href="#RS485的逻辑电平" class="headerlink" title="RS485的逻辑电平"></a>RS485的逻辑电平</h3><ul><li>逻辑1：+2V–+6V (A - B)</li><li>逻辑0：-6V–+2V (A - B)</li><li>高阻态（控制信号未使能）</li></ul><p>这里的电平指AB两线间的电压差。</p><h2 id="TTL电平标准"><a href="#TTL电平标准" class="headerlink" title="TTL电平标准"></a>TTL电平标准</h2><h3 id="TTL通信模式‘"><a href="#TTL通信模式‘" class="headerlink" title="TTL通信模式‘"></a>TTL通信模式‘</h3><p>TTL是全双工通信</p><h3 id="TTL的逻辑电平"><a href="#TTL的逻辑电平" class="headerlink" title="TTL的逻辑电平"></a>TTL的逻辑电平</h3><ul><li>逻辑1: 2.4V–5V </li><li>逻辑0: 0V–0.5V</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RS232-RS485-TTL电平标准&quot;&gt;&lt;a href=&quot;#RS232-RS485-TTL电平标准&quot; class=&quot;headerlink&quot; title=&quot;RS232 RS485 TTL电平标准&quot;&gt;&lt;/a&gt;RS232 RS485 TTL电平标准&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Qt文件读写</title>
    <link href="http://example.com/2023/09/21/Qt%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"/>
    <id>http://example.com/2023/09/21/Qt%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/</id>
    <published>2023-09-21T08:17:49.000Z</published>
    <updated>2023-09-21T08:33:32.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt文件读写"><a href="#Qt文件读写" class="headerlink" title="Qt文件读写"></a>Qt文件读写</h2><h3 id="QFile"><a href="#QFile" class="headerlink" title="QFile"></a>QFile</h3><p>QFile 是一个读写文本、二进制文件和资源的 I&#x2F;O 设备。 QFile 可以自己使用，也可以更方便地与 QTextStream 或 QDataStream 一起使用。  </p><h4 id="QFile常用操作函数"><a href="#QFile常用操作函数" class="headerlink" title="QFile常用操作函数"></a>QFile常用操作函数</h4><ul><li>exists()检查文件是否存在  </li><li>remove()删除文件  </li><li>open()打开文件  </li><li>close()关闭文件  </li><li>flush()刷新文件  </li><li>read()读取文件</li><li>write()写入文件</li></ul><p>通常使用 QDataStream 或 QTextStream 读写数据，但也可以调用 QIODevice 继承的函数 read()、readLine()、 readAll()、 write()。 QFile 还继承 getChar()、 putChar()和 ungetChar()，它们一次只处理一个字符。文件的大小由 size()返回。可以使用 pos()获取当前文件位置，也可以使用 seek()移动到新的文件位置。如果已经到达文件的末尾，则 atEnd()返回 true。  </p><p>QFile::open()函数打开文件时需要传递 QIODevice::OpenModeFlag 枚举类型的参数，决定文件以什么方式打开， QIODevice::OpenModeFlag 类型的主要取值如下  </p><ul><li>QIODevice::ReadOnly：以只读方式打开文件，用于载入文件。  </li><li>QIODevice::WriteOnly：以只写方式打开文件，用于保存文件。</li><li>QIODevice::ReadWrite：以读写方式打开。  </li><li>QIODevice::Append：以添加模式打开，新写入文件的数据添加到文件尾部。  </li><li>QIODevice::Truncate：以截取方式打开文件，文件原有的内容全部被删除。</li><li>QIODevice::Text：以文本方式打开文件，读取时“\n”被自动翻译为换行符，写入时字符串结束符会自动翻译为系统平台的编码，如 Windows 平台下是“\r\n”。</li></ul><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QFileDialog&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    textEdit = new QTextEdit();</span><br><span class="line">    vBoxLayout = new QVBoxLayout();</span><br><span class="line">    hBoxLayout = new QHBoxLayout();</span><br><span class="line">    vWidget = new QWidget();</span><br><span class="line">    hWidget = new QWidget();</span><br><span class="line">    openFileButton = new QPushButton();</span><br><span class="line">    closeFileButton = new QPushButton();</span><br><span class="line">    /*设置两个按钮大小*/</span><br><span class="line">    openFileButton-&gt;setMaximumHeight(50);</span><br><span class="line">    openFileButton-&gt;setMaximumWidth(120);</span><br><span class="line">    closeFileButton-&gt;setMaximumHeight(50);</span><br><span class="line">    closeFileButton-&gt;setMaximumWidth(120);</span><br><span class="line"></span><br><span class="line">    openFileButton-&gt;setText(&quot;打开&quot;);</span><br><span class="line">    closeFileButton-&gt;setText(&quot;关闭&quot;);</span><br><span class="line"></span><br><span class="line">    /*将按钮设置为不可用*/</span><br><span class="line">    closeFileButton-&gt;setEnabled(false);</span><br><span class="line">    /*水平布局*/</span><br><span class="line">    hBoxLayout-&gt;addWidget(openFileButton);</span><br><span class="line">    hBoxLayout-&gt;addWidget(closeFileButton);</span><br><span class="line">    hWidget-&gt;setLayout(hBoxLayout);</span><br><span class="line">    /*垂直布局*/</span><br><span class="line">    vBoxLayout-&gt;addWidget(textEdit);</span><br><span class="line">    vBoxLayout-&gt;addWidget(hWidget);</span><br><span class="line">    vWidget-&gt;setLayout(vBoxLayout);</span><br><span class="line">    /*设置vWidget居中*/</span><br><span class="line">    setCentralWidget(vWidget);</span><br><span class="line"></span><br><span class="line">    connect(openFileButton,SIGNAL(clicked()),this,SLOT(openFile()));</span><br><span class="line">    connect(closeFileButton,SIGNAL(clicked()),this,SLOT(closeFile()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool MainWindow::openFile()&#123;</span><br><span class="line">    QString file_name = QFileDialog::getOpenFileName(this);</span><br><span class="line"></span><br><span class="line">    /*指向文件*/</span><br><span class="line">    file.setFileName(file_name);</span><br><span class="line">    /*判断文件是否存在*/</span><br><span class="line">    if(!file.exists())&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    /*打开文件*/</span><br><span class="line">    if(!file.open(QIODevice::ReadOnly | QIODevice::Text))&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    /*读取文本到textEdit*/</span><br><span class="line">    textEdit-&gt;setPlainText(file.readAll());</span><br><span class="line">    /*设置打开按钮不可用*/</span><br><span class="line">    openFileButton-&gt;setEnabled(false);</span><br><span class="line">    /*设置关闭按钮可用*/</span><br><span class="line">    closeFileButton-&gt;setEnabled(true);</span><br><span class="line">    file.close();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::closeFile()&#123;</span><br><span class="line">    /*检测打开按钮openFileButton是否可用,不可用时表示打开了文件*/</span><br><span class="line">    if(!openFileButton-&gt;isEnabled())&#123;</span><br><span class="line">        /*获取textEdit的文本内容*/</span><br><span class="line">        QString str = textEdit-&gt;toPlainText();</span><br><span class="line">        if(!file.open(QIODevice::WriteOnly | QIODevice::Text))&#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        QByteArray strBytes = str.toUtf8();</span><br><span class="line">        file.write(strBytes,strBytes.length());</span><br><span class="line"></span><br><span class="line">        textEdit-&gt;clear();</span><br><span class="line">        file.close();</span><br><span class="line"></span><br><span class="line">        /*重新设置按钮属性*/</span><br><span class="line">        openFileButton-&gt;setEnabled(true);</span><br><span class="line">        closeFileButton-&gt;setEnabled(false);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例"><a href="#ui示例" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/21/Qt%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/image-20230921162316212.png" alt="image-20230921162316212"></p><h3 id="QTextStream"><a href="#QTextStream" class="headerlink" title="QTextStream"></a>QTextStream</h3><p>QTextStream 类为读写文本提供了一个方便的接口，常与 QFile 结合使用。  可以使用 C++的操作符“&lt;&lt;”和“&gt;&gt;” (流提取运算符和流插入运算符)进行操作流了  </p><h5 id="代码QFile代码类似，代码部分示例"><a href="#代码QFile代码类似，代码部分示例" class="headerlink" title="代码QFile代码类似，代码部分示例"></a>代码QFile代码类似，代码部分示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*使用文本流读取文件*/</span><br><span class="line">QTextStream stream(&amp;file);</span><br><span class="line"></span><br><span class="line">/*读取文本到textEdit*/</span><br><span class="line">textEdit-&gt;setPlainText(stream.readAll());</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QTextStream stream(&amp;file);</span><br><span class="line">/*获取textEdit的文本内容，转换成字符串*/</span><br><span class="line">QString str = textEdit-&gt;toPlainText();</span><br><span class="line">/*使用流提取运算符*/</span><br><span class="line">stream&lt;&lt;str;</span><br></pre></td></tr></table></figure><h5 id="ui同QFile一致"><a href="#ui同QFile一致" class="headerlink" title="ui同QFile一致"></a>ui同QFile一致</h5>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt文件读写&quot;&gt;&lt;a href=&quot;#Qt文件读写&quot; class=&quot;headerlink&quot; title=&quot;Qt文件读写&quot;&gt;&lt;/a&gt;Qt文件读写&lt;/h2&gt;&lt;h3 id=&quot;QFile&quot;&gt;&lt;a href=&quot;#QFile&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>Qt项目控件组</title>
    <link href="http://example.com/2023/09/21/Qt%E9%A1%B9%E7%9B%AE%E6%8E%A7%E4%BB%B6%E7%BB%84/"/>
    <id>http://example.com/2023/09/21/Qt%E9%A1%B9%E7%9B%AE%E6%8E%A7%E4%BB%B6%E7%BB%84/</id>
    <published>2023-09-21T06:03:41.000Z</published>
    <updated>2023-09-21T07:24:15.556Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt项目控件组"><a href="#Qt项目控件组" class="headerlink" title="Qt项目控件组"></a>Qt项目控件组</h2><h3 id="QListWidget"><a href="#QListWidget" class="headerlink" title="QListWidget"></a>QListWidget</h3><p>QListWidget 类提供了一个基于项的列表小部件。 QListWidget 是一个便捷的类，它提供了一个类似于 QListView（下一小节将讲到）提供的列表视图，但是提供了一个用于添加和删除项目的基于项目的经典接口。 QListWidget 使用内部模型来管理列表中的每个 QListWidgetItem。  </p><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QFileDialog&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    listWidget = new QListWidget(this);</span><br><span class="line">    /*设置listWidget的大小*/</span><br><span class="line">    listWidget-&gt;setGeometry(0,0,480,480);</span><br><span class="line">    listWidget-&gt;addItem(&quot;请点击右边的添加项添加内容&quot;);</span><br><span class="line">    button = new QPushButton(this);</span><br><span class="line">    button-&gt;setGeometry(540,200,200,100);</span><br><span class="line">    button-&gt;setText(&quot;添加项&quot;);</span><br><span class="line"></span><br><span class="line">    connect(button,SIGNAL(clicked()),this,SLOT(buttonClicked()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::buttonClicked()&#123;</span><br><span class="line">    /*调用系统窗口打开文件，过滤文件名*/</span><br><span class="line">    QString file_name = QFileDialog::getOpenFileName(this,</span><br><span class="line">                                                     tr(&quot;添加项&quot;),</span><br><span class="line">                                                     &quot;&quot;,</span><br><span class="line">                                                     tr(&quot;Files(*.mp3)&quot;));</span><br><span class="line">    if(file_name != NULL)&#123;</span><br><span class="line">        listWidget-&gt;addItem(file_name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例"><a href="#ui示例" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/21/Qt%E9%A1%B9%E7%9B%AE%E6%8E%A7%E4%BB%B6%E7%BB%84/image-20230921141936691.png" alt="image-20230921141936691"></p><h3 id="QTreeWidget"><a href="#QTreeWidget" class="headerlink" title="QTreeWidget"></a>QTreeWidget</h3><p>QTreeWidget 类提供了一个使用预定义树模型的树视图。QTreeWidget 类是一个便捷的类，它提供了一个标准的树小部件，具有一个类似于 qt3 中的 QListView 类所使用的基于项目的经典接口。该类基于 Qt 的模型&#x2F;视图体系结构，并使用默认模型来保存项，每个项都是 QTreeWidgetItem。  </p><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    treeWidget = new QTreeWidget(this);</span><br><span class="line">    this-&gt;setCentralWidget(treeWidget);</span><br><span class="line"></span><br><span class="line">    /*清空列表*/</span><br><span class="line">    treeWidget-&gt;clear();</span><br><span class="line">    /*实例化顶层树节点*/</span><br><span class="line">    upItem = new QTreeWidgetItem(treeWidget);</span><br><span class="line">    upItem-&gt;setText(0,&quot;同学&quot;);</span><br><span class="line">    upItem-&gt;setFlags(Qt::ItemIsUserCheckable|</span><br><span class="line">                     Qt::ItemIsEnabled|</span><br><span class="line">                     Qt::ItemIsSelectable);</span><br><span class="line">    /*树节点设置为未选中*/</span><br><span class="line">    upItem-&gt;setCheckState(0,Qt::Unchecked);</span><br><span class="line"></span><br><span class="line">    QList &lt;QString&gt;  strList;</span><br><span class="line">    strList&lt;&lt;&quot;小明&quot;&lt;&lt;&quot;小红&quot;&lt;&lt;&quot;小蓝&quot;;</span><br><span class="line">    /*在顶层节点下面实例化3个子节点*/</span><br><span class="line">    for(int i = 0;i &lt; 3;i ++)&#123;</span><br><span class="line">        subItem[i] = new QTreeWidgetItem(upItem);</span><br><span class="line">        subItem[i]-&gt;setText(0,strList[i]);</span><br><span class="line">        /*设置子节点的属性为用户可选，项开启，项可选*/</span><br><span class="line">        subItem[i]-&gt;setFlags(Qt::ItemIsUserCheckable|</span><br><span class="line">                             Qt::ItemIsEnabled|</span><br><span class="line">                             Qt::ItemIsSelectable);</span><br><span class="line">        /*设置子节点的状态为未选中*/</span><br><span class="line">        subItem[i]-&gt;setCheckState(0,Qt::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    connect(treeWidget,SIGNAL(itemChanged(QTreeWidgetItem*,int)),this,SLOT(treeItemChanged(QTreeWidgetItem*,int)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">/*子节点跟新处理函数*/</span><br><span class="line">void MainWindow::subItemHandle(QTreeWidgetItem *item)&#123;</span><br><span class="line">    /*获取节点的上层节点*/</span><br><span class="line">    QTreeWidgetItem *parentItem = item-&gt;parent();</span><br><span class="line">    if(parentItem == NULL)&#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    /*初始化选中的数目为0,下面根据selectCount来判断树节点的状态*/</span><br><span class="line">    int selectCount = 0;</span><br><span class="line">    /*获取子节点的总数*/</span><br><span class="line">    int childCount = parentItem-&gt;childCount();</span><br><span class="line">    for(int i = 0;i &lt; childCount;i ++)&#123;</span><br><span class="line">        QTreeWidgetItem *childItem = parentItem-&gt;child(i);</span><br><span class="line">        /*判断当前节点的状态是否为选中状态，如果是则加1*/</span><br><span class="line">        if(childItem-&gt;checkState(0) == Qt::Checked)&#123;</span><br><span class="line">            selectCount ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*根据selectCount来判断树节点的状态*/</span><br><span class="line">    /*当选中的子节点小于或等于0时，则设置树节点为未选中的状态*/</span><br><span class="line">    if(selectCount &lt;= 0)&#123;</span><br><span class="line">        /*设置为未选中状态*/</span><br><span class="line">        parentItem-&gt;setCheckState(0,Qt::Unchecked);</span><br><span class="line">    &#125;else if(selectCount &gt; 0 &amp;&amp; selectCount &lt; childCount)&#123;</span><br><span class="line">        /*设置为半选中状态*/</span><br><span class="line">        parentItem-&gt;setCheckState(0,Qt::PartiallyChecked);</span><br><span class="line">    &#125;else if(selectCount == childCount)&#123;</span><br><span class="line">        /*设置为全选中状态*/</span><br><span class="line">        parentItem-&gt;setCheckState(0,Qt::Checked);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::treeItemChanged(QTreeWidgetItem *item,int value)&#123;</span><br><span class="line">    (void) value;</span><br><span class="line">    /*获取子节点个数*/</span><br><span class="line">    int count = item-&gt;childCount();</span><br><span class="line">    /*如果顶层节点被选中*/</span><br><span class="line">    if(Qt::Checked == item-&gt;checkState(0))&#123;</span><br><span class="line">        /*若选中的项是树节点,count会大于0，否则选中的项是子节点*/</span><br><span class="line">        if(count &gt; 0)&#123;</span><br><span class="line">            for(int i = 0;i &lt; count;i ++)&#123;</span><br><span class="line">                item-&gt;child(i)-&gt;setCheckState(0,Qt::Checked);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            /*子节点处理*/</span><br><span class="line">            subItemHandle(item);</span><br><span class="line">        &#125;</span><br><span class="line">        /*如果顶层节点取消选中*/</span><br><span class="line">    &#125;else if(Qt::Unchecked == item-&gt;checkState(0))&#123;</span><br><span class="line">        if(count &gt; 0)&#123;</span><br><span class="line">            /*如果选中的是树节点*/</span><br><span class="line">            for(int i = 0;i &lt; count;i ++)&#123;</span><br><span class="line">                item-&gt;child(i)-&gt;setCheckState(0,Qt::Unchecked);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            subItemHandle(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例-1"><a href="#ui示例-1" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/21/Qt%E9%A1%B9%E7%9B%AE%E6%8E%A7%E4%BB%B6%E7%BB%84/image-20230921150630642.png" alt="image-20230921150630642"></p><h3 id="QTableWidget"><a href="#QTableWidget" class="headerlink" title="QTableWidget"></a>QTableWidget</h3><p>QTableWidget 类提供了一个带有默认模型的基于项的表视图。表小部件为应用程序提供标准的表显示工具。  </p><h5 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    tableWidget = new QTableWidget();</span><br><span class="line">    this-&gt;setCentralWidget(tableWidget);</span><br><span class="line">    /*设置列数*/</span><br><span class="line">    tableWidget-&gt;setColumnCount(2);</span><br><span class="line">    /*设置行数*/</span><br><span class="line">    tableWidget-&gt;setRowCount(2);</span><br><span class="line">    /*使用标签设置水平标题标签*/</span><br><span class="line">    tableWidget-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;&quot;姓名&quot;&lt;&lt;&quot;性别&quot;);</span><br><span class="line">    QList &lt;QString&gt; strList;</span><br><span class="line">    strList&lt;&lt;&quot;小明&quot;&lt;&lt;&quot;小红&quot;&lt;&lt;&quot;男&quot;&lt;&lt;&quot;女&quot;;</span><br><span class="line">    for(int i = 0;i &lt; 4;i ++)&#123;</span><br><span class="line">        tableWidgetItem[i] = new QTableWidgetItem();</span><br><span class="line">        tableWidgetItem[i]-&gt;setText(strList[i]);</span><br><span class="line">        tableWidgetItem[i]-&gt;setTextAlignment(Qt::AlignCenter);</span><br><span class="line">    &#125;</span><br><span class="line">    /*插入数据表的index，一个二位数组数据*/</span><br><span class="line">    tableWidget-&gt;setItem(0,0,tableWidgetItem[0]);</span><br><span class="line">    tableWidget-&gt;setItem(1,0,tableWidgetItem[1]);</span><br><span class="line">    tableWidget-&gt;setItem(0,1,tableWidgetItem[2]);</span><br><span class="line">    tableWidget-&gt;setItem(1,1,tableWidgetItem[3]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例-2"><a href="#ui示例-2" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/21/Qt%E9%A1%B9%E7%9B%AE%E6%8E%A7%E4%BB%B6%E7%BB%84/image-20230921152412701.png" alt="image-20230921152412701"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt项目控件组&quot;&gt;&lt;a href=&quot;#Qt项目控件组&quot; class=&quot;headerlink&quot; title=&quot;Qt项目控件组&quot;&gt;&lt;/a&gt;Qt项目控件组&lt;/h2&gt;&lt;h3 id=&quot;QListWidget&quot;&gt;&lt;a href=&quot;#QListWidget&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
  <entry>
    <title>代码编程规范</title>
    <link href="http://example.com/2023/09/20/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://example.com/2023/09/20/%E4%BB%A3%E7%A0%81%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/</id>
    <published>2023-09-20T09:10:10.000Z</published>
    <updated>2023-09-20T09:14:17.722Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码编程规范"><a href="#代码编程规范" class="headerlink" title="代码编程规范"></a>代码编程规范</h2><h3 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h3><p>宏定义使用字母加下划线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define EXAMPLE_A_B</span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量使用小写字母加下划线</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char example_a_b;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数使用驼峰命名法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void functionExample(void)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;代码编程规范&quot;&gt;&lt;a href=&quot;#代码编程规范&quot; class=&quot;headerlink&quot; title=&quot;代码编程规范&quot;&gt;&lt;/a&gt;代码编程规范&lt;/h2&gt;&lt;h3 id=&quot;宏定义&quot;&gt;&lt;a href=&quot;#宏定义&quot; class=&quot;headerlink&quot; title=&quot;宏定义</summary>
      
    
    
    
    
    <category term="C语言" scheme="http://example.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Qt项目视图组</title>
    <link href="http://example.com/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/"/>
    <id>http://example.com/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/</id>
    <published>2023-09-20T08:03:13.000Z</published>
    <updated>2023-09-21T05:59:33.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Qt项目视图组"><a href="#Qt项目视图组" class="headerlink" title="Qt项目视图组"></a>Qt项目视图组</h2><h3 id="QListView"><a href="#QListView" class="headerlink" title="QListView"></a>QListView</h3><p>QListView 类提供模型上的列表或图标视图。  </p><p>QListView 以简单的非分层列表或图标集合的形式显示存储在模型中的项。  </p><p>QT 提供了一些现成的 models 用于处理数据项（这些是 Qt 处理数据模型的精华，如果用到Qt 数据模型，下面这些是经常要用到的）：  </p><ul><li>QStringListModel 用于存储简单的 QString 列表。  </li><li>QStandardItemModel 管理复杂的树型结构数据项，每项都可以包含任意数据。  </li><li>QDirModel 提供本地文件系统中的文件与目录信息。  </li><li>QSqlQueryModel, QSqlTableModel,QSqlRelationTableModel 用来访问数据库。</li></ul><h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    listView = new QListView(this);</span><br><span class="line">    this-&gt;setCentralWidget(listView);</span><br><span class="line"></span><br><span class="line">    QStringList strList;</span><br><span class="line">    strList&lt;&lt;&quot;高三(1)班&quot;&lt;&lt;&quot;高三(2)班&quot;&lt;&lt;&quot;高三(3)班&quot;&lt;&lt;&quot;高三(4)班&quot;;</span><br><span class="line"></span><br><span class="line">    /*实例化字符串模型*/</span><br><span class="line">    stringListModel = new QStringListModel(strList);</span><br><span class="line">    /*向表中插入一段数据*/</span><br><span class="line">    listView-&gt;setModel(stringListModel);</span><br><span class="line">    /*设置视图为图标模式*/</span><br><span class="line">    listView-&gt;setViewMode(QListView::IconMode);</span><br><span class="line">    /*设置为不可拖动*/</span><br><span class="line">    listView-&gt;setDragEnabled(false);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例"><a href="#ui示例" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/image-20230920162231401.png" alt="image-20230920162231401"></p><h3 id="QTreeView"><a href="#QTreeView" class="headerlink" title="QTreeView"></a>QTreeView</h3><p>QTreeView 类提供树视图的默认模型&#x2F;视图实现。 QTreeView 实现了模型项的树表示。  要使一个 QTreeView 能够显示数据，需要构造一个 model 并设置 QTreeView。 Qt 提供了一些类型的 Model，其中最常用的就是这个<br>QStandardItemModel 类，一般可以满足大部分需求。  另外，表头的内容也由这个 model管理，setHorizontalHeaderLabels  函数可以设置共有多少列、每列文字。一级标题直接使用 appendRow方法添加到 model 上，次级标题则是添加到第一个父级标题上，依次构成父子关系树。  </p><h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QStandardItem&gt;</span><br><span class="line">#include &lt;QStandardItemModel&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line">    treeView = new QTreeView(this);</span><br><span class="line"></span><br><span class="line">    this-&gt;setCentralWidget(treeView);</span><br><span class="line"></span><br><span class="line">    /*构建modle*/</span><br><span class="line">    QStandardItemModel *sdiModule = new QStandardItemModel(treeView);</span><br><span class="line">    sdiModule-&gt;setHorizontalHeaderLabels(QStringList()&lt;&lt;QStringLiteral(&quot;标题&quot;)</span><br><span class="line">                                         &lt;&lt; QStringLiteral(&quot;名称&quot;));</span><br><span class="line">    for(int i = 0;i &lt; 5;i ++)&#123;</span><br><span class="line">        /*一级标题*/</span><br><span class="line">        QList &lt;QStandardItem *&gt; items1;</span><br><span class="line">        QStandardItem *item1 = new QStandardItem(QString::number(i));</span><br><span class="line">        QStandardItem *item2 = new QStandardItem(QStringLiteral(&quot;一级标题&quot;));</span><br><span class="line">        /*添加项1*/</span><br><span class="line">        items1.append(item1);</span><br><span class="line">        /*添加项2*/</span><br><span class="line">        items1.append(item2);</span><br><span class="line">        /*将items1添加到sdiModule*/</span><br><span class="line">        sdiModule-&gt;appendRow(items1);</span><br><span class="line">        for(int j = 0;j &lt; 5;j ++)&#123;</span><br><span class="line">            /*在一级标题后面插入二级标题*/</span><br><span class="line">            QList &lt;QStandardItem *&gt; items2;</span><br><span class="line">            QStandardItem * item3 = new QStandardItem(QString::number(j));</span><br><span class="line">            QStandardItem * item4 = new QStandardItem(QStringLiteral(&quot;二级标题&quot;));</span><br><span class="line"></span><br><span class="line">            items2.append(item3);</span><br><span class="line">            items2.append(item4);</span><br><span class="line">            item1-&gt;appendRow(items2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    treeView-&gt;setModel(sdiModule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例-1"><a href="#ui示例-1" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/image-20230921102401703.png" alt="image-20230921102401703"></p><h3 id="QTableView"><a href="#QTableView" class="headerlink" title="QTableView"></a>QTableView</h3><p>QTableView 类提供了表视图的默认模型&#x2F;视图实现。 QTableView 实现了一个表视图，用于显示来自模型的项。  Qt 提供了一些类型的 Model，其中最常用的就是这个QStandardItemModel 类，一般可以满足大部分需求。另外，表头的内容也由这个 model 管理，setHorizontalHeaderLabels 函数可以设置共有多少列、每列文字。  </p><h5 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QStandardItemModel&gt;</span><br><span class="line">#include &lt;QHeaderView&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    tableView = new QTableView(this);</span><br><span class="line">    this-&gt;setCentralWidget(tableView);</span><br><span class="line"></span><br><span class="line">    /*显示网格线*/</span><br><span class="line">    tableView-&gt;setShowGrid(true);</span><br><span class="line"></span><br><span class="line">    QStandardItemModel *model = new QStandardItemModel();</span><br><span class="line">    QStringList lables = QObject::tr(&quot;语文,数学,英语&quot;).simplified().split(&quot;,&quot;);</span><br><span class="line">    /*设置水平头标签*/</span><br><span class="line">    model-&gt;setHorizontalHeaderLabels(lables);</span><br><span class="line">    /*model插入内容*/</span><br><span class="line">    QStandardItem * item = 0;</span><br><span class="line">    for(int i = 0;i &lt; 5;i ++)&#123;</span><br><span class="line">        item = new  QStandardItem(&quot;80&quot;);</span><br><span class="line">        model-&gt;setItem(i,0,item);</span><br><span class="line">        item = new  QStandardItem(&quot;90&quot;);</span><br><span class="line">        model-&gt;setItem(i,1,item);</span><br><span class="line">        item = new  QStandardItem(&quot;100&quot;);</span><br><span class="line">        model-&gt;setItem(i,2,item);</span><br><span class="line">    &#125;</span><br><span class="line">    /*将model设置给tableView*/</span><br><span class="line">    tableView-&gt;setModel(model);</span><br><span class="line">    /*平均分列*/</span><br><span class="line">    tableView-&gt;horizontalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch);</span><br><span class="line">    /*平均分行*/</span><br><span class="line">    tableView-&gt;verticalHeader()-&gt;setSectionResizeMode(QHeaderView::Stretch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例-2"><a href="#ui示例-2" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/image-20230921104143600.png" alt="image-20230921104143600"></p><h3 id="QColumnView"><a href="#QColumnView" class="headerlink" title="QColumnView"></a>QColumnView</h3><p>QColumnView 在许多 QListViews 中显示一个模型，每个 QListViews 对应树中的每个层次结构。这有时被称为级联列表。 QColumnView 类是模型&#x2F;视图类之一，是 Qt 模型&#x2F;视图框架的一部分。   </p><h5 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QStandardItem&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    this-&gt;setGeometry(0,0,800,480);</span><br><span class="line"></span><br><span class="line">    columnView = new QColumnView(this);</span><br><span class="line">    this-&gt;setCentralWidget(columnView);</span><br><span class="line"></span><br><span class="line">    QStandardItemModel *model = new QStandardItemModel(this);</span><br><span class="line">    /*省份*/</span><br><span class="line">    QStandardItem *province = new QStandardItem(&quot;四川省&quot;);</span><br><span class="line">    /*城市*/</span><br><span class="line">    QStandardItem *city1 = new QStandardItem(&quot;成都市&quot;);</span><br><span class="line">    QStandardItem *city2 = new QStandardItem(&quot;绵阳市&quot;);</span><br><span class="line">    /*将城市添加到省份*/</span><br><span class="line">    province-&gt;appendRow(city1);</span><br><span class="line">    province-&gt;appendRow(city2);</span><br><span class="line"></span><br><span class="line">    /*区域*/</span><br><span class="line">    QStandardItem *area1 = new QStandardItem(&quot;武侯区&quot;);</span><br><span class="line">    QStandardItem *area2 = new QStandardItem(&quot;金牛区&quot;);</span><br><span class="line">    /*将区域添加到城市*/</span><br><span class="line">    city1-&gt;appendRow(area1);</span><br><span class="line">    city1-&gt;appendRow(area2);</span><br><span class="line"></span><br><span class="line">    model-&gt;appendRow(province);</span><br><span class="line">    columnView-&gt;setModel(model);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例-3"><a href="#ui示例-3" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/image-20230921105547479.png" alt="image-20230921105547479"></p><h3 id="QundoView"><a href="#QundoView" class="headerlink" title="QundoView"></a>QundoView</h3><p>QUndoView 类显示 QUndoStack 的内容。 QUndoView 是一个QListView，它显示在撤销堆栈上推送的命令列表。总是选择最近执行的命令。选择不同的命令会导致调用QUndoStack::setIndex()，将文档的状态向后或向前滚动到新命令。可以使用setStack()显式地设置堆栈。  </p><h5 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h5><p>mainWindow.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    /* 设置主窗体显示的位置与大小 */</span><br><span class="line">    this-&gt;setGeometry(0, 0, 800, 480);</span><br><span class="line"></span><br><span class="line">    /* 实例一个水平布局，用于左侧按钮区域与右侧历史记录面板 */</span><br><span class="line">    hLayout = new QHBoxLayout();</span><br><span class="line"></span><br><span class="line">    /* 实例一个水平布局，用于左侧标签与按钮 */</span><br><span class="line">    vLayout = new QVBoxLayout();</span><br><span class="line"></span><br><span class="line">    /* 主Widget, 因为MainWindow自带一个布局，</span><br><span class="line">     * 我们要新建一个Widget容纳新布局</span><br><span class="line">     */</span><br><span class="line">    mainWidget = new QWidget();</span><br><span class="line"></span><br><span class="line">    /* 用于存放命令行栈 */</span><br><span class="line">    undoStack = new QUndoStack(this);</span><br><span class="line"></span><br><span class="line">    /* 用于容纳左侧标签与按钮布局 */</span><br><span class="line">    widget = new QWidget();</span><br><span class="line"></span><br><span class="line">    /* 历史记录面板实例化 */</span><br><span class="line">    undoView = new QUndoView(undoStack);</span><br><span class="line"></span><br><span class="line">    /* 实例化一个按钮，用于加一操作 */</span><br><span class="line">    pushButton = new QPushButton();</span><br><span class="line"></span><br><span class="line">    /* 标签，用于显示计算结果 */</span><br><span class="line">    label = new QLabel();</span><br><span class="line"></span><br><span class="line">    /* 设置widget的大小 */</span><br><span class="line">    widget-&gt;setMinimumSize(400, 480);</span><br><span class="line"></span><br><span class="line">    /* 将两个widget添加到水平布局 */</span><br><span class="line">    hLayout-&gt;addWidget(widget);</span><br><span class="line">    hLayout-&gt;addWidget(undoView);</span><br><span class="line"></span><br><span class="line">    /* 初始化count的值 */</span><br><span class="line">    count = 0;</span><br><span class="line"></span><br><span class="line">    /* 显示初始化计算结果 */</span><br><span class="line">    label-&gt;setText(&quot;计算结果：&quot; + QString::number(count));</span><br><span class="line">    label-&gt;setAlignment(Qt::AlignCenter);</span><br><span class="line"></span><br><span class="line">    /* 左侧布局 */</span><br><span class="line">    vLayout-&gt;addWidget(label);</span><br><span class="line">    vLayout-&gt;addWidget(pushButton);</span><br><span class="line"></span><br><span class="line">    /* 左侧布局控件的高度设置 */</span><br><span class="line">    label-&gt;setMaximumHeight(this-&gt;height() / 5);</span><br><span class="line">    pushButton-&gt;setMaximumHeight(this-&gt;height() / 5);</span><br><span class="line"></span><br><span class="line">    /* 按钮文件设置 */</span><br><span class="line">    pushButton-&gt;setText(&quot;加1&quot;);</span><br><span class="line"></span><br><span class="line">    /* 设置widget的布局为vLayout */</span><br><span class="line">    widget-&gt;setLayout(vLayout);</span><br><span class="line"></span><br><span class="line">    /* 将主窗体的布局设置为hLayout */</span><br><span class="line">    mainWidget-&gt;setLayout(hLayout);</span><br><span class="line"></span><br><span class="line">    /* 设置mainWidget为主窗体的居中widget */</span><br><span class="line">    this-&gt;setCentralWidget(mainWidget);</span><br><span class="line"></span><br><span class="line">    /* 信号槽连接，按钮点击，执行加一操作 */</span><br><span class="line">    connect(pushButton, SIGNAL(clicked()), this,</span><br><span class="line">            SLOT(pushButtonClieked()));</span><br><span class="line"></span><br><span class="line">    /* 信号槽连接，历史记录项index发生变化，显示count大小 */</span><br><span class="line">    connect(undoStack, SIGNAL(indexChanged(int) ),</span><br><span class="line">            this, SLOT(showCountValue(int)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 入栈操作会自动调用addCommand的redo */</span><br><span class="line">void MainWindow::pushButtonClieked()</span><br><span class="line">&#123;</span><br><span class="line">    /* 变量值加一 */</span><br><span class="line">    count++;</span><br><span class="line"></span><br><span class="line">    /* value指向count的地址 */</span><br><span class="line">    int *value = &amp;count;</span><br><span class="line"></span><br><span class="line">    /* 用重写的addCommand类实例化 */</span><br><span class="line">    QUndoCommand *add = new addCommand(value);</span><br><span class="line"></span><br><span class="line">    /* 入栈 */</span><br><span class="line">    undoStack-&gt;push(add);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::showCountValue(int)</span><br><span class="line">&#123;</span><br><span class="line">    /* 标签用于显示计算结果 */</span><br><span class="line">    label-&gt;setText(&quot;计算结果：&quot; + QString::number(count));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>command.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#ifndef COMMAND_H</span><br><span class="line">#define COMMAND_H</span><br><span class="line"></span><br><span class="line">#include &lt;QUndoCommand&gt;</span><br><span class="line">#include &lt;QObject&gt;</span><br><span class="line"></span><br><span class="line">class addCommand : public QUndoCommand</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    addCommand(int *value, QUndoCommand* parent = 0);</span><br><span class="line">    ~addCommand();</span><br><span class="line"></span><br><span class="line">    /* 重写重做与撤回方法 */</span><br><span class="line">    void redo() override;</span><br><span class="line">    void undo() override;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    /* 新的count */</span><br><span class="line">    int *new_count;</span><br><span class="line"></span><br><span class="line">    /* 旧的count */</span><br><span class="line">    int old_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif // COMMAND_H</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>command.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;command.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">addCommand::addCommand(int *value, QUndoCommand *parent)</span><br><span class="line">&#123;</span><br><span class="line">    /* 使用Q_UNUSED,避免未使用的数据类型 */</span><br><span class="line">    Q_UNUSED(parent);</span><br><span class="line"></span><br><span class="line">    /* undoView显示的操作信息 */</span><br><span class="line">    setText(&quot;进行了加1操作&quot;);</span><br><span class="line"></span><br><span class="line">    /* value的地址赋值给new_count */</span><br><span class="line">    new_count = value;</span><br><span class="line"></span><br><span class="line">    /* 让构造函数传过来的*new_count的值赋值给old_count */</span><br><span class="line">    old_count = *new_count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 执行stack push时或者重做操作时会自动调用 */</span><br><span class="line">void addCommand::redo()</span><br><span class="line">&#123;</span><br><span class="line">    /* 重新赋值给new_count */</span><br><span class="line">    *new_count = old_count;</span><br><span class="line"></span><br><span class="line">    /* 打印出*new_count的值 */</span><br><span class="line">    qDebug()&lt;&lt;&quot;redo:&quot;&lt;&lt;*new_count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/* 回撤操作时执行 */</span><br><span class="line">void addCommand::undo()</span><br><span class="line">&#123;</span><br><span class="line">    /* 回撤操作每次应减一 */</span><br><span class="line">    (*new_count)--;</span><br><span class="line"></span><br><span class="line">    /* 打印出*new_count的值 */</span><br><span class="line">    qDebug()&lt;&lt;&quot;undo:&quot;&lt;&lt;*new_count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addCommand::~addCommand()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ui示例-4"><a href="#ui示例-4" class="headerlink" title="ui示例"></a>ui示例</h5><p><img src="/2023/09/20/Qt%E9%A1%B9%E7%9B%AE%E8%A7%86%E5%9B%BE%E7%BB%84/image-20230921135931326.png" alt="image-20230921135931326"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Qt项目视图组&quot;&gt;&lt;a href=&quot;#Qt项目视图组&quot; class=&quot;headerlink&quot; title=&quot;Qt项目视图组&quot;&gt;&lt;/a&gt;Qt项目视图组&lt;/h2&gt;&lt;h3 id=&quot;QListView&quot;&gt;&lt;a href=&quot;#QListView&quot; class=&quot;header</summary>
      
    
    
    
    
    <category term="Qt" scheme="http://example.com/tags/Qt/"/>
    
  </entry>
  
</feed>
